<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKECAT</title>
    <updated>2025-05-12T04:35:45.809Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2025, LIKECAT</rights>
    <entry>
        <title type="html"><![CDATA[SSO 和 OAuth2.0 ]]></title>
        <id>https://q456qq520.github.io/post/sso-he-oauth20/</id>
        <link href="https://q456qq520.github.io/post/sso-he-oauth20/">
        </link>
        <updated>2025-05-12T03:33:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-简介">一、简介</h2>
<ul>
<li>
<p>SSO：单点登录。SSO用于在一处系统中登录， 切换到其他系统时，不必再次输入用户名密码。</p>
</li>
<li>
<p>OAuth2.0：开放授权。 OAuth 2.0授权框架允许第三方应用程序通过协调资源所有者和HTTP服务之间的审批交互，或允许第三方应用程序自己获得访问权限，从而获得对HTTP服务的有限访问。也就是授权别人(client)访问我们的资源。</p>
</li>
</ul>
<p>区别：SSO和OAuth2.0在应用场景上的区别在于，SSO是为了解决一个用户在鉴权服务器登陆过一次以后，可以在任何应用（通常是一个厂家的各个系统）中畅通无阻。OAuth2.0解决的是通过令牌（token）而不是密码获取某个系统的操作权限（不同厂家之间的账号共享）。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>SSO</th>
<th>OAuth2.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>含义</td>
<td>Single Sign On，单点登录</td>
<td>OAuth 的 2.0 版本</td>
</tr>
<tr>
<td>本质</td>
<td>一种思想 / 解决方案，抽象的</td>
<td>一种协议，具体的</td>
</tr>
<tr>
<td>应用场景</td>
<td>一次鉴权，畅通多个应用</td>
<td>发放令牌，授予操作权限</td>
</tr>
<tr>
<td>在业务系统中存储账密</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>验证用户身份的方式</td>
<td>session、cookie、token</td>
<td>token</td>
</tr>
<tr>
<td>互相信任的应用群</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>资源提供方</td>
<td>客户端+用户</td>
<td>用户</td>
</tr>
</tbody>
</table>
<h2 id="二-sso">二、SSO</h2>
<p>SSO实现的最关键是，在传统的多应用切换中，面临着cookie 跨域和session共享的问题，解决这两个问题是实现SSO(CAS)的关键。</p>
<p>下面介绍了一种单点登录的方式CAS(中央认证服务Central Authentication Service)</p>
<h3 id="21-cas">2.1 CAS</h3>
<ol>
<li>CAS是对用户的账号和密码进行保存，同时也记录着用户与资源关系（是否可以访问资源）。</li>
<li>各个业务系统获得的信息是，这个用户能不能访问我的资源。资源都在各个业务那边。</li>
<li>用户登陆成功后会获得Ticket，CAS给业务系统一个Ticket，业务系统是不能确定这个Ticket是否是用户伪造的，还是真的有效，所以要拿着这个Ticket去CAS服务器再问一下，这个用户给我的Token是否有效，以及会询问当前用户在我系统中的权限是什么样子的。</li>
</ol>
<h3 id="22-cas实现流程">2.2 CAS实现流程</h3>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1747021394744.webp" alt="" loading="lazy"></figure>
<p>上图具体流程如下：</p>
<ol>
<li>用户访问APP1系统，APP1系统是需要登录的，但用户现在没有登录。</li>
<li>跳转到CAS server，即SSO登录系统。SSO系统也没有登录，弹出用户登录页。</li>
<li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的Session，浏览器（Browser）中写入SSO域下的Cookie。【此处的Cookie可以确保不用重复登陆SSO系统】</li>
<li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到APP1系统，同时将ST作为参数传递给APP1系统。</li>
<li>APP1系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li>
<li>验证通过后，APP1系统将登录状态写入Session并设置APP1域下的Cookie。【仅仅是在APP1域下的Cookie】</li>
</ol>
<p>至此，跨域单点登录就完成了。以后我们再访问APP1系统时，用户状态就已经有了。接下来，我们再看看访问APP2系统时的流程。</p>
<ol>
<li>用户访问APP2系统，app2系统没有登录，跳转到SSO。</li>
<li>由于SSO已经登录了，不需要重新登录认证。【在APP1登陆成功后写入的Cookie】</li>
<li>SSO生成ST，浏览器跳转到APP2系统，并将ST作为参数传递给APP2。</li>
<li>APP2拿到ST，后台访问SSO，验证ST是否有效。</li>
<li>验证成功后，app2将登录状态写入Session，并在app2域下写入Cookie。</li>
</ol>
<p>这样，APP2系统不需要走登录流程，就已经是登录了。SSO，APP1和APP2在不同的域下，它们之间的Session不应该是的共享的，这样可以更加保证用户信息安全。</p>
<h2 id="三-oauth2">三、OAuth2</h2>
<p>OAuth 2.0授权框架支持第三方支持访问有限的HTTP服务，通过在资源所有者和HTTP服务之间进行一个批准交互来代表资源者去访问这些资源，或者通过允许第三方应用程序以自己的名义获取访问权限。</p>
<p>对应资源解释：</p>
<ol>
<li>资源所有者（Resource Owner）：很多时候就是我们普通人（但不限于普通人，如某些应用程序也会创建资源），拥有资源的所有权。</li>
<li>资源服务器（Resource Server）：保存着受保护的用户资源。（微信个人信息服务器）</li>
<li>应用程序（Client）：准备访问用户资源的应用程序，其可能是一个web应用，或是一个后端web服务应用，或是一个移动端应用，也或是一个桌面可执行程序。（第三方应用）</li>
<li>授权服务器（Authorization Server）：授权服务器，在获取用户的同意授权后，颁发访问令牌给应用程序，以便其获取用户资源。（微信授权服务器）</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1747022741690.webp" alt="" loading="lazy"></figure>
<h3 id="31-授权码模式">3.1 授权码模式</h3>
<ol>
<li>用户在第三方应用程序中，应用程序尝试获取用户保存在 微信资源服务器上 的信息，比如用户的身份信息和头像，应用程序首先让重定向用户到授权服务器，告知申请资源的读权限，并提供自己的client id。</li>
<li>到授权服务器，用户输入用户名和密码，服务器对其认证成功后，提示用户即将要颁发一个读权限给应用程序，在用户确认后，授权服务器颁发一个授权码（authorization code）并重定向用户回到应用程序。</li>
<li>应用程序获取到授权码之后，使用这个授权码和自己的Client id/Secret向认证服务器 申请访问令牌/刷新令牌（access token/refresh token）。授权服务器对这些信息进行校验，如果一切OK，则颁发给应用程序。</li>
<li>应用程序在拿到访问令牌之后，向资源服务器申请用户的资源信息</li>
<li>资源服务器在获取到访问令牌后，对令牌进行解析（如果令牌已加密，则需要进行使用相应算法进行解密）并校验，并向授权服务器校验其合法性，如果一起OK，则返回应用程序所需要的资源信息。</li>
</ol>
<p>注意的是，访问令牌对于应用程序来说是透明的，应用程序无需关注访问令牌所带的任何信息，只需在访问资源服务器时带上它。但是资源服务器需要知道访问令牌的组成和加密方式，资源服务器需要解析或解密这个访问令牌，查看并校验里面的信息。</p>
<h3 id="32-简化模式">3.2 简化模式</h3>
<p>这种场景经常运用应用程序没有服务端的情况。 应用程序运行在客户端，一个最大的变化就是其变成了公开应用程序（Public Client），应用程序的运行完全暴露在用户的控制之中。在这种场景下，应用程序是无法隐藏自己的一些敏感数据，比如client secret和授权码，在这个方式下，再向授权服务器获取授权码是多此一举。</p>
<p>为此OAuth 2.0提供简化模式，授权服务器在校验好用户信息后，直接颁发给应用程序访问资源服务器的访问令牌。换句话说，<code>应用程序在获取访问令牌时无需提供授权码和client secret</code>。</p>
<p>整个授权流程如下，</p>
<ol>
<li>用户在应用程序中，应用程序尝试获取用户保存在资源服务器上的信息，比如用户的身份信息和头像，应用程序首先让用户重定向到授权服务器，告知申请资源的读权限，并提供自己的client id。在重定向的过程中，应用程序指定使用Implicit Grant授权方式。</li>
<li>在授权服务器，用户输入用户名和密码，服务器对其认证成功后，提示用户即将要颁发一个读权限给应用程序，在用户确认后，授权服务器直接颁发一个访问令牌并重定向用户回到应用程序。</li>
<li>应用程序在拿到访问令牌之后，向资源服务器申请用户的资源信息</li>
<li>资源服务器在获取到访问令牌后，对令牌进行解析（如果令牌已加密，则需要进行使用相应算法进行解密）并校验，并向授权服务器校验其合法性，如果一起OK，则返回应用程序所需要的资源信息。</li>
</ol>
<p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p>
<h3 id="33-应用授信">3.3 应用授信</h3>
<p>这种授信模式特点是：应用程序角色本身就是资源所有者 （应用程序和资源服务器之间是完全可信的）</p>
<p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p>
<ol>
<li>应用程序尝试获取在资源服务器上的信息，应用程序直接向授权服务器申请访问令牌，告知申请资源的读权限，并提供自己的授信凭证（client id/secret）。在申请请求中，应用程序指定使用client credentials授权方式。在授权服务器，服务器对其client credentials校验成功后，授权服务器直接颁发一个访问令牌给应用程序。</li>
<li>应用程序在拿到访问令牌之后，向资源服务器申请用户的资源信息。</li>
<li>资源服务器在获取到访问令牌后，对令牌进行解析（如果令牌已加密，则需要进行使用相应算法进行解密）并校验，并向授权服务器校验其合法性，如果一起OK，则返回应用程序所需要的资源信息。</li>
</ol>
<p>这个授权流程被称为应用授信模式，其命名原因是由于应用程序是通过自己的授信凭证（client id/secret）直接向授权服务器申请访问令牌。这种模式一般用在可信的应用程序。</p>
<h3 id="34-用户授信模式">3.4 用户授信模式</h3>
<p>在基本的授权码模式中，用户需要跳转到授权服务器上，使用用户名和密码登录后拿到授权码，然后把授权码交给应用程序，然后再去申请访问令牌。</p>
<p>用户授信模式流程如下，</p>
<ol>
<li>用户在应用程序中，应用程序首先让用户到登录页面输入用户名和密码。</li>
<li>应用程序拿到资源所有者的用户名和密码，加上自己的client id/secret一同向认证服务器申请访问令牌/刷新令牌。授权服务器对这些信息进行校验，如果通过，则颁发给应用程序访问令牌/刷新令牌。</li>
<li>应用程序在拿到访问令牌/刷新令牌之后，向资源服务器申请用户的资源信息。</li>
<li>资源服务器在获取到访问令牌后，对令牌进行解析（如果令牌已加密，则需要进行使用相应算法进行解密）并校验，并向授权服务器校验其合法性，如果一起OK，则返回应用程序所需要的资源信息。</li>
</ol>
<h3 id="35-四种授权模式的联系和区别">3.5 四种授权模式的联系和区别</h3>
<p>各个模式获取访问令牌的手段:</p>
<ul>
<li>授权码模式：授权码+应用的授信凭据</li>
<li>简化模式：应用client id + 用户的授信凭据</li>
<li>应用授信模式：应用的授信凭据</li>
<li>用户授信模式：应用的授信凭据+用户的授信凭据</li>
</ul>
<p>这四种授权模式中，授权码模式是基本的授权模式。</p>
<ol>
<li>授权码模式：基本授权模式，它需要有四个角色同时在场才能完成授权：资源所有者、应用程序、授权服务器、资源服务器。</li>
<li>简化模式：开放应用程序，应用程序运行在公开开放的环境。即：无需应用程序的认证。</li>
<li>应用授信模式：应用程序即为资源所有者，或资源所有者不参与授权交互。即：无资源所有者的认证。</li>
<li>用户授信模式：无授权码的颁发过程，直接通过用户名和密码换取授权。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解析Jdk与Cglib代理]]></title>
        <id>https://q456qq520.github.io/post/jie-xi-jdk-yu-cglib-dai-li/</id>
        <link href="https://q456qq520.github.io/post/jie-xi-jdk-yu-cglib-dai-li/">
        </link>
        <updated>2025-05-11T05:45:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-jdk动态代理">一、JDK动态代理</h1>
<h2 id="11-jdk动态代理简介">1.1 JDK动态代理简介</h2>
<p>JDK动态代理是Java语言提供的一种实现动态代理的方式，其基本原理是利用反射机制在运行时动态生成代理类和代理对象。</p>
<h3 id="111-基本原理">1.1.1 基本原理</h3>
<ol>
<li>接口定义：定义一个接口（或者是一组接口），用于描述需要被代理的行为。</li>
<li>InvocationHandler接口：编写一个实现了<code>InvocationHandle</code>r接口的类，该类负责实际的代理逻辑。InvocationHandler接口只有一个方法<code>invoke(Object proxy, Method method, Object[] args)</code>，当代理对象的方法被调用时，invoke方法会被调用，并在其中执行代理逻辑。</li>
<li>Proxy类：使用<code>Proxy</code>类的<code>newProxyInstance</code>方法动态地创建代理对象。newProxyInstance方法接受三个参数：ClassLoader、一个接口数组和一个InvocationHandler对象。在运行时，Proxy类会动态生成一个实现了指定接口的代理类，并通过传入的InvocationHandler对象来调用实际的代理逻辑。</li>
<li>代理对象调用：当调用代理对象的方法时，实际上是调用了InvocationHandler接口的invoke方法，该方法会根据被调用的方法和传入的参数执行相应的代理逻辑。</li>
</ol>
<h3 id="112-使用场景">1.1.2 使用场景</h3>
<p>日志记录：通过代理可以在方法执行前后记录日志，实现日志记录的功能。<br>
性能监控：可以在方法执行前后记录方法的执行时间，从而进行性能监控。<br>
事务管理：在方法执行前后开启和提交事务，实现事务管理的功能。<br>
权限控制：在方法执行前进行权限验证，实现权限控制的功能。<br>
远程调用：可以通过代理在调用远程对象的方法时添加网络通信的逻辑，实现远程调用的功能。</p>
<h2 id="12-spring-如何利用动态代理实现-aop">1.2 Spring 如何利用动态代理实现 AOP</h2>
<p>Spring AOP的实现基于<code>代理模式</code>和<code>装饰器模式</code>，在目标方法执行前后或异常抛出时，通过代理对象来执行额外的逻辑，如日志记录、事务管理、权限控制等。通过配置<code>切面</code>和<code>通知</code>，可以将这些额外逻辑统一地应用到多个目标类的方法中，从而实现横切关注点的分离和复用。</p>
<p>在Spring AOP中，主要利用了JDK动态代理和CGLIB动态代理两种方式。</p>
<ol>
<li>JDK动态代理：</li>
</ol>
<ul>
<li>当被代理的目标对象实现了接口时，Spring会使用JDK动态代理。</li>
<li>Spring AOP利用java.lang.reflect.Proxy类来创建代理对象，该类要求被代理的类必须实现至少一个接口。</li>
<li>Spring在运行时动态生成了一个实现了相同接口的代理对象，代理对象中的方法会委托给InvocationHandler接口的实现类来执行增强逻辑。</li>
<li>JDK动态代理的优势在于它不需要引入额外的库，但缺点是被代理的类必须实现接口。</li>
</ul>
<ol>
<li>CGLIB动态代理：</li>
</ol>
<ul>
<li>当被代理的目标对象没有实现接口时，Spring会使用CGLIB动态代理。</li>
<li>CGLIB是一个强大的，高性能的代码生成库，它通过在运行时生成字节码的方式来动态创建代理类。</li>
<li>Spring AOP利用CGLIB来生成被代理对象的子类，并在子类中重写需要增强的方法，将增强逻辑织入到重写的方法中。</li>
<li>CGLIB动态代理的优势在于它可以代理没有实现接口的类，但缺点是需要引入CGLIB库，并且生成的代理类会比较庞大。</li>
</ul>
<h2 id="13-jdkdynamicaopproxy-类">1.3 JdkDynamicAopProxy 类</h2>
<h3 id="131-jdkdynamicaopproxy-类结构">1.3.1 JdkDynamicAopProxy 类结构</h3>
<p><code>JdkDynamicAopProxy</code>类的实现做一些准备工作，包括声明变量、初始化变量、定义静态成员等。</p>
<pre><code class="language-java">//final 类不能被继承
final class JdkDynamicAopProxy implements org.springframework.aop.framework.AopProxy, InvocationHandler, Serializable {

	/** use serialVersionUID from Spring 1.2 for interoperability. */
	private static final long serialVersionUID = 5531744639992436476L;


	private static final String COROUTINES_FLOW_CLASS_NAME = &quot;kotlinx.coroutines.flow.Flow&quot;;

	private static final boolean coroutinesReactorPresent = ClassUtils.isPresent(
			&quot;kotlinx.coroutines.reactor.MonoKt&quot;, JdkDynamicAopProxy.class.getClassLoader());

	/** We use a static Log to avoid serialization issues. */
	private static final Log logger = LogFactory.getLog(JdkDynamicAopProxy.class);

	/** Config used to configure this proxy. 用于保存代理配置信息 */
	private final org.springframework.aop.framework.AdvisedSupport advised;

	/** Cached in {@link org.springframework.aop.framework.AdvisedSupport#proxyMetadataCache}.
	 *  保存被代理的接口
	 * */
	private transient ProxiedInterfacesCache cache;
    
}
</code></pre>
<pre><code class="language-java">/**
	 * Holder for the complete proxied interfaces and derived metadata,
	 * to be cached in {@link org.springframework.aop.framework.AdvisedSupport#proxyMetadataCache}.
	 * @since 6.1.3
	 */
	private static final class ProxiedInterfacesCache {

		//保存被代理的接口
		final Class&lt;?&gt;[] proxiedInterfaces;

		//表示被代理的接口是否定义类equals方法
		final boolean equalsDefined;

		final boolean hashCodeDefined;
}
</code></pre>
<h3 id="132-getproxy-方法的实现">1.3.2 getProxy 方法的实现</h3>
<pre><code class="language-java">//重写父类的接口或者方法
@Override
public Object getProxy() {//使用默认类加载器
    return getProxy(ClassUtils.getDefaultClassLoader());
}

@Override
public Object getProxy(@Nullable ClassLoader classLoader) {//允许传入自定义类加载器
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Creating JDK dynamic proxy: &quot; + this.advised.getTargetSource());
    }
    return Proxy.newProxyInstance(determineClassLoader(classLoader), this.cache.proxiedInterfaces, this);
}
</code></pre>
<h3 id="133-determineclassloader-方法的实现">1.3.3 determineClassLoader 方法的实现</h3>
<pre><code class="language-java">/**
    * Determine whether the JDK bootstrap or platform loader has been suggested -&gt;
    * use higher-level loader which can see Spring infrastructure classes instead.
    * 确定最终使用的类加载器
    */
private ClassLoader determineClassLoader(@Nullable ClassLoader classLoader) {
    if (classLoader == null) {
        // JDK bootstrap loader -&gt; use spring-aop ClassLoader instead.
        //返回当前类的类加载器，通常是应用程序类加载器
        return getClass().getClassLoader();
    }
    if (classLoader.getParent() == null) {
        // Potentially the JDK platform loader on JDK 9+
        //获取当前类的类加载器
        ClassLoader aopClassLoader = getClass().getClassLoader();
        //获取父类加载器
        ClassLoader aopParent = aopClassLoader.getParent();
        while (aopParent != null) {//找到最顶层父类加载器
            if (classLoader == aopParent) {
                // Suggested ClassLoader is ancestor of spring-aop ClassLoader
                // -&gt; use spring-aop ClassLoader itself instead.
                //如果当前类加载器等于当前父类加载器，直接返回
                return aopClassLoader;
            }
            aopParent = aopParent.getParent();
        }
    }
    // Regular case: use suggested ClassLoader as-is.
    return classLoader;
}
</code></pre>
<h3 id="134-newproxyinstance-方法的实现">1.3.4 newProxyInstance 方法的实现</h3>
<p>主要用于创建代理实例，其中包含了一些安全性检查和异常处理。</p>
<pre><code class="language-java">//传入类加载器、代理接口数组、调用处理程序
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                        Class&lt;?&gt;[] interfaces,
                                        InvocationHandler h)
    throws IllegalArgumentException
{
    //检查调用处理程序是否为null
    Objects.requireNonNull(h);

    //复制接口数组，确保不会修改原始数组
    final Class&lt;?&gt;[] intfs = interfaces.clone();
    final SecurityManager sm = System.getSecurityManager();
    //安全检查
    if (sm != null) {
        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
    }

    /*
    * Look up or generate the designated proxy class.
    * 生存代理对象
    */
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);

    /*
        * Invoke its constructor with the designated invocation handler.
        */
    try {
        if (sm != null) {
            checkNewProxyPermission(Reflection.getCallerClass(), cl);
        }
        //获取代理类构造函数
        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h;
        if (!Modifier.isPublic(cl.getModifiers())) {
            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                public Void run() {
                    cons.setAccessible(true);
                    return null;
                }
            });
        }
        //返回代理对象
        return cons.newInstance(new Object[]{h});
    } catch (IllegalAccessException|InstantiationException e) {
        throw new InternalError(e.toString(), e);
    } catch (InvocationTargetException e) {
        Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new InternalError(t.toString(), t);
        }
    } catch (NoSuchMethodException e) {
        throw new InternalError(e.toString(), e);
    }
}
</code></pre>
<h3 id="135-invocationhandler-接口">1.3.5 InvocationHandler 接口</h3>
<p>InvocationHandler接口定义了一个用于处理代理对象方法调用的统一入口，当代理对象的方法被调用时，会触发invoke方法的执行，通过实现invoke方法来定义代理对象方法调用时的行为，例如添加日志、实现权限控制等。</p>
<pre><code class="language-java">public interface InvocationHandler {
    //传入代理对象，被调用的方法、方法 参数
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}

在 invoke 方法中，会根据方法名和参数，调用对应的拦截器。

```java
/**
    * Implementation of {@code InvocationHandler.invoke}.
    * &lt;p&gt;Callers will see exactly the exception thrown by the target,
    * unless a hook method throws an exception.
    */
@Override
public @Nullable Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Object oldProxy = null;
    boolean setProxyContext = false;

    TargetSource targetSource = this.advised.targetSource;
    Object target = null;

    try {
        if (!this.cache.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {
            // The target does not implement the equals(Object) method itself.
            return equals(args[0]);
        }
        else if (!this.cache.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {
            // The target does not implement the hashCode() method itself.
            return hashCode();
        }
        else if (method.getDeclaringClass() == DecoratingProxy.class) {
            // There is only getDecoratedClass() declared -&gt; dispatch to proxy config.
            return org.springframework.aop.framework.AopProxyUtils.ultimateTargetClass(this.advised);
        }
        else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;
                method.getDeclaringClass().isAssignableFrom(org.springframework.aop.framework.Advised.class)) {
            // Service invocations on ProxyConfig with the proxy config...
            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
        }

        Object retVal;

        if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = org.springframework.aop.framework.AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
        }

        // Get as late as possible to minimize the time we &quot;own&quot; the target,
        // in case it comes from a pool.
        target = targetSource.getTarget();
        Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);

        // Get the interception chain for this method.
        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        // Check whether we have any advice. If we don't, we can fall back on direct
        // reflective invocation of the target, and avoid creating a MethodInvocation.
        if (chain.isEmpty()) {
            // We can skip creating a MethodInvocation: just invoke the target directly
            // Note that the final invoker must be an InvokerInterceptor so we know it does
            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
            @Nullable Object[] argsToUse = org.springframework.aop.framework.AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
        }
        else {
            // We need to create a method invocation...
            MethodInvocation invocation =
                    new org.springframework.aop.framework.ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            // Proceed to the joinpoint through the interceptor chain.
            retVal = invocation.proceed();
        }

        // Massage return value if necessary.
        Class&lt;?&gt; returnType = method.getReturnType();
        if (retVal != null &amp;&amp; retVal == target &amp;&amp;
                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;
                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
            // Special case: it returned &quot;this&quot; and the return type of the method
            // is type-compatible. Note that we can't help if the target sets
            // a reference to itself in another returned object.
            retVal = proxy;
        }
        else if (retVal == null &amp;&amp; returnType != void.class &amp;&amp; returnType.isPrimitive()) {
            throw new AopInvocationException(
                    &quot;Null return value from advice does not match primitive return type for: &quot; + method);
        }
        if (coroutinesReactorPresent &amp;&amp; KotlinDetector.isSuspendingFunction(method)) {
            return COROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName()) ?
                    org.springframework.aop.framework.CoroutinesUtils.asFlow(retVal) : org.springframework.aop.framework.CoroutinesUtils.awaitSingleOrNull(retVal, args[args.length - 1]);
        }
        return retVal;
    }
    finally {
        if (target != null &amp;&amp; !targetSource.isStatic()) {
            // Must have come from TargetSource.
            targetSource.releaseTarget(target);
        }
        if (setProxyContext) {
            // Restore old proxy.
            org.springframework.aop.framework.AopContext.setCurrentProxy(oldProxy);
        }
    }
}
</code></pre>
<h2 id="13-实践与应用">1.3 实践与应用</h2>
<h3 id="131-编写自定义的-aop-拦截器步骤">1.3.1 编写自定义的 AOP 拦截器步骤</h3>
<ol>
<li>编写自定义拦截器：</li>
</ol>
<ul>
<li>创建一个类，实现 Spring 的 MethodInterceptor 接口，该接口定义了拦截器的核心方法 invoke。</li>
<li>在 invoke 方法中编写自定义的拦截逻辑，比如在目标方法执行前后执行一些操作，或者替换目标方法的执行等。</li>
</ul>
<pre><code class="language-java">public class CustomInterceptor implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // 在目标方法执行前输出日志
        System.out.println(&quot;Before invoking method: &quot; + invocation.getMethod().getName());

        // 执行目标方法
        Object result = invocation.proceed(); 

        // 在目标方法执行后输出日志
        System.out.println(&quot;After invoking method: &quot; + invocation.getMethod().getName());

        return result;
    }
}
</code></pre>
<p>创建一个注解 CustomAnnotation，用来标记需要被拦截的方法。</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomAnnotation {
}
</code></pre>
<p>修改 UserService 和 UserServiceImpl，在需要拦截的方法上添加 CustomAnnotation 注解。</p>
<pre><code class="language-java">public interface UserService {
    @CustomAnnotation
    void addUser(String username);
}

public class UserServiceImpl implements UserService {
    @Override
    @CustomAnnotation
    public void addUser(String username) {
        System.out.println(&quot;User added: &quot; + username);
    }
}
</code></pre>
<ol start="2">
<li>配置拦截器：</li>
</ol>
<ul>
<li>使用 Spring 的配置方式（XML、Java Config、注解）将自定义的拦截器配置到 Spring 容器中。</li>
<li>将拦截器与目标 bean 关联起来，可以通过切点表达式或其他方式指定在哪些方法上应用拦截器。</li>
</ul>
<p>使用 Spring 的 Java Config 来配置拦截器和切面。</p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    /**
     * 返回一个 UserService 实例
     */
    @Bean
    public UserService userService() {
        return new UserServiceImpl();
    }

    /**
     * 返回一个 CustomInterceptor 的实例，即自定义的拦截器
     */
    @Bean
    public CustomInterceptor customInterceptor() {
        return new CustomInterceptor();
    }

    /**
     * 返回一个 DefaultAdvisorAutoProxyCreator 实例，负责自动代理被 @AspectJ 注解标记的 Bean
     */
    @Bean
    public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() {
        return new DefaultAdvisorAutoProxyCreator();
    }

    /**
     * 返回一个 DefaultPointcutAdvisor 实例，将拦截器和切点绑定在一起
     */
    @Bean
    public DefaultPointcutAdvisor defaultPointcutAdvisor() {
        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor();
        // 将自定义的拦截器设置为 Advisor 的 advice，即在目标方法执行前后所执行的逻辑
        advisor.setAdvice(customInterceptor());
       // 设置切点，即确定在哪些方法上应用拦截器的条件
        advisor.setPointcut(annotationMatchingPointcut());
        return advisor;
    }

    /**
     * 返回一个 AnnotationMatchingPointcut 实例，切点用于匹配带有 CustomAnnotation 注解的方法
     */
    @Bean
    public AnnotationMatchingPointcut annotationMatchingPointcut() {
        return AnnotationMatchingPointcut.forMethodAnnotation(CustomAnnotation.class);
    }
}
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        UserService userService = context.getBean(UserService.class);
        // 在执行 addUser 方法之前，拦截器执行了自定义的前置逻辑，并在方法执行完毕后执行了自定义的后置逻辑
        userService.addUser(&quot;Alice&quot;);
    }
}

// 输出结果
Before invoking method: addUser
User added: Alice
After invoking method: addUser
</code></pre>
<ol start="4">
<li>调试和优化</li>
</ol>
<h1 id="二-cglib代理">二、Cglib代理</h1>
<h2 id="21-cglib-代理简介">2.1 CGLIB 代理简介</h2>
<p>CGLIB是一个强大的、高性能的代码生成库。它被广泛应用于AOP（面向切面编程）、ORM（对象关系映射）和其他一些框架中。</p>
<h3 id="211-cglib代理的基本原理">2.1.1 CGLIB代理的基本原理</h3>
<ol>
<li>创建代理类：CGLIB通过<code>ASM</code>字节码操作框架，在运行时动态生成目标类的子类。这个子类会继承自目标类。</li>
<li>方法拦截：在生成的子类中，会覆盖所有非final的方法。覆盖的方法会委托给一个用户定义的拦截器（MethodInterceptor），拦截器中包含了增强的代码。<br>
调用流程：当调用代理类的方法时，实际上是在调用被覆盖的方法。这些方法内部会调用拦截器，拦截器再去调用原始类的相应方法。</li>
</ol>
<h3 id="212-cglib代理的特点">2.1.2 CGLIB代理的特点</h3>
<ol>
<li>无需接口：CGLIB代理不需要目标类实现任何接口，因为它是通过继承的方式来实现代理的。</li>
<li>性能：CGLIB生成的代理类是目标类的子类，相比于JDK动态代理（接口代理），CGLIB代理通常有更好的性能，因为它直接调用父类的方法，减少了反射调用的开销。</li>
<li>灵活性：由于CGLIB代理是通过继承实现的，它无法代理final类和方法。但是，它提供了比JDK代理更高的灵活性，因为它可以代理任何类，而不受接口限制。</li>
<li>复杂性：CGLIB代理的实现比JDK动态代理复杂，因为它涉及到字节码生成和类加载机制。</li>
<li>兼容性：CGLIB代理通常与Spring框架结合使用，Spring AOP默认使用JDK动态代理，但如果目标对象没有实现接口，Spring AOP会自动切换到CGLIB代理。</li>
</ol>
<h2 id="22-分析-cglib-如何通过字节码技术创建代理类">2.2 分析 CGLIB 如何通过字节码技术创建代理类</h2>
<p>CGLIB通过操纵字节码，创建出目标类的子类，并在子类中覆盖非final的方法，从而实现方法拦截和增强。</p>
<h3 id="221-cglib创建代理类的基本步骤">2.2.1 CGLIB创建代理类的基本步骤</h3>
<ol>
<li>确定目标类：首先要确定需要被代理的目标类。CGLIB代理不需要目标类实现任何接口，因为它是通过继承的方式来实现代理的。</li>
<li>创建<code>Enhancer对</code>象：Enhancer是CGLIB中的一个核心类，用于创建代理类。首先创建一个Enhancer实例，并设置其父类（即目标类）。</li>
<li>设置<code>Callback</code>：Callback是一个接口，用于定义代理类中覆盖方法的逻辑。通常使用<code>MethodInterceptor</code>接口，它允许我们在调用原始方法之前和之后插入自定义代码。将实现的Callback对象设置给Enhancer。</li>
<li>创建代理类：调用Enhancer的<code>create()</code>方法，CGLIB会使用ASM字节码操作框架来动态生成一个继承自目标类的子类。这个子类会覆盖所有<code>非final</code>的方法，并将调用委托给Callback对象。</li>
<li>使用代理类：create()方法返回的是一个代理类的实例，这个实例可以被当作目标类的实例来使用。当调用代理类的方法时，实际上会调用MethodInterceptor中的<code>intercept()</code>方法。</li>
<li>方法调用流程：在intercept()方法中，可以调用Method对象的invoke()方法来执行原始方法。这样，我们就可以在原始方法执行前后插入自定义的逻辑，实现方法的拦截和增强。</li>
</ol>
<h3 id="222-深入分析-cglibaopproxy-类的结构">2.2.2 深入分析 CglibAopProxy 类的结构</h3>
<h4 id="cglibaopproxy-类结构">CglibAopProxy 类结构</h4>
<ol>
<li>成员变量：<br>
AdvisedSupport advised：存储了AOP配置信息的数据结构，如目标对象、切面等。<br>
Callback callback：CGLIB 回调对象，负责实现代理逻辑。</li>
<li>构造方法：<br>
CglibAopProxy(AdvisedSupport config)：构造方法接收一个 AdvisedSupport 参数，用于设置AOP配置信息。</li>
<li>核心方法：<br>
getProxy(ClassLoader classLoader)：生成代理对象的核心方法，接收一个 ClassLoader 参数用于加载代理类。<br>
createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks)：使用 CGLIB 的 Enhancer 创建代理类，并返回代理对象的实例。<br>
proxy(ClassLoader classLoader, Callback[] callbacks)：创建代理类并生成代理对象的实现逻辑， 使用 Enhancer 创建代理类，并指定 Callback 对象，完成代理类的生成和实例化。<br>
createEnhancer()：创建 Enhancer 对象，用于生成代理类， Enhancer 是 CGLIB 中负责生成代理类的核心类。</li>
</ol>
<h4 id="cglibaopproxy-类源码">CglibAopProxy 类源码</h4>
<pre><code class="language-java">class CglibAopProxy implements org.springframework.aop.framework.AopProxy, Serializable {

	// Constants for CGLIB callback array indices
	//表示aop代理类型
	private static final int AOP_PROXY = 0;

	//表示直接调用目标对象
	private static final int INVOKE_TARGET = 1;

	//表示不覆盖方法
	private static final int NO_OVERRIDE = 2;

	//表示分派到目标对象
	private static final int DISPATCH_TARGET = 3;

	//表示分派到通知器
	private static final int DISPATCH_ADVISED = 4;

	//表示调用equals方法
	private static final int INVOKE_EQUALS = 5;

	//表示调用hashCode方法
	private static final int INVOKE_HASHCODE = 6;


	private static final String COROUTINES_FLOW_CLASS_NAME = &quot;kotlinx.coroutines.flow.Flow&quot;;

	private static final boolean coroutinesReactorPresent = ClassUtils.isPresent(
			&quot;kotlinx.coroutines.reactor.MonoKt&quot;, CglibAopProxy.class.getClassLoader());

	private static final GeneratorStrategy undeclaredThrowableStrategy =
			new UndeclaredThrowableStrategy(UndeclaredThrowableException.class);

	/** Logger available to subclasses; static to optimize serialization. */
	protected static final Log logger = LogFactory.getLog(CglibAopProxy.class);

	/** Keeps track of the Classes that we have validated for final methods. */
	private static final Map&lt;Class&lt;?&gt;, Boolean&gt; validatedClasses = new WeakHashMap&lt;&gt;();

	//用于存储aop的配置信息，如目标对象、切面等
	/** The configuration used to configure this proxy. */
	protected final org.springframework.aop.framework.AdvisedSupport advised;

	//对象数组，用于存储构造器参数
	protected Object @Nullable [] constructorArgs;

	//类对象数组，用于存储构造器参数类型
	protected Class&lt;?&gt; @Nullable [] constructorArgTypes;

	/** Dispatcher used for methods on Advised. */
	//用于分派通知器
	private final transient AdvisedDispatcher advisedDispatcher;

	private transient Map&lt;Method, Integer&gt; fixedInterceptorMap = Collections.emptyMap();

	private transient int fixedInterceptorOffset;


	/**
	 * Create a new CglibAopProxy for the given AOP configuration.
	 * @param config the AOP configuration as AdvisedSupport object
	 * @throws org.springframework.aop.framework.AopConfigException if the config is invalid. We try to throw an informative
	 * exception in this case, rather than let a mysterious failure happen later.
	 */
	public CglibAopProxy(org.springframework.aop.framework.AdvisedSupport config) throws org.springframework.aop.framework.AopConfigException {
		Assert.notNull(config, &quot;AdvisedSupport must not be null&quot;);
		this.advised = config;
		this.advisedDispatcher = new AdvisedDispatcher(this.advised);
	}

	/**
	 * Set constructor arguments to use for creating the proxy.
	 * @param constructorArgs the constructor argument values
	 * @param constructorArgTypes the constructor argument types
	 */
	public void setConstructorArguments(Object @Nullable [] constructorArgs, Class&lt;?&gt; @Nullable [] constructorArgTypes) {
		if (constructorArgs == null || constructorArgTypes == null) {
			throw new IllegalArgumentException(&quot;Both 'constructorArgs' and 'constructorArgTypes' need to be specified&quot;);
		}
		if (constructorArgs.length != constructorArgTypes.length) {
			throw new IllegalArgumentException(&quot;Number of 'constructorArgs' (&quot; + constructorArgs.length +
					&quot;) must match number of 'constructorArgTypes' (&quot; + constructorArgTypes.length + &quot;)&quot;);
		}
		this.constructorArgs = constructorArgs;
		this.constructorArgTypes = constructorArgTypes;
	}
}
</code></pre>
<h3 id="223-cglib-代理对象的创建过程">2.2.3 CGLIB 代理对象的创建过程</h3>
<blockquote>
<p>代理对象的创建过程： 检查是否可以使用缓存的代理对象 -&gt; 准备 CGLIB Enhancer -&gt;  配置 Enhancer -&gt; 设置回调处理器（Callback） -&gt; 生成代理类字节码 -&gt; 创建代理对象实例  -&gt;  将代理对象缓存起来</p>
</blockquote>
<h4 id="createhelper-方法用来实际创建代理对象">createHelper() 方法用来实际创建代理对象。</h4>
<pre><code class="language-java">private Object createHelper() {
    preValidate();
    // SPRING PATCH BEGIN
    Object key = new EnhancerKey((superclass != null ? superclass.getName() : null),
            (interfaces != null ? Arrays.asList(ReflectUtils.getNames(interfaces)) : null),
            (filter == ALL_ZERO ? null : new WeakCacheKey&lt;&gt;(filter)),
            Arrays.asList(callbackTypes),
            useFactory,
            interceptDuringConstruction,
            serialVersionUID);
    // SPRING PATCH END
    this.currentKey = key;
    //创建代理对象
    Object result = super.create(key);
    return result;
}
</code></pre>
<p>AbstractClassGenerator 对象通过调用 create() 方法，根据给定的键值（key）创建对象实例。</p>
<pre><code class="language-java">protected Object create(Object key) {
    try {
        //获取当前类加载器
        ClassLoader loader = getClassLoader();
        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;
        ClassLoaderData data = cache.get(loader);
        if (data == null) {
            synchronized (AbstractClassGenerator.class) {
                cache = CACHE;
                data = cache.get(loader);
                if (data == null) {
                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = new WeakHashMap&lt;&gt;(cache);
                    data = new ClassLoaderData(loader);
                    newCache.put(loader, data);
                    CACHE = newCache;
                }
            }
        }
        this.key = key;
        Object obj = data.get(this, getUseCache());
        if (obj instanceof Class&lt;?&gt; clazz) {
            //创建第一个实例
            return firstInstance(clazz);
        }
        return nextInstance(obj);
    }
    catch (RuntimeException | Error ex) {
        throw ex;
    }
    catch (Exception ex) {
        throw new CodeGenerationException(ex);
    }
}
</code></pre>
<h3 id="224-实践与应用">2.2.4 实践与应用</h3>
<p>编写自定义的 CGLIB 拦截器</p>
<blockquote>
<p>假设有一个简单的服务类 UserService，其中包含一些方法，希望能够在调用这些方法之前和之后记录日志。使用CGLIB来实现一个拦截器，记录方法调用的开始和结束时间。</p>
</blockquote>
<h4 id="1服务类-userservice模拟创建和更新用户信息">1.服务类 UserService，模拟创建和更新用户信息。</h4>
<pre><code class="language-java">public class UserService {

    public void createUser(String username) {
        System.out.println(&quot;Creating user: &quot; + username);
        // 模拟创建用户的逻辑
    }

    public void updateUser(String username) {
        System.out.println(&quot;Updating user: &quot; + username);
        // 模拟更新用户的逻辑
    }
}
</code></pre>
<h4 id="2自定义的cglib拦截器用于记录方法调用的开始和结束时间">2.自定义的CGLIB拦截器，用于记录方法调用的开始和结束时间。</h4>
<pre><code class="language-java">/**
 * 创建 LoggingInterceptor 类，实现 MethodInterceptor 接口
 */
public class LoggingInterceptor implements MethodInterceptor {
    
    /**
     * 参数：obj 是被代理的对象实例
     *      method 是被调用的方法对象
     *      args 是方法的参数数组
     *      proxy 是用于调用父类（被代理类）方法的代理对象
     */
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 获取方法调用开始时的时间戳
        long startTime = System.currentTimeMillis();
        System.out.println(&quot;Method &quot; + method.getName() + &quot; start at: &quot; + startTime);

        // 调用被代理类的原始方法，而不是代理对象的方法，以避免循环调用
        Object result = proxy.invokeSuper(obj, args);

        // 获取方法调用结束时的时间戳
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;Method &quot; + method.getName() + &quot; end at: &quot; + endTime);
        // 方法执行所花费的时间
        System.out.println(&quot;Method &quot; + method.getName() + &quot; execution time: &quot; + (endTime - startTime) + &quot; milliseconds&quot;);

        // 调用原始方法后的返回值
        return result;
    }

    public static void main(String[] args) {
        UserService userService = new UserService();

        // 使用CGLIB的 Enhancer 类创建了 UserService 类的代理对象，并将拦截器设置为回调方法
        Enhancer enhancer = new Enhancer();
        // 设置了要代理的目标类是 UserService
        enhancer.setSuperclass(UserService.class);
        // 指定了在方法调用时应该执行的拦截逻辑
        enhancer.setCallback(new LoggingInterceptor());

        // 创建代理对象，将会在方法调用时执行我们定义的拦截逻辑
        UserService userServiceProxy = (UserService) enhancer.create();

        // 调用代理对象的 createUser 和 updateUser 方法来触发拦截器的拦截逻辑
        userServiceProxy.createUser(&quot;John Doe&quot;);
        userServiceProxy.updateUser(&quot;Jane Smith&quot;);
    }
}

//输出结果：
Method createUser start at: 1621802728000
Creating user: John Doe
Method createUser end at: 1621802728000
Method createUser execution time: 0 milliseconds
Method updateUser start at: 1621802728000
Updating user: Jane Smith
Method updateUser end at: 1621802728000
Method updateUser execution time: 0 milliseconds
</code></pre>
<h3 id="225-实现对非接口类的代理和增强功能">2.2.5 实现对非接口类的代理和增强功能</h3>
<p>实现对非接口类的代理和增强功能通常使用 Spring AOP来实现，提供了一种便捷的方式来在方法执行前、执行后、方法抛出异常时等时机插入特定逻辑，而无需修改原始类的代码。</p>
<blockquote>
<p>假设有一个订单管理系统，其中包含一个 OrderService 类，该类负责处理订单相关的业务逻辑，比如创建订单、更新订单状态等。希望在处理订单相关业务时，记录日志并统计方法执行时间。</p>
</blockquote>
<ol>
<li>切面类 OrderAspect。</li>
</ol>
<pre><code class="language-java">@Aspect
@Component
public class OrderAspect {

    /**
     * 切面方法，用于实现切面的逻辑 -&gt; 表示正在执行目标方法之前
     * 接受一个 JoinPoint 参数，连接点 -&gt; 被增强的目标方法
     */
    @Before(&quot;execution(* com.example.service.OrderService.*(..))&quot;)
    public void logBefore(JoinPoint joinPoint) {
        System.out.println(&quot;Before executing method: &quot; + joinPoint.getSignature());
    }

     /**
     * 切面方法，用于实现切面的逻辑 -&gt; 表示目标方法执行完成后
     * 接受一个 JoinPoint 参数，连接点 -&gt; 被增强的目标方法
     */
    @After(&quot;execution(* com.example.service.OrderService.*(..))&quot;)
    public void logAfter(JoinPoint joinPoint) {
        System.out.println(&quot;After executing method: &quot; + joinPoint.getSignature());
    }
}
</code></pre>
<ol start="2">
<li>
<p>配置类中启用 Spring AOP 功能。</p>
</li>
<li>
<p>OrderService 类</p>
</li>
</ol>
<pre><code class="language-java">/**
 * 调用 OrderService 类的 createOrder() 或 updateOrderStatus() 方法时，OrderAspect 切面中定义的增强逻辑会在方法执行前后生效，从而实现了对非接口类的代理和增强功能
 */
@Service
public class OrderService {

    public void createOrder() {
        // 模拟创建订单的业务逻辑
        System.out.println(&quot;Creating order...&quot;);
    }

    public void updateOrderStatus() {
        // 模拟更新订单状态的业务逻辑
        System.out.println(&quot;Updating order status...&quot;);
    }
}

// 输出结果：
Before executing method: public void com.example.service.OrderService.createOrder()
Creating order...
After executing method: public void com.example.service.OrderService.createOrder()

Before executing method: public void com.example.service.OrderService.updateOrderStatus()
Updating order status...
After executing method: public void com.example.service.OrderService.updateOrderStatus()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring @Transactional原理]]></title>
        <id>https://q456qq520.github.io/post/spring-transactional-yuan-li/</id>
        <link href="https://q456qq520.github.io/post/spring-transactional-yuan-li/">
        </link>
        <updated>2025-05-11T04:21:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-简介">一 简介</h2>
<p>@Transactional是spring中声明式事务管理的注解配置方式，相信这个注解的作用大家都很清楚。@Transactional注解可以帮助我们把事务开启、提交或者回滚的操作，通过aop的方式进行管理。</p>
<p>通过@Transactional注解就能让spring为我们管理事务，免去了重复的事务管理逻辑，减少对业务代码的侵入，使我们开发人员能够专注于业务层面开发。</p>
<p>Spring事务管理采用切面（AOP）的核心原因在于实现声明式事务控制，将事务逻辑与业务逻辑解耦，从而提升代码的可维护性、灵活性和复用性</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1746937993921.png" alt="" loading="lazy"></figure>
<h2 id="二-transactional">二 @Transactional</h2>
<p>打开<code>TransactionAutoConfiguration</code>自动配置类可以看到一个比较重要的注解<code>@EnableTransactionManagement</code>用于开启事务管理功能，@EnableTransactionManagement注解又导入了<code>AutoProxyRegistrar</code>和<code>ProxyTransactionManagementConfiguration</code>。</p>
<h3 id="21-事务配置">2.1 事务配置</h3>
<p>首先是@Transactional，作用是定义代理植入点。我们知道代理对象创建的通过BeanPostProcessor的实现类AnnotationAwareAspectJAutoProxyCreator的postProcessAfterInstantiation方法来实现个，如果需要进行代理，那么在这个方法就会返回一个代理对象给容器，同时判断植入点也是在这个方法中。</p>
<p>在配置好注解驱动方式的事务管理之后，spring会在ioc容器创建一个<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例，这个实例可以看作是一个切点，在判断一个bean在初始化过程中是否需要创建代理对象，都需要验证一次<code>BeanFactoryTransactionAttributeSourceAdvisor</code>是否是适用这个bean的切点。如果是，就需要创建代理对象，并且把<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例注入到代理对象中。</p>
<p>我们知道在<code>AopUtils#findAdvisorsThatCanApply</code>中判断切面是否适用当前bean，最终调用<code>SpringTransactionAnnotationParser#parseTransactionAnnotation(java.lang.reflect.AnnotatedElement)</code></p>
<pre><code class="language-java">@Override
public TransactionAttribute parseTransactionAnnotation(AnnotatedElement ae) {
    //这里就是分析Method是否被@Transactional注解标注，有的话，不用说BeanFactoryTransactionAttributeSourceAdvisor适配当前bean，进行代理，并且注入切点
    //BeanFactoryTransactionAttributeSourceAdvisor
   AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ae, Transactional.class);
   if (attributes != null) {
      return parseTransactionAnnotation(attributes);
   }
   else {
      return null;
   }
}
</code></pre>
<p>上面就是判断是否需要根据<code>@Transactional</code>进行代理对象创建的判断过程。@Transactional的作用一个就是标识方法需要被代理，一个就是携带事务管理需要的一些属性信息。</p>
<h3 id="22-事务流程">2.2 事务流程</h3>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1746939646593.png" alt="" loading="lazy"></figure>
<h3 id="23-transactional注解作用域">2.3 @Transactional注解作用域</h3>
<p>@Transactional可以作用在接口、类、类方法；</p>
<ol>
<li>作用于类：当把@Transactional 注解放在类上时，表示所有该类的public方法都配置相同的事务属性信息，会导致事务控制的粒度太大，注解参数无法根据每个类方法的实际需求设置；因此，一般@Transactional注解都会直接添加的需要的方法上</li>
<li>作用于方法：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息</li>
<li>作用于接口：不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效</li>
</ol>
<h3 id="24-事务回滚">2.4 事务回滚</h3>
<p>@Transactional默认只能回滚RuntimeException和RuntimeException下面的子类抛出的异常，不能回滚Exception异常；如果需要支持回滚Exception异常，需要显示的指明，如@Transactional(rollbackFor = Exception.class)</p>
<h3 id="25-失效场景">2.5 失效场景</h3>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1746939916629.png" alt="" loading="lazy"></figure>
<p>参考<a href="https://blog.csdn.net/wang_luwei/article/details/121549005">&quot;事务失效场景&quot;</a></p>
<ol>
<li>@Transactional注解未打在public方法上<br>
Java的访问权限主要有四种：private、default、protected、public；如果事务方法定义了错误的访问权限（非public方法），会导致事务失效。</li>
<li>目标方法用final修饰<br>
某个方法不想被子类重写，可以将该方法定义成final的；如果将事务方法定义成final，会导致事务失效<br>
原因：Spring事务基于Spring AOP，通过JDK动态代理或者CGlib代理，在代理类中实现的事务功能；但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法；同样，static修饰的方法，同样无法通过动态代理，变成事务方法</li>
<li>同一个类中的方法直接内部调用<br>
方法被事务管理是因为Apring AOP为其生成代理了对象，但是直接this调用同类方法，调用的是目标类对象的方法，而非代理类方法，因此，在同类中的方法直接内部调用，会导致事务失效。</li>
<li>事务方法所在的类未被Spring管理</li>
<li>多线程调用<br>
如果两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务</li>
<li>存储引擎不支持事务</li>
<li>未开启事务</li>
</ol>
<h3 id="26-事务不回滚">2.6 事务不回滚</h3>
<ol>
<li>错误的传播特性</li>
</ol>
<p>其实，我们在使用@Transactional注解时，是可以指定propagation参数的。</p>
<p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p>
<ul>
<li>REQUIRED 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li>
<li>SUPPORTS 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。</li>
<li>MANDATORY 如果当前上下文中存在事务，否则抛出异常。</li>
<li>REQUIRES_NEW 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</li>
<li>NOT_SUPPORTED 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。</li>
<li>NEVER 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。</li>
<li>NESTED 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</li>
</ul>
<ol start="2">
<li>自己吞了异常<br>
这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。</li>
</ol>
<p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p>
<ol start="3">
<li>手动抛了别的异常</li>
<li>自定义了回滚异常</li>
<li>嵌套事务回滚多了</li>
</ol>
<h2 id="三-源码分析">三 源码分析</h2>
<p>aop最终的代理对象的代理方法是</p>
<p><code>DynamicAdvisedInterceptor#intercept</code></p>
<pre><code class="language-java">@Override
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
   Object oldProxy = null;
   boolean setProxyContext = false;
   Class&lt;?&gt; targetClass = null;
   Object target = null;
   try {
      if (this.advised.exposeProxy) {
         // Make invocation available if necessary.
         oldProxy = AopContext.setCurrentProxy(proxy);
         setProxyContext = true;
      }
      // May be null. Get as late as possible to minimize the time we
      // &quot;own&quot; the target, in case it comes from a pool...
      target = getTarget();
      if (target != null) {
         targetClass = target.getClass();
      }
       //follow
      List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
      Object retVal;
      // Check whether we only have one InvokerInterceptor: that is,
      // no real advice, but just reflective invocation of the target.
      if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {
         // We can skip creating a MethodInvocation: just invoke the target directly.
         // Note that the final invoker must be an InvokerInterceptor, so we know
         // it does nothing but a reflective operation on the target, and no hot
         // swapping or fancy proxying.
         Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
         retVal = methodProxy.invoke(target, argsToUse);
      }
      else {
         // We need to create a method invocation...
         retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
      }
      retVal = processReturnType(proxy, target, method, retVal);
      return retVal;
   }
   finally {
      if (target != null) {
         releaseTarget(target);
      }
      if (setProxyContext) {
         // Restore old proxy.
         AopContext.setCurrentProxy(oldProxy);
      }
   }
}
</code></pre>
<p><code>getInterceptorsAndDynamicInterceptionAdvice</code>返回的是<code>TransactionInterceptor</code>，发现最终是调用<code>TransactionInterceptor#invoke</code>方法，并且把CglibMethodInvocation注入到invoke方法中，从上面可以看到CglibMethodInvocation是包装了目标对象的方法调用的所有必须信息，因此，在TransactionInterceptor#invoke里面也是可以调用目标方法的，并且还可以实现类似@Around的逻辑，在目标方法调用前后继续注入一些其他逻辑，比如事务管理逻辑。</p>
<h3 id="23-transactioninterceptor最终事务管理者">2.3 TransactionInterceptor–最终事务管理者</h3>
<pre><code class="language-java">@Override
public Object invoke(final MethodInvocation invocation) throws Throwable {
 // Work out the target class: may be {@code null}.
 // The TransactionAttributeSource should be passed the target class
 // as well as the method, which may be from an interface.
 Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

 // Adapt to TransactionAspectSupport's invokeWithinTransaction...
 return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {
  @Override
  public Object proceedWithInvocation() throws Throwable {
   return invocation.proceed();
  }
 });
}
</code></pre>
<pre><code class="language-java">protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)
      throws Throwable {

   // If the transaction attribute is null, the method is non-transactional.
   final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);
   final PlatformTransactionManager tm = determineTransactionManager(txAttr);
   final String joinpointIdentification = methodIdentification(method, targetClass);

   if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
      // Standard transaction demarcation with getTransaction and commit/rollback calls.
       //开启事务
      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
      Object retVal = null;
      try {
         // This is an around advice: Invoke the next interceptor in the chain.
         // This will normally result in a target object being invoked.
          //方法调用
         retVal = invocation.proceedWithInvocation();
      }
      catch (Throwable ex) {
         // target invocation exception
     //回滚事务
         completeTransactionAfterThrowing(txInfo, ex);
         throw ex;
      }
      finally {
         cleanupTransactionInfo(txInfo);
      }
       //提交事务
      commitTransactionAfterReturning(txInfo);
      return retVal;
   }

   else {
      // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
      try {
         Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,
               new TransactionCallback&lt;Object&gt;() {
                  @Override
                  public Object doInTransaction(TransactionStatus status) {
                     TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
                     try {
                        return invocation.proceedWithInvocation();
                     }
                     catch (Throwable ex) {
                        if (txAttr.rollbackOn(ex)) {
                           // A RuntimeException: will lead to a rollback.
                           if (ex instanceof RuntimeException) {
                              throw (RuntimeException) ex;
                           }
                           else {
                              throw new ThrowableHolderException(ex);
                           }
                        }
                        else {
                           // A normal return value: will lead to a commit.
                           return new ThrowableHolder(ex);
                        }
                     }
                     finally {
                        cleanupTransactionInfo(txInfo);
                     }
                  }
               });

         // Check result: It might indicate a Throwable to rethrow.
         if (result instanceof ThrowableHolder) {
            throw ((ThrowableHolder) result).getThrowable();
         }
         else {
            return result;
         }
      }
      catch (ThrowableHolderException ex) {
         throw ex.getCause();
      }
   }
}
</code></pre>
<p>这里做了几件事情：</p>
<ol>
<li>获取事务的属性</li>
<li>加载配置中配的transactionManager</li>
<li>不同的事务处理方式使用不同的事务</li>
<li>在目标方法执行前获取事务并收集事务信息</li>
<li>执行目标方法</li>
<li>一旦出现异常，尝试异常处理，不是所有的异常都回滚， Spring 只对RuntimeException 处理</li>
<li>提交事务前的事务信息清除</li>
<li>提交事务</li>
</ol>
<h4 id="gettransactionattribute">getTransactionAttribute</h4>
<p>getTransactionAttribute 方法比较简单，就是获取事务属性并缓存， 如果事务存在，那就对事务 加一个属性描述，对应的值为 类名.方法名</p>
<pre><code class="language-java">public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {
		// 如果是Object.class 类，直接返回
		if (method.getDeclaringClass() == Object.class) {
			return null;
		}

		/** 
		首先 去查看是否有缓存，getCacheKey 里面 就是一个单纯的 new 了一个对象 MethodClassKey，MethodClassKey重写了
		toString() 方法， 主要就是 用了 method+targetClass
		**/
		Object cacheKey = getCacheKey(method, targetClass);
		TransactionAttribute cached = this.attributeCache.get(cacheKey);
		// 如果不为null, 要么就是具体的事务属性，要么就是 默认的空属性， 如果是默认的空事务属性，那就 返回null
		if (cached != null) {
			if (cached == NULL_TRANSACTION_ATTRIBUTE) {
				return null;
			}
			else {
				return cached;
			}
		}
		else {
			// 如果是空 ，那就再次获取一遍
			TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);
			// 放入缓存， 如果 属性为null, 设置 对应的value 为NULL_TRANSACTION_ATTRIBUTE
			if (txAttr == null) {
				this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
			}
			else {
			    // 放入属性之前， 对 事务属性 设置一个 描述，就是用 类名.方法名
				String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
				if (txAttr instanceof DefaultTransactionAttribute) {
					((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);
				}
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Adding transactional method '&quot; + methodIdentification + &quot;' with attribute: &quot; + txAttr);
				}
				this.attributeCache.put(cacheKey, txAttr);
			}
			return txAttr;
		}
	}
</code></pre>
<h4 id="computetransactionattribute">computeTransactionAttribute</h4>
<p>computeTransactionAttribute 方法主要是 寻找事务属性的， 主要流程如下：</p>
<ol>
<li>首先判断方法是什么类型的，如果不是 public 类型的，直接返回null</li>
<li>接下来获取 事务属性，这里是按照 targetClass.Method -&gt;tragetClass -&gt;interface.Method -&gt; interface 的顺序获取属性的， 也就是说，如果你接口上有事务属性， 但是如果你目标类的方法上还有属性，那就以目标类的方法的属性为准</li>
</ol>
<pre><code class="language-java">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {
		/** 这里要求 事务的方法是 public的，不然不生效
           注解式事务里面 AnnotationTransactionAttributeSource 里面默认是 true 的
          **/
		if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {
			return null;
		}

		/**
		 这里的方法可能是在一个接口上，所以这里是获取target class 的具体方法
		 比如： method 为IFoo.bar() , targetClass 是 DefaultFoo ,这里是需要获取 DefaultFoo.bar()方法
		 同时这里还处理了可能出现桥接的问题
		 如果 targetClass 为null ,那方法就不会变
		**/
		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);

		/**
		第一次尝试： 先对 方法上 @Transactional 进行解析
		 解析 方法上的@Transactional属性，利用 springTransactionAnnotationParser 对 方法上的
		 @Transactional 进行解析里面的属性， 返回 TransactionAttribute 
		**/
		TransactionAttribute txAttr = findTransactionAttribute(specificMethod);
		if (txAttr != null) {
			return txAttr;
		}

		/**
		第二次： 如果上一步没有获取到，那就可能在 target class上面
		对 target class 进行解析， 如果找到对应的事务属性， 并且是 
		用户级别的方法，那就返回
		**/
		txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());
		if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {
			return txAttr;
		}

        /**
         第三步 如果 在目标类上的 方法和类上都没有找到 对应的 事务属性
         那就去 原始的接口上去寻找， 还是 先从 method 上面开始，
         如果没有，那就看接口上有没有 配置事务属性
        **/
		if (specificMethod != method) {
			// Fallback is to look at the original method.
			txAttr = findTransactionAttribute(method);
			if (txAttr != null) {
				return txAttr;
			}
			// Last fallback is the class of the original method.
			txAttr = findTransactionAttribute(method.getDeclaringClass());
			if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {
				return txAttr;
			}
		}
         // 最后都没有找到，那就返回null
		return null;
	}
</code></pre>
<h4 id="transactionaspectsupportdeterminetransactionmanager">TransactionAspectSupport#determineTransactionManager</h4>
<p>方法的逻辑也比较简单：</p>
<ol>
<li>判断是否有事务属性，如果没有直接返回</li>
<li>根据事务的名字，获取对应的事务管理器</li>
<li>如果事务没有设置名字， 获取默认的事务管理器</li>
</ol>
<pre><code class="language-java">protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) {
		// 如果 事务属性 txAttr 为null， 那就直接返回
		if (txAttr == null || this.beanFactory == null) {
			return getTransactionManager();
		}
        // 获取对应的事务注解上的名字
		String qualifier = txAttr.getQualifier();
		if (StringUtils.hasText(qualifier)) {
		    // 根据指定的事务注解name去查询
			return determineQualifiedTransactionManager(this.beanFactory, qualifier);
		}
		//根据默认的事务注解name查询
		else if (StringUtils.hasText(this.transactionManagerBeanName)) {
			return determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName);
		}
		else {
		    // 获取默认的 事务管理器
			TransactionManager defaultTransactionManager = getTransactionManager();
			if (defaultTransactionManager == null) {
				defaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);
				if (defaultTransactionManager == null) {
					defaultTransactionManager = this.beanFactory.getBean(TransactionManager.class);
					this.transactionManagerCache.putIfAbsent(
							DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);
				}
			}
			return defaultTransactionManager;
		}
	}

    /**
     这里从(cache-&gt;beanFactory)里面获取 指定名字的事务管理器
    **/
	private TransactionManager determineQualifiedTransactionManager(BeanFactory beanFactory, String qualifier) {
	   // 这里首先也是先从缓存里面获取
		TransactionManager txManager = this.transactionManagerCache.get(qualifier);
		//如果缓存不存在，那就从BeanFactory 里面获取，然后再放进缓存
		if (txManager == null) {
			txManager = BeanFactoryAnnotationUtils.qualifiedBeanOfType(
					beanFactory, TransactionManager.class, qualifier);
			this.transactionManagerCache.putIfAbsent(qualifier, txManager);
		}
		return txManager;
	}
</code></pre>
<h4 id="transactionaspectsupportcreatetransactionifnecessary">TransactionAspectSupport#createTransactionIfNecessary</h4>
<p>这个方法主要是判断是否有必要创建事务</p>
<pre><code class="language-java">	protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {
		/**
		如果没有指定名称，则将方法标识应用为事务名称，就是之前设置的 class.method
		**/
		if (txAttr != null &amp;&amp; txAttr.getName() == null) {
			txAttr = new DelegatingTransactionAttribute(txAttr) {
				@Override
				public String getName() {
					return joinpointIdentification;
				}
			};
		}

		TransactionStatus status = null;
		if (txAttr != null) {
			if (tm != null) {
				status = tm.getTransaction(txAttr);
			}
			else {
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification +
							&quot;] because no transaction manager has been configured&quot;);
				}
			}
		}
		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
	}
</code></pre>
<h4 id="abstractplatformtransactionmanagergettransaction">AbstractPlatformTransactionManager#getTransaction</h4>
<p>getTransaction方法 比较核心了， 主要做了以下几件事：</p>
<ol>
<li>获取事务</li>
<li>如果当前线程存在事务，则转向嵌套事务处理</li>
<li>事务的超时设置验证</li>
<li>事务的传播属性验证</li>
<li>隔离级别， timeout ,connectinHolder 等配置</li>
<li>绑定到当前线程</li>
</ol>
<pre><code class="language-java">public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException {

		// 如果传入的definition 为null , 就从新定义一个新的definition (StaticTransactionDefinition 类型)
		TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());
        //这里时获取 当前线程缓存在 threadlocal里面的 connection, 如果没有connection,那DataSourceTransactionObject 里面的
        //connectionHolder 为null
		Object transaction = doGetTransaction();
		boolean debugEnabled = logger.isDebugEnabled();
        // 这里时判断如果上面的 connectionHolder 不为空，并且是有效的
		if (isExistingTransaction(transaction)) {
			// Existing transaction found -&gt; check propagation behavior to find out how to behave.
			// 这里是 为已经存在的 transaction创建一个 TransactionStatus对象
			return handleExistingTransaction(def, transaction, debugEnabled);
		}

		// Check definition settings for new transaction.
		if (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) {
			throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, def.getTimeout());
		}

		//如果事务定义为MANDATORY，那就是必须在一个已有事务里面运行， 这里没有事务就会报错
		if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
			throw new IllegalTransactionStateException(
					&quot;No existing transaction found for transaction marked with propagation 'mandatory'&quot;);
		}
		else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
				def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
				def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
				// 这块空挂起，不做任何操作
			SuspendedResourcesHolder suspendedResources = suspend(null);
			if (debugEnabled) {
				logger.debug(&quot;Creating new transaction with name [&quot; + def.getName() + &quot;]: &quot; + def);
			}
			try {
			   // 这里就是开启事务
				return startTransaction(def, transaction, debugEnabled, suspendedResources);
			}
			catch (RuntimeException | Error ex) {
				resume(null, suspendedResources);
				throw ex;
			}
		}
		else {
			// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.
			if (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) {
				logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +
						&quot;isolation level will effectively be ignored: &quot; + def);
			}
			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);
		}
	}
</code></pre>
<h4 id="datasourcetransactionmanagerdogettransaction">DataSourceTransactionManager#doGetTransaction</h4>
<p>doGetTransaction 方法主要就是为了获取当前线程的 connection, 通过查看缓存在 TransactionSynchronizationManager.class里面的resources 的threadLocal 里面的connection,如果没有就为null</p>
<p>后面doBegin 方法里面最好是绑定数据源，就是存放在一个 ThreadLocal里面， 里面存放的是Map,key 就是 datasource,Value 就是对应的connection</p>
<pre><code class="language-java">	protected Object doGetTransaction() {
	    // 创建一个 DataSourceTransactionObject 对象
		DataSourceTransactionObject txObject = new DataSourceTransactionObject();
		// 设置 此事务中是否允许保存点, isNestedTransactionAllowed() 为true，是在事务创建时设置的
		txObject.setSavepointAllowed(isNestedTransactionAllowed());
		/**获取当前线程的connection 缓存，如果不存在，那就为null
		这里是一个Map 存储的， key 是datasource ，value 是connection
		**/
		ConnectionHolder conHolder =
				(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());
		txObject.setConnectionHolder(conHolder, false);
		return txObject;
	}
</code></pre>
<h4 id="abstractplatformtransactionmanagersuspend">AbstractPlatformTransactionManager#suspend</h4>
<p>suspend 方法主要是对事务进行挂起，对于挂起操作主要的目的是记录原有事务的状态，以便后续操作对原有事务的恢复.</p>
<pre><code class="language-java">protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {
        // 如果当前线程的事务同步器是否是活跃状态
		if (TransactionSynchronizationManager.isSynchronizationActive()) {
		    /** 这里获取所有事务同步器的 快照，先悬挂住，并把当前线程清空，最后返回一个 
		    new SuspendedResourcesHolder  对象
		    **/
			List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();
			try {
				Object suspendedResources = null;
				if (transaction != null) {
					suspendedResources = doSuspend(transaction);
				}
				String name = TransactionSynchronizationManager.getCurrentTransactionName();
				TransactionSynchronizationManager.setCurrentTransactionName(null);
				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);
				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);
				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();
				TransactionSynchronizationManager.setActualTransactionActive(false);
				return new SuspendedResourcesHolder(
						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);
			}
			catch (RuntimeException | Error ex) {
				// doSuspend failed - original transaction is still active...
				doResumeSynchronization(suspendedSynchronizations);
				throw ex;
			}
		}
		else if (transaction != null) {
			// Transaction active but no synchronization active.
			Object suspendedResources = doSuspend(transaction);
			return new SuspendedResourcesHolder(suspendedResources);
		}
		else {
			// Neither transaction nor synchronization active.
			return null;
		}
	}
</code></pre>
<h4 id="abstractplatformtransactionmanagerstarttransaction">AbstractPlatformTransactionManager#startTransaction</h4>
<p>startTransaction方法 主要就是 开启新事务 ,详细逻辑在下面的doBegin</p>
<pre><code class="language-java">	private TransactionStatus startTransaction(TransactionDefinition definition, Object transaction,
			boolean debugEnabled, @Nullable SuspendedResourcesHolder suspendedResources) {

		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
		DefaultTransactionStatus status = newTransactionStatus(
				definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
				// 这里主要是构造transaction, 包括设置ConnectionHolder ，隔离级别，timeout ，如果是新连接，绑定到当前线程
		doBegin(transaction, definition);
		// 新同步事务的设置
		prepareSynchronization(status, definition);
		return status;
	}
</code></pre>
<h4 id="datasourcetransactionmanagerdobegin">DataSourceTransactionManager#doBegin</h4>
<p>doBegin 主要是构造transaction, 包括设置ConnectionHolder ，隔离级别，timeout ，这类不是spring 完成，而是交给底层的数据连接去做的，如果是新连接，绑定到当前线程</p>
<pre><code class="language-java">protected void doBegin(Object transaction, TransactionDefinition definition) {
        // 转换为 DataSourceTransactionObject
		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
		Connection con = null;

		try {
		    // 如果没有数据连接connection
			if (!txObject.hasConnectionHolder() ||
					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {
				// 这里就是调用数据源进行获取 connection 并进行绑定
				Connection newCon = obtainDataSource().getConnection();
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Acquired Connection [&quot; + newCon + &quot;] for JDBC transaction&quot;);
				}
				txObject.setConnectionHolder(new ConnectionHolder(newCon), true);
			}

			txObject.getConnectionHolder().setSynchronizedWithTransaction(true);
			con = txObject.getConnectionHolder().getConnection();
            // 对connection 设置 隔离级别和 是否只读属性
			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);
			txObject.setPreviousIsolationLevel(previousIsolationLevel);
			txObject.setReadOnly(definition.isReadOnly());

			// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,
			// so we don't want to do it unnecessarily (for example if we've explicitly
			// configured the connection pool to set it already).
			/**
			这里就是关闭自动提交， 就是开启事务了，由Spring 控制提交
			**/
			if (con.getAutoCommit()) {
				txObject.setMustRestoreAutoCommit(true);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Switching JDBC Connection [&quot; + con + &quot;] to manual commit&quot;);
				}
				con.setAutoCommit(false);
			}
            /**
            设置只读事务,就是这事务内没有新增，修改，删除操作只有查询操作，不需要数据库锁等操作，减少数据库压力，
            还有就是其他事务提交的数据，在&quot;SET TRANSACTION READ ONLY&quot; 是看不到的
            **/
			prepareTransactionalConnection(con, definition);
			// 配置 判断当前线程是否有事务的 标志
			txObject.getConnectionHolder().setTransactionActive(true);
            // 设置timeout
			int timeout = determineTimeout(definition);
			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {
				txObject.getConnectionHolder().setTimeoutInSeconds(timeout);
			}

			// Bind the connection holder to the thread.
			// 绑定这connection 到当前线程
			if (txObject.isNewConnectionHolder()) {
				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());
			}
		}

		catch (Throwable ex) {
			if (txObject.isNewConnectionHolder()) {
				DataSourceUtils.releaseConnection(con, obtainDataSource());
				txObject.setConnectionHolder(null, false);
			}
			throw new CannotCreateTransactionException(&quot;Could not open JDBC Connection for transaction&quot;, ex);
		}
	}
</code></pre>
<h4 id="transactionaspectsupportpreparetransactioninfo">TransactionAspectSupport#prepareTransactionInfo</h4>
<p>当已经建立事务连接并完成了事务的提取后，我们需要将所有的事务信息统一记录在TransactionInfo 类型的实例里面，这个实例包含了目标方法开始前的所有状态信息，一旦事务执行失败，Spring 会通过TransactionInfo 类型的实例中的信息来进行回滚等后续工作.<br>
方法prepareTransactionInfo 主要做了以下几件事：</p>
<ol>
<li>创建了一个TransactionInfo 实例， 把tm,txAttr,joinpointIdentification,status 属性都填充进去了</li>
<li>先把之前的老的TransactionInfo 保存起来， 并把当前的TransactionInfo 放到ThreadLocal 里面暴露出去 ,这样就便于后续的<br>
还原，提交，回滚等一系列操作.</li>
</ol>
<pre><code class="language-java">protected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, String joinpointIdentification,
			@Nullable TransactionStatus status) {

		TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification);
		if (txAttr != null) {
			// We need a transaction for this method...
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Getting transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);
			}
			// The transaction manager will flag an error if an incompatible tx already exists.
			txInfo.newTransactionStatus(status);
		}
		else {
			// The TransactionInfo.hasTransaction() method will return false. We created it only
			// to preserve the integrity of the ThreadLocal stack maintained in this class.
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;No need to create transaction for [&quot; + joinpointIdentification +
						&quot;]: This method is not transactional.&quot;);
			}
		}

		// We always bind the TransactionInfo to the thread, even if we didn't create
		// a new transaction here. This guarantees that the TransactionInfo stack
		// will be managed correctly even if no transaction was created by this aspect.
		txInfo.bindToThread();
		return txInfo;
	}
</code></pre>
<h2 id="总结">总结</h2>
<p>Spring事务管理通过AOP实现声明式事务控制的核心价值在于：</p>
<ol>
<li>
<p>关注点分离：事务逻辑由框架统一处理，业务代码更纯粹。</p>
</li>
<li>
<p>降低复杂度：开发者无需手动管理事务生命周期。</p>
</li>
<li>
<p>提升健壮性：通过统一的事务模板减少人为错误（如忘记回滚）。</p>
</li>
<li>
<p>灵活配置：支持多种事务策略，适配不同业务场景。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring常用拓展点]]></title>
        <id>https://q456qq520.github.io/post/spring-chang-yong-tuo-zhan-dian/</id>
        <link href="https://q456qq520.github.io/post/spring-chang-yong-tuo-zhan-dian/">
        </link>
        <updated>2025-05-11T03:49:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1自定义拦截器">1.自定义拦截器</h2>
<p>spring mvc拦截器跟spring拦截器相比，它里面能够获取<code>HttpServletRequest</code>和<code>HttpServletResponse</code>等web对象实例。</p>
<p>spring mvc拦截器的顶层接口是：HandlerInterceptor，包含三个方法：<br>
- preHandle 目标方法执行前执行<br>
- postHandle 目标方法执行后执行<br>
- afterCompletion 请求完成时执行</p>
<p>假如有权限认证、日志、统计的场景，可以使用该拦截器，用HandlerInterceptor接口的实现类HandlerInterceptorAdapter类。</p>
<p>第一步，继承HandlerInterceptorAdapter类定义拦截器：</p>
<pre><code class="language-java">public class AuthInterceptor extends HandlerInterceptorAdapter {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        String requestUrl = request.getRequestURI();
        if (checkAuth(requestUrl)) {
            return true;
        }

        return false;
    }

    private boolean checkAuth(String requestUrl) {
        System.out.println(&quot;===权限校验===&quot;);
        return true;
    }
}
</code></pre>
<p>第二步，将该拦截器注册到spring容器：</p>
<pre><code class="language-java">@Configuration
public class WebAuthConfig extends WebMvcConfigurerAdapter {
 
    @Bean
    public AuthInterceptor getAuthInterceptor() {
        return new AuthInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new AuthInterceptor());
    }
}
</code></pre>
<p>第三步，在请求接口时spring mvc通过该拦截器，能够自动拦截该接口，并且校验权限。</p>
<h2 id="2获取spring容器对象">2.获取Spring容器对象</h2>
<h3 id="21-beanfactoryaware接口">2.1 BeanFactoryAware接口</h3>
<pre><code class="language-java">@Service
public class PersonService implements BeanFactoryAware {
    private BeanFactory beanFactory;

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }

    public void add() {
        Person person = (Person) beanFactory.getBean(&quot;person&quot;);
    }
}
</code></pre>
<p>实现BeanFactoryAware接口，然后重写setBeanFactory方法，就能从该方法中获取到spring容器对象。</p>
<h3 id="22-applicationcontextaware接口">2.2 ApplicationContextAware接口</h3>
<pre><code class="language-java">@Service
public class PersonService2 implements ApplicationContextAware {
    private ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    public void add() {
        Person person = (Person) applicationContext.getBean(&quot;person&quot;);
    }
}
</code></pre>
<p>实现ApplicationContextAware接口，然后重写setApplicationContext方法，也能从该方法中获取到spring容器对象。</p>
<h3 id="23-applicationlistener接口">2.3 ApplicationListener接口</h3>
<pre><code class="language-java">@Service
public class PersonService3 implements ApplicationListener&lt;ContextRefreshedEvent&gt; {
    private ApplicationContext applicationContext;
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        applicationContext = event.getApplicationContext();
    }

    public void add() {
        Person person = (Person) applicationContext.getBean(&quot;person&quot;);
    }
}
</code></pre>
<p>实现接口ApplicationListener方式和实现ApplicationRunner，CommandLineRunner接口都不影响服务，都可以正常提供服务，注意监听的事件，通常是ApplicationStartedEvent 或者ApplicationReadyEvent，其他的事件可能无法注入bean。</p>
<h2 id="3全局异常处理">3.全局异常处理</h2>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public String handleException(Exception e) {
        if (e instanceof ArithmeticException) {
            return &quot;数据异常&quot;;
        }
        if (e instanceof Exception) {
            return &quot;服务器内部异常&quot;;
        }
        retur nnull;
    }
}
</code></pre>
<h2 id="4类型转换器">4.类型转换器</h2>
<p>spring目前支持3中类型转换器：</p>
<ol>
<li>Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象</li>
<li>ConverterFactory&lt;S, R&gt;：将 S 类型对象转为 R 类型及子类对象</li>
<li>GenericConverter：它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。</li>
</ol>
<h2 id="5导入配置">5.导入配置</h2>
<p>有时我们需要在某个配置类中引入其他的类，引入的类也加入到Spring容器中。 这时候可以使用注解<code>@Import</code>来完成这个功能。</p>
<h3 id="51-通用类">5.1 通用类</h3>
<pre><code class="language-java">public class A {
}

@Import(A.class)
@Configuration
public class TestConfiguration {
    
}
</code></pre>
<p>通过@Import注解引入类A，spring可以自动实例化A对象，然后在需要使用的地方通过注解@Autowired注入。</p>
<h3 id="52-配置类">5.2 配置类</h3>
<p>这种引入方式是最复杂的，因为@Configuration支持还支持多种组合注解，比如：</p>
<ul>
<li>@Import</li>
<li>@ImportResource</li>
<li>@PropertySource</li>
</ul>
<pre><code class="language-java">public class A {
}

public class B {
}

@Import(B.class)
@Configuration
public class AConfiguration {

    @Bean
    public A a() {
        return new A();
    }
}

@Import(AConfiguration.class)
@Configuration
public class TestConfiguration {
}
</code></pre>
<h3 id="53-importselector">5.3 ImportSelector</h3>
<pre><code class="language-java">public class AImportSelector implements ImportSelector {

    private static final String CLASS_NAME = &quot;com.test.A&quot;;

    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{CLASS_NAME};
    }
}

@Import(AImportSelector.class)
@Configuration
public class TestConfiguration {
}
</code></pre>
<p>这种方法的好处是selectImports方法返回的是一个数组，也就是说可以同时引入多个类。</p>
<h3 id="54-importbeandefinitionregistrar">5.4 ImportBeanDefinitionRegistrar</h3>
<pre><code class="language-java">public class AImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(A.class);
        registry.registerBeanDefinition(&quot;a&quot;, rootBeanDefinition);
    }
}

@Import(AImportBeanDefinitionRegistrar.class)
@Configuration
public class TestConfiguration {
}
</code></pre>
<p>这种方法是最灵活的。 容器注册对象可以在registerBeanDefinitions方法中获取，可以手动创建BeanDefinition注册到BeanDefinitionRegistry种。</p>
<h2 id="6-项目启动时">6. 项目启动时</h2>
<p>有时候我们需要在项目启动时定制化一些附加功能，比如：加载一些系统参数、完成初始化、预热本地缓存等，spring提供了：</p>
<ul>
<li>CommandLineRunner</li>
<li>ApplicationRunner</li>
</ul>
<pre><code class="language-java">@Component
public class TestRunner implements ApplicationRunner {

    @Autowired
    private LoadDataService loadDataService;

    public void run(ApplicationArguments args) throws Exception {
        loadDataService.load();
    }
}
</code></pre>
<pre><code class="language-java">@SpringBootApplication
public class Application implements CommandLineRunner {

    public static void main(String[] args) {
        System.out.println(&quot;--- Application main begin to start...&quot;);
        SpringApplication.run(Application.class, args);
        System.out.println(&quot;--- Application main has start...&quot;);
    }

    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;--- CommandLineRunner in Application...&quot;);
    }
}
</code></pre>
<p>实现ApplicationRunner接口，重写run方法，在该方法中实现自己定制化需求。</p>
<p>如果项目中有多个类实现了ApplicationRunner接口，他们的执行顺序要怎么指定呢？</p>
<p>答案是使用@Order(n)注解，n的值越小越先执行。当然也可以通过@Priority注解指定顺序。</p>
<h2 id="7修改beandefinition">7.修改BeanDefinition</h2>
<p>Spring IOC在实例化Bean对象之前，需要先读取Bean的相关属性，保存到BeanDefinition对象中，然后通过BeanDefinition对象，实例化Bean对象。</p>
<p>如果想修改BeanDefinition对象中的属性，该怎么办呢？</p>
<p>可以实现<code>BeanFactoryPostProcessor</code>接口。</p>
<pre><code class="language-java">@Component
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {
        DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;
        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);
        beanDefinitionBuilder.addPropertyValue(&quot;id&quot;, 100);
        //--...---
        defaultListableBeanFactory.registerBeanDefinition(&quot;user&quot;, beanDefinitionBuilder.getBeanDefinition());
    }
}
</code></pre>
<h2 id="8初始化bean前后">8.初始化Bean前后</h2>
<p>想在初始化Bean前后，实现一些自己的逻辑。这时可以实现：<code>BeanPostProcessor</code>接口。</p>
<p>该接口目前有两个方法：</p>
<ul>
<li>postProcessBeforeInitialization 该在初始化方法之前调用。</li>
<li>postProcessAfterInitialization 该方法再初始化方法之后调用。</li>
</ul>
<pre><code class="language-java">@Component
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof User) {
            ((User) bean).setUserName(&quot;name&quot;);
        }
        return bean;
    }
}
</code></pre>
<p>其实，我们经常使用的注解，比如：@Autowired、@Value、@Resource、@PostConstruct等，是通过AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor实现的。</p>
<h2 id="9初始化方法">9.初始化方法</h2>
<p>目前spring中使用比较多的初始化bean的方法有：</p>
<ul>
<li>使用@PostConstruct注解</li>
<li>实现InitializingBean接口</li>
</ul>
<h3 id="91-使用postconstruct注解">9.1 使用@PostConstruct注解</h3>
<p>在需要初始化的方法上增加@PostConstruct注解</p>
<h3 id="92-实现initializingbean接口">9.2 实现InitializingBean接口</h3>
<p>实现InitializingBean接口，重写afterPropertiesSet方法，该方法中可以完成初始化功能。</p>
<h2 id="10关闭容器前">10.关闭容器前</h2>
<pre><code class="language-java">@Service
public class DService implements InitializingBean, DisposableBean {
 
    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;DisposableBean destroy&quot;);
    }
 
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;InitializingBean afterPropertiesSet&quot;);
    }
}
</code></pre>
<h2 id="11自定义作用域">11.自定义作用域</h2>
<p>spring默认支持的Scope只有两种：</p>
<ul>
<li>singleton 单例，每次从spring容器中获取到的bean都是同一个对象。</li>
<li>prototype 多例，每次从spring容器中获取到的bean都是不同的对象。</li>
</ul>
<p>spring web又对Scope进行了扩展，增加了：</p>
<ul>
<li>RequestScope 同一次请求从spring容器中获取到的bean都是同一个对象。</li>
<li>SessionScope 同一个会话从spring容器中获取到的bean都是同一个对象。</li>
</ul>
<p>我们想在同一个线程中从spring容器获取到的bean都是同一个对象，该怎么办？</p>
<p>这就需要自定义Scope了</p>
<ol>
<li>第一步实现Scope接口</li>
<li>第二步将新定义的Scope注入到spring容器中</li>
<li>第三步使用新定义的Scope</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis 分布式锁如何自动续期？]]></title>
        <id>https://q456qq520.github.io/post/redis-fen-bu-shi-suo-ru-he-zi-dong-xu-qi/</id>
        <link href="https://q456qq520.github.io/post/redis-fen-bu-shi-suo-ru-he-zi-dong-xu-qi/">
        </link>
        <updated>2025-05-10T15:38:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="redis-实现分布式锁">Redis 实现分布式锁</h2>
<ol>
<li>指定一个 key 作为锁标记，存入 Redis 中，指定一个 唯一的用户标识作为 value。</li>
<li>当 key 不存在时才能设置值，确保同一时间只有一个客户端进程获得锁，满足互斥性特性。</li>
<li>设置一个过期时间，防止因系统异常导致没能删除这个 key，满足防死锁特性。</li>
<li>当处理完业务之后需要清除这个 key 来释放锁，清除 key 时需要校验 value 值，需要满足只有加锁的人才能释放锁 。</li>
</ol>
<h2 id="存在问题">存在问题</h2>
<p>如果这个锁的过期时间是30秒，但是业务运行超过了30秒，比如40秒，当业务运行到30秒的时候，锁过期了，其他客户端拿到了这个锁，怎么办<br>
我们可以设置一个合理的过期时间，让业务能够在这个时间内完成业务逻辑，但LockTime的设置原本就很不容易。</p>
<pre><code>LockTime设置过小，锁自动超时的概率就会增加，锁异常失效的概率也就会增加；
LockTime设置过大，万一服务出现异常无法正常释放锁，那么出现这种异常锁的时间也就越长。
</code></pre>
<p>我们只能通过经验去配置，一个可以接受的值，基本上是这个服务历史上的平均耗时再增加一定的buff。总体来说，设置一个合理的过期时间并不容易<br>
我们也可以不设置过期时间，让业务运行结束后解锁，但是如果客户端出现了异常结束了或宕机了，那么这个锁就无法解锁，变成死锁；</p>
<h2 id="自动续期">自动续期</h2>
<p>我们可以先给锁设置一个LockTime，然后启动一个守护线程，让守护线程在一段时间后，重新去设置这个锁的LockTime。</p>
<ol>
<li>和释放锁的情况一样，我们需要先判断持有锁客户端是否有变化。否则会造成无论谁持有锁，守护线程都会去重新设置锁的LockTime。</li>
<li>守护线程要在合理的时间再去重新设置锁的LockTime，否则会造成资源的浪费。不能动不动就去续。</li>
<li>如果持有锁的线程已经处理完业务了，那么守护线程也应该被销毁。不能业务运行结束了，守护者还在那里继续运行，浪费资源。</li>
</ol>
<h2 id="redisson的看门狗机制">Redisson的看门狗机制</h2>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1746891777926.jpg" alt="" loading="lazy"></figure>
<p>Redisson 锁的加锁机制如上图所示，线程去获取锁，获取成功则执行lua脚本，保存数据到redis数据库。如果获取失败: 一直通过while循环尝试获取锁(可自定义等待时间，超时后返回失败)，获取成功后，执行lua脚本，保存数据到redis数据库。Redisson提供的分布式锁是支持锁自动续期的，也就是说，如果线程仍旧没有执行完，那么redisson会自动给redis中的目标key延长超时时间，这在Redisson中称之为 Watch Dog 机制。同时 redisson 还有公平锁、读写锁的实现。</p>
<pre><code class="language-java">public void test() throws Exception{
        RLock lock = redissonClient.getLock(&quot;guodong&quot;);    // 拿锁失败时会不停的重试
        // 具有Watch Dog 自动延期机制 默认续30s 每隔30/3=10 秒续到30s
        lock.lock();
        // 尝试拿锁10s后停止重试,返回false 具有Watch Dog 自动延期机制 默认续30s
        boolean res1 = lock.tryLock(10, TimeUnit.SECONDS); 
        // 没有Watch Dog ，10s后自动释放
        lock.lock(10, TimeUnit.SECONDS);
        // 尝试拿锁100s后停止重试,返回false 没有Watch Dog ，10s后自动释放
        boolean res2 = lock.tryLock(100, 10, TimeUnit.SECONDS);
        Thread.sleep(40000L);
        lock.unlock();
    }

</code></pre>
<p>Redissson tryLock流程如下：</p>
<pre><code class="language-java">   public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
        long time = unit.toMillis(waitTime);
        long current = System.currentTimeMillis();
        long threadId = Thread.currentThread().getId();  // 1.尝试获取锁 
        Long ttl = tryAcquire(leaseTime, unit, threadId);  // lock acquired 
        if (ttl == null) {
            return true;
        }
        // 申请锁的耗时如果大于等于最大等待时间，则申请锁失败.  
        time -= System.currentTimeMillis() - current;
        if (time &lt;= 0) {
            acquireFailed(threadId);
            return false;
        }
        current = System.currentTimeMillis();
        /**  * 2.订阅锁释放事件，并通过 await 方法阻塞等待锁释放，有效的解决了无效的锁申请浪费资源的问题：  * 基于信息量，当锁被其它资源占用时，当前线程通过 Redis 的 channel 订阅锁的释放事件，一旦锁释放会发消息通知待等待的线程进行竞争.  *  * 当 this.await 返回 false，说明等待时间已经超出获取锁最大等待时间，取消订阅并返回获取锁失败.  * 当 this.await 返回 true，进入循环尝试获取锁.  */
        RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);  
        // await 方法内部是用 CountDownLatch 来实现阻塞，获取 subscribe 异步执行的结果（应用了 Netty 的 Future）  
        if (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) {
            if (!subscribeFuture.cancel(false)) {
                subscribeFuture.onComplete((res, e) -&gt; {
                    if (e == null) {
                        unsubscribe(subscribeFuture, threadId);
                    }
                });
            }
            acquireFailed(threadId);
            return false;
        }
        try {
            // 计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败.    
            time -= System.currentTimeMillis() - current;
            if (time &lt;= 0) {
                acquireFailed(threadId);
                return false;
            }
            /**    * 3.收到锁释放的信号后，在最大等待时间之内，循环一次接着一次的尝试获取锁    * 获取锁成功，则立马返回 true，    * 若在最大等待时间之内还没获取到锁，则认为获取锁失败，返回 false 结束循环    */
            while (true) {
                long currentTime = System.currentTimeMillis();        // 再次尝试获取锁    
                ttl = tryAcquire(leaseTime, unit, threadId);      // lock acquired     
                if (ttl == null) {
                    return true;
                }
                // 超过最大等待时间则返回 false 结束循环，获取锁失败     
                time -= System.currentTimeMillis() - currentTime;
                if (time &lt;= 0) {
                    acquireFailed(threadId);
                    return false;
                }
                /**      * 6.阻塞等待锁（通过信号量(共享锁)阻塞,等待解锁消息）：      */
                currentTime = System.currentTimeMillis();
                if (ttl &gt;= 0 &amp;&amp; ttl &lt; time) {
                    //如果剩余时间(ttl)小于wait time ,就在 ttl 时间内，从Entry的信号量获取一个许可(除非被中断或者一直没有可用的许可)。     
                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                } else {
                    //则就在wait time 时间范围内等待可以通过信号量      
                    getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);
                }
                // 更新剩余的等待时间(最大等待时间-已经消耗的阻塞时间)      
                time -= System.currentTimeMillis() - currentTime;
                if (time &lt;= 0) {
                    acquireFailed(threadId);
                    return false;
                }
            }
        } finally {
            // 7.无论是否获得锁,都要取消订阅解锁消息  
            unsubscribe(subscribeFuture, threadId);
        }
        return get(tryLockAsync(waitTime, leaseTime, unit));
    }
</code></pre>
<ol>
<li>尝试获取锁，返回 null 则说明加锁成功，返回一个数值，则说明已经存在该锁，ttl 为锁的剩余存活时间。</li>
<li>如果此时客户端 2 进程获取锁失败，那么使用客户端 2 的线程 id（其实本质上就是进程 id）通过 Redis 的 channel 订阅锁释放的事件。如果等待的过程中一直未等到锁的释放事件通知，当超过最大等待时间则获取锁失败，返回 false，如果等到了锁的释放事件的通知，则开始进入一个不断重试获取锁的循环。</li>
<li>循环中每次都先试着获取锁，并得到已存在的锁的剩余存活时间。如果在重试中拿到了锁，则直接返回。如果锁当前还是被占用的，那么等待释放锁的消息，具体实现使用了信号量 Semaphore 来阻塞线程，当锁释放并发布释放锁的消息后，信号量的 release() 方法会被调用，此时被信号量阻塞的等待队列中的一个线程就可以继续尝试获取锁了。</li>
<li>当锁正在被占用时，等待获取锁的进程并不是通过一个 while(true) 死循环去获取锁，而是利用了 Redis 的发布订阅机制,通过 await 方法阻塞等待锁的进程，有效的解决了无效的锁申请浪费资源的问题。</li>
</ol>
<h2 id="看门狗如何自动续期">看门狗如何自动续期</h2>
<p>Redisson看门狗机制， 只要客户端加锁成功，就会启动一个 Watch Dog。</p>
<pre><code class="language-java">  private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long leaseTime, TimeUnit unit, long threadId) {
        if (leaseTime != -1) {
            return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
        }
        RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; {
            if (e != null) {
                return;
            }        // lock acquired       
            if (ttlRemaining == null) {
                scheduleExpirationRenewal(threadId);
            }
        });
        return ttlRemainingFuture;
    }
</code></pre>
<p>⚠️同时需要注意的是：</p>
<ol>
<li>watchDog 只有在未显示指定加锁时间（leaseTime）时才会生效。（这点很重要）</li>
<li>lockWatchdogTimeout设定的时间不要太小 ，比如我之前设置的是 100毫秒，由于网络直接导致加锁完后，watchdog去延期时，这个key在redis中已经被删除了。</li>
</ol>
<h2 id="续期原理">续期原理</h2>
<p>续期原理其实就是用lua脚本，将锁的时间重置为30s</p>
<pre><code class="language-java">   private void scheduleExpirationRenewal(long threadId) {
        ExpirationEntry entry = new ExpirationEntry();
        ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);
        if (oldEntry != null) {
            oldEntry.addThreadId(threadId);
        } else {
            entry.addThreadId(threadId);
            renewExpiration();
        }
    }

    protected RFuture&lt;Boolean&gt; renewExpirationAsync(long threadId) {
        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; + &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; + &quot;return 1; &quot; + &quot;end; &quot; + &quot;return 0;&quot;, Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
    }
</code></pre>
<p>Watch Dog 机制其实就是一个后台定时任务线程，获取锁成功之后，会将持有锁的线程放入到一个 RedissonLock.EXPIRATION_RENEWAL_MAP里面，然后每隔 10 秒 （internalLockLeaseTime / 3） 检查一下，如果客户端 还持有锁 key（判断客户端是否还持有 key，其实就是遍历 EXPIRATION_RENEWAL_MAP 里面线程 id 然后根据线程 id 去 Redis 中查，如果存在就会延长 key 的时间），那么就会不断的延长锁 key 的生存时间。</p>
<p>如果服务宕机了，Watch Dog 机制线程也就没有了，此时就不会延长 key 的过期时间，到了 30s 之后就会自动过期了，其他线程就可以获取到锁。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis选举流程]]></title>
        <id>https://q456qq520.github.io/post/redis-xuan-ju-liu-cheng/</id>
        <link href="https://q456qq520.github.io/post/redis-xuan-ju-liu-cheng/">
        </link>
        <updated>2025-05-10T03:17:28.000Z</updated>
        <content type="html"><![CDATA[<p>为了实现Redis读写分离的方式实现高可靠，我们使用redis集群模式，而且为了防止主节点压力过大，假设优化成了主-从-从模式。</p>
<p><strong>思考一个问题，主节点此时挂了怎么办</strong></p>
<p>这里主从模式下涉及到的几个问题：</p>
<ol>
<li>主库真的挂了吗？</li>
<li>我们应当选择哪个从库作为主库？</li>
<li>怎样让其他从库知道新的主库信息呢？</li>
<li>中断的数据如何恢复？</li>
</ol>
<p>所以我们引入哨兵机制</p>
<h2 id="什么是哨兵机制">什么是哨兵机制？</h2>
<p>在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这几个问题。</p>
<p>Redis引入哨兵（Sentinel）机制的主要目的是为了增强其高可用性和自动故障恢复能力。在分布式系统中，特别是用作数据存储的数据库系统中，保障高可用性是至关重要的，以确保系统在面对节点故障等情况时能够继续提供服务。</p>
<p><strong>哨兵实现了什么功能呢？</strong><br>
下面是Redis官方文档的描述：</p>
<ul>
<li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li>自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li>
<li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li>
<li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<h2 id="哨兵机制的基本流程">哨兵机制的基本流程</h2>
<p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1746849001674.png" alt="" loading="lazy"></figure>
<h3 id="监控">监控</h3>
<p>Redis哨兵的监控流程涉及多个步骤，用于实时监控Redis集群中各个节点的状态并采取必要的措施来确保集群的可用性和稳定性。</p>
<ol>
<li>
<p>节点发现和配置： 哨兵通过配置文件指定要监控的主节点和从节点。启动哨兵后，它会连接到指定的节点，并获取有关其他节点的信息，形成一个初始的监控拓扑。</p>
</li>
<li>
<p>心跳检测： 哨兵会定期向监控的节点发送PING命令来检测节点是否存活。这些节点可以是主节点、从节点或其他哨兵节点。如果哨兵在一定时间内没有收到响应，它会认为节点不可用。</p>
</li>
<li>
<p>节点状态变更： 当哨兵连续多次无法连接到一个节点时，它会将该节点标记为主观下线。当多个哨兵都将节点标记为主观下线时，这个节点会被认为是客观下线。</p>
</li>
<li>
<p>故障判断和选举： 当主节点被标记为客观下线时，哨兵会执行故障判断。它会从剩余的健康主节点中选举一个作为新的主节点，并将该信息广播给其他哨兵和客户端。故障判断的逻辑考虑了多个因素，包括优先级、最近一次复制偏移量等。</p>
</li>
<li>
<p>自动故障切换： 如果主节点被标记为客观下线，哨兵会通知从节点晋升为新的主节点。同时，哨兵会更新其他从节点的配置，使其复制新的主节点。这确保了即使主节点发生故障，集群仍然可以继续提供服务。</p>
</li>
<li>
<p>监控从节点： 哨兵还会监控从节点的状态，包括从节点是否与主节点保持同步，以及从节点的复制延迟情况。如果从节点无法同步或者复制延迟过高，哨兵会将其标记为不健康。</p>
</li>
<li>
<p>节点恢复： 如果一个节点从客观下线状态恢复，哨兵会将其标记为健康，并将其重新纳入集群中。从节点恢复后，它会重新同步主节点的数据。</p>
</li>
<li>
<p>配置更新： 如果集群的拓扑发生变化，例如添加或移除节点，哨兵会自动更新配置，以便客户端能够正确连接到集群。</p>
</li>
<li>
<p>事件通知： 哨兵通过发布订阅机制向订阅者（通常是客户端）发送有关集群状态变化的消息。这使得应用程序能够根据实时的集群状态做出相应的决策。</p>
</li>
<li>
<p>持续监控： 哨兵会持续地监控集群中的节点，定期执行心跳检测、状态更新和故障判断，以确保集群的稳定运行。</p>
</li>
</ol>
<h3 id="主观下线与客观下线">主观下线与客观下线</h3>
<p>在Redis的哨兵监控机制中，有两个关键概念：<code>主观下线（Subjective Down）</code>和<code>客观下线（Objective Down）</code>。这些概念帮助哨兵判断节点的可用性和故障状态。</p>
<ol>
<li>
<p>主观下线（Subjective Down）： 主观下线是指单个哨兵节点认为一个特定的Redis节点（主节点、从节点或其他哨兵）不可用。主观下线是一种主观的判断，是基于单个哨兵节点的观察结果得出的。当一个哨兵无法连接到某个Redis节点，它会将该节点标记为主观下线。多个哨兵节点可能会对同一个节点发出主观下线标记。</p>
</li>
<li>
<p>客观下线（Objective Down）： 客观下线是指在整个哨兵集合中达成一致，认为某个特定的Redis节点不可用。客观下线是一种更客观的判断，需要多个哨兵节点共同达成一致。当多个哨兵节点都主观下线同一个Redis节点时，这个节点会被认为是客观下线。</p>
</li>
</ol>
<p>举例说明：</p>
<ul>
<li>
<p>假设有三个哨兵节点：Sentinel A、Sentinel B 和 Sentinel C，以及一个主节点 Master 和一个从节点 Slave。如果 Sentinel A 无法连接到 Master 节点，它会将 Master 标记为主观下线。同样地，如果 Sentinel B 也无法连接到 Master 节点，它也会将 Master 标记为主观下线。但这还不足以让 Master 被认为是客观下线。</p>
</li>
<li>
<p>当 Sentinel A 和 Sentinel B 都主观下线了 Master 节点，并且他们相互通信时发现了这个情况，他们就会在达成一致意见后将 Master 节点标记为客观下线。这时，整个哨兵集合达成一致，认为 Master 节点已下线。</p>
</li>
</ul>
<p>客观下线是一个更严格的判断，需要多个哨兵节点一致认为某个节点不可用，才会触发后续的故障判断和自动故障切换等动作。这种机制确保了在一个哨兵节点认为某节点下线时，不会立即触发故障切换，以避免误判造成不必要的切换。只有多个哨兵节点一致认为节点下线，才会触发后续的故障处理流程。</p>
<h3 id="如何选定新主库">如何选定新主库</h3>
<p>在Redis Sentinel模式中，当主节点（Master）发生故障导致下线后，哨兵会通过选举过程选择一个新的主节点（Master）来取代原来的主节点。选定新主库的过程如下：</p>
<ol>
<li>
<p>主观下线和客观下线判断： 当哨兵节点主观下线（单个哨兵认为不可用）一个主节点时，如果多数哨兵都主观下线了同一个主节点，那么这个主节点会被标记为客观下线（多数派共识）。</p>
</li>
<li>
<p>选举新主节点： 当一个主节点被标记为客观下线后，哨兵节点会开始选举一个新的主节点。选举过程如下：<br>
哨兵会在所有没有下线的从节点（Slaves）中选择一个作为新主节点。哨兵会选择一个延迟最小、复制偏移量最大的从节点作为新主节点。这确保了新主节点是最接近原主节点的从节点。<br>
如果没有合适的从节点，哨兵会选择一个具备最高优先级的从节点，将其升级为主节点。如果优先级相同，那么哨兵会选择一个复制偏移量最大的从节点。</p>
</li>
<li>
<p>故障转移和切换： 一旦新主节点被选定，哨兵会发起故障转移操作。旧主节点会变成新主节点的一个从节点。其他从节点会重新配置，指向新的主节点。这个过程会保证尽量不丢失数据，并且保证整个集群的高可用性。</p>
</li>
</ol>
<p>选定新主库的过程是一个由哨兵节点协同工作的流程，确保了在主节点故障的情况下，尽可能地选择一个合适的从节点作为新的主节点，实现集群的高可用性和数据完整性。</p>
<h3 id="如何配置哨兵">如何配置哨兵</h3>
<ol>
<li>哨兵配置文件： 在Redis 6.x版本中，哨兵的配置文件名称默认为redis-sentinel.conf。</li>
<li>配置变化： Redis 6.x版本引入了一些新的哨兵配置选项，以适应新的功能和改进。以下是一些常见的配置选项：<br>
sentinel monitor mymaster 127.0.0.1 6379 2   # 监控名为 &quot;mymaster&quot; 的主节点，2表示至少需要2个哨兵同意主观下线才会执行故障转移<br>
sentinel down-after-milliseconds mymaster 5000   # 主观下线判定为5秒无响应<br>
sentinel parallel-syncs mymaster 1   # 执行故障转移时同时同步的从节点数量<br>
sentinel failover-timeout mymaster 10000   # 故障转移超时时间为10秒<br>
sentinel auth-pass mymaster mypassword   # 主节点的访问密码</li>
<li>启动哨兵节点： 在Redis 6.x版本中，启动哨兵节点的命令为：<br>
redis-server /path/to/redis-sentinel.conf --sentinel</li>
<li>查看哨兵状态： 使用以下命令查看Redis 6.x版本哨兵节点的状态：<br>
redis-cli -p 26379<br>
sentinel master mymaster   # 查看主节点的信息<br>
sentinel slaves mymaster   # 查看从节点的信息<br>
sentinel sentinels mymaster   # 查看其他哨兵节点的信息</li>
</ol>
<h3 id="哨兵是如何互相发现的">哨兵是如何互相发现的？</h3>
<p>我们查看配置可以看到，我们并没有配置从节点的哨兵，我们只配置了主节点地址。</p>
<p>那么哨兵之间是如何互相发现通信的呢？</p>
<p>在Redis Sentinel（哨兵）集群中，哨兵节点之间通过发布订阅机制来互相发现和通信。这种方式使得哨兵节点能够监控主节点和从节点的状态，并进行故障检测和故障转移。</p>
<p>以下是哨兵集群如何通过发布订阅机制互相发现的工作流程：</p>
<ol>
<li>
<p>初始连接： 在启动时，每个哨兵节点会尝试连接到指定的主节点。这些哨兵节点通过配置文件中的sentinel monitor命令指定要监控的主节点信息。</p>
</li>
<li>
<p>Sentinel命令发布： 当一个哨兵节点成功连接到主节点后，它会开始定期向主节点发送PING命令，以确保主节点处于活跃状态。如果哨兵节点检测到主节点不可用，它会将一个+switch-master命令发布到频道中，通知其他哨兵节点。</p>
</li>
<li>
<p>发布订阅机制： Redis的发布订阅机制允许一个节点（发布者）向一个或多个节点（订阅者）广播消息。在哨兵集群中，每个哨兵节点都订阅了一个名为__sentinel__:hello的频道，用于接收其他哨兵节点发送的信息。<br>
<img src="https://q456qq520.github.io/post-images/1746851281045.png" alt="" loading="lazy"></p>
</li>
<li>
<p>发现其他哨兵节点： 当一个哨兵节点成功连接到主节点后，它会向__sentinel__:hello频道发布一个&quot;Hello&quot;消息，其中包含它自己的信息（如IP地址和端口号）。其他哨兵节点通过订阅这个频道，可以获取所有其他哨兵节点的信息。</p>
</li>
<li>
<p>收集哨兵信息： 每个哨兵节点通过订阅__sentinel__:hello频道，收集到其他哨兵节点的信息。这使得每个哨兵节点都知道了集群中其他哨兵节点的存在。</p>
</li>
<li>
<p>故障检测和转移： 当一个哨兵节点检测到主节点不可用时，它会通过发布+switch-master命令来通知其他哨兵节点。这个命令包含了新的主节点信息，以及在执行故障转移时需要的其他信息。其他哨兵节点收到这个命令后，会进行判断并可能发起故障转移。</p>
</li>
</ol>
<p>通过以上机制，哨兵节点可以相互发现和通信，共同监控主节点和从节点的状态，并在主节点下线时协同执行故障转移操作。这种发布订阅机制确保了哨兵集群中节点之间的实时信息传递和协作。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1746852009500.png" alt="" loading="lazy"></figure>
<h2 id="由哪个哨兵执行主从切换">由哪个哨兵执行主从切换？</h2>
<h3 id="客观下线具体判断流程">客观下线具体判断流程</h3>
<ol>
<li>
<p>故障检测： 哨兵节点定期向集群中的所有主节点和从节点发送PING命令来检测节点的可用性。如果一个哨兵节点连续一定次数没有收到节点的回复，就会将该节点标记为可能进入客观下线状态。</p>
</li>
<li>
<p>Quorum判断： 在判断一个节点是否客观下线时，需要考虑Quorum的概念。Quorum是指一个最小的投票数，当达到或超过这个投票数时，哨兵认为节点可能进入客观下线状态。Quorum的值通常设置为哨兵节点数量的一半加一。</p>
</li>
<li>
<p>投票过程： 当哨兵节点开始怀疑某个节点可能客观下线时，它会向其他哨兵节点发送一个SENTINEL is-master-down-by-addr命令，询问其他哨兵节点是否也认为该节点客观下线。其他哨兵节点会对此做出回应，根据回应的数量来判断是否达到Quorum。</p>
</li>
<li>
<p>达到Quorum： 如果收到的回应数量达到或超过Quorum，那么哨兵节点就会认为该节点进入客观下线状态。这表示集群中有足够多的哨兵都认为该节点可能下线，进而触发后续的主从切换流程。</p>
</li>
<li>
<p>执行后续操作： 一旦一个节点被认为客观下线，哨兵节点将开始执行故障转移操作，选择新的主节点并开始同步数据。这将最终导致一个新的主节点被选出，从而实现高可用性。</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1746852276842.png" alt="" loading="lazy"></figure>
<h2 id="选举leader流程">选举Leader流程</h2>
<p>Redis Sentinel（哨兵）是用于监控和管理Redis主从复制以及自动故障切换的工具。当主节点失效时，哨兵会协调选择一个从节点作为新的主节点，这涉及到选举Leader的过程。详细流程如下：</p>
<ol>
<li>监控主节点： 哨兵持续监控Redis主节点的状态，包括主节点是否在线，主从复制是否正常，以及哨兵和其他节点的通信情况。</li>
<li>检测主节点失效： 当哨兵检测到主节点失效（例如，无法响应PING命令），它会将主节点标记为“主观下线”。</li>
<li>广播主观下线状态： 一旦主观下线状态被确认，哨兵会广播该信息给其他哨兵和节点，告知主节点已经“主观下线”。</li>
<li>投票： 当其他哨兵收到关于主观下线状态的广播时，它们会进行投票来决定是否需要进行领导者选举。</li>
<li>选举Leader： 如果多个哨兵都认为主节点失效，它们将进入领导者选举过程。选举过程使用了Raft算法的变体。</li>
<li>提议投票： 在选举过程中，哨兵会提议自己作为领导者，然后请求其他哨兵投票支持。</li>
<li>投票表决： 哨兵在收到提议后会表决是否支持该提议。通常，哨兵会投票给具有最高配置版本号的提议者。</li>
<li>Quorum判断： 在选举过程中，哨兵需要收集足够数量的投票，达到Quorum（大多数）的支持才能选举成功。</li>
<li>选出新领导者： 如果某个哨兵获得足够多的投票，超过了Quorum，那么它将被选为新的领导者。</li>
<li>通知其他节点： 新选出的Leader会向其他哨兵和节点广播其成为领导者的消息，确保集群中的所有节点都知道领导者的变更。</li>
<li>故障切换： 一旦新的Leader选举完成，哨兵会协调进行故障切换，将一个从节点提升为新的主节点，使整个集群继续正常运行。</li>
<li>恢复正常状态： 一旦故障切换完成，新的主节点将开始处理客户端请求，集群会恢复到正常运行状态。</li>
</ol>
<p>需要注意的是，Redis Sentinel的选举Leader过程受到Paxos算法和Raft算法等分布式一致性算法的影响，以保证在主节点失效时能够选择合适的节点作为新的主节点，从而保持数据的一致性和高可用性。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1746852708045.png" alt="" loading="lazy"></figure>
<p>⚠️<br>
如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得 2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置 3 个哨兵实例。</p>
<p>要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值 down-after-milliseconds。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ThreadLocal简介]]></title>
        <id>https://q456qq520.github.io/post/threadlocal-jian-jie/</id>
        <link href="https://q456qq520.github.io/post/threadlocal-jian-jie/">
        </link>
        <updated>2025-05-07T09:45:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-threadlocal简介">一、ThreadLocal简介</h2>
<p><code>ThreadLocal</code>顾名思义可以根据字面意思理解成线程本地变量。也就是说如果定义了一个ThreadLocal，每个线程都可以在这个ThreadLocal中读写，这个读写是线程隔离的，线程之前不会有影响。</p>
<p>每个Thread都维护自己的一个ThreadLocalMap ，所以是线程隔离的。</p>
<pre><code class="language-java">/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre>
<p>通过这个ThreadLocalMap实现数据的读写，既然是Map肯定有key和value，但是这个ThreadLocalMap的key可以简单的看成是ThreadLocal，实际是并不是ThreadLocal的本身，而是它的一个弱引用。</p>
<h2 id="二-threadlocal方法和成员变量">二、ThreadLocal方法和成员变量</h2>
<h3 id="api">API</h3>
<p>ThreadLocal的API很少就包含了4个，分别是get()、set()、remove()、withInitial()，源码如下：</p>
<pre><code class="language-java">public T get() {}

public void set(T value){}

public void remove(){}

public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) {
        
}
</code></pre>
<ul>
<li>get()：获取当前线程对应的ThreadLocalMap存储的值，key为当前TheadLocal（实际为TheadLocal的弱引用），也就是获取当前线程本地变量的值。</li>
<li>set(T value)：给当前线程对应的ThreadLocalMap的设置值，也就是给当前线程本地变量设置值。</li>
<li>remove()：清除前线程对应的ThreadLocalMap存储的TheadLocal，也就是清除当前线程本地变量的值。</li>
<li>withInitial()：用于创建一个线程局部变量，变量的初始化值通过调用Supplier的get方法来确定</li>
</ul>
<h3 id="成员变量">成员变量</h3>
<pre><code class="language-java">// 调用nextHashCode()方法获取下一个hashCode值，用于计算ThreadLocalMap.tables数组下标
// key.threadLocalHashCode &amp; (len - 1)
private final int threadLocalHashCode = nextHashCode();

// 原子类，用于计算hashCode值
private staitc AmoicInteger nextHashCode = new AmoicInteger();

// hash增量值，斐波那契数也叫黄金分割数，可以让hash值分布非常均匀
private static final int HASH_INCREMENT = 0x61c88647；

// 获取下一个hashCode值方法，只用原子类操作
private static int nextHashCode () {
    return nextHashCode.getAndAdd(HASH_INCREMENT);
}
</code></pre>
<h2 id="三-threadlocalmap">三、ThreadLocalMap</h2>
<p>ThreadLocalMap是ThreadLocal类的一个静态内部类，在上面有说到每个线程都维护着一个ThreadLocalMap，这个`ThreadLocalMap 就是用来储存数据的。</p>
<p>ThreadLocalMap内部维护着一个Entry节点，这个节点继承了WeakReference类，泛型为ThreadLocal表示是弱引用，节点内部定义了一个为Object的value，这个value就是我们存放的值，Entry类的构造方法只有一个，传入key和value，这个key就是ThreadLocal，实际为ThreadLocal的弱引用。</p>
<pre><code class="language-java">static class Entry extends WeakReference&lt;ThreacLocal&lt;?&gt;&gt; {
    Object value;
    
    Entry(ThreadLocal&lt;?&gt; k, Object v){
        super(k);
        value = v;
    }
}
</code></pre>
<h3 id="thread-threadlocalmap-threadlocal结构关系">Thread、ThreadLocalMap、ThreadLocal结构关系</h3>
<p>每个Thread都有一个ThreadLocalMap变量，ThreadLocalMap内部定义了Entry节点类，这个节点继承了WeakReference类泛型为ThreacLocal类，节点类的构造方法ThreadLocal&lt;?&gt; k, Object v，所以可以得到下面的结构关系图：</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1746611761654.webp" alt="" loading="lazy"></figure>
<h3 id="gc之后key是否为null">GC之后key是否为null？</h3>
<p>既然ThreadLocalMap的key是弱引用，GC之后key是否为null？在搞清楚这个问题之前，我们需要先搞清楚Java的四种引用类型：</p>
<ul>
<li>
<p>强引用：new出来的对象就是强引用，只要强引用存在，垃圾回收器就永远不会回收被引用的对象，哪怕内存不足的时候。</p>
</li>
<li>
<p>软引用：使用SoftReference修饰的对象被称为软引用，在内存要溢出的时候软引用指向的对象会被回收。</p>
</li>
<li>
<p>弱引用：使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，被弱引用指向的对象就会被回收。</p>
</li>
<li>
<p>虚引用：虚引用是最弱的引用，用PhantomReference进行定。唯一的作用就是用来队列接受对象即将死亡的通知。</p>
<p>**这个问题的答案是不为null **，可以看下面的图</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1746612119050.webp" alt="" loading="lazy"></figure>
<p>通过上图我们知道ThreadLocal的强引用是仍然存在的，所以不会被回收，不为null</p>
<h3 id="threadlocalmap成员变量">ThreadLocalMap成员变量</h3>
</li>
</ul>
<pre><code class="language-java">  // 初始化容量 必须为2的幂，位运算取代模运算提升计算效率，可以试hash值发生碰撞的概率更小，尽可能的使
// 元素在哈希表中均匀的散列
private static final int INITTAL_CAPACIRY = 16;

// Entry表
private Entry[] table;

// Entry表存放的元素数量
private int size = 0;

// 扩容阙值
private int threshold;
</code></pre>
<h2 id="四-threadlocalset方法源码详解">四、ThreadLocal.set()方法源码详解</h2>
<h3 id="set方法">set()方法</h3>
<pre><code class="language-java">pubic void set(T value) {
    // 获取当前线程
    Thread t = Threac.currentThread();
    // 获取当前线程的ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    // 如果map不为null， 调用ThreadLocalMap.set()方法设置值
    if (map != null)
        map.set(this, value);
    else 
        // map为null，调用createMap()方法初始化创建map
        createMap(t, value);
}

// 返回线程的ThreadLocalMap.threadLocals
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

// 调用ThreadLocalMap构造方法创建ThreadLocalMap
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}

// ThreadLocalMap构造方法，传入firstKey, firstValue
ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {
    // 初始化Entry表的容量 = 16
    table = new Entry[INITIAL_CAPACITY];
    // 获取ThreadLocal的hashCode值与运算得到数组下标
    int i = firsetKey.threadLocalHashCode &amp; (INITAL_CAPACITY - 1);
    // 通过下标Entry表赋值
    table[i] = new Entry(firstKey, firstValue);
    // Entry表存储元素数量初始化为1
    size = 1;
    // 设置Entry表扩容阙值 默认为 len * 2 / 3
    setThreshold(INITIAL_CAPACITY);
}

private void setThreshold(int len) {
    threshold = len * 2 / 3
}
</code></pre>
<p>ThreadLocal.set()方法还是很简单的，核心方法在ThreadLocalMap.set()方法，ThreadLocal.set()方法流程如下：</p>
<ol>
<li>获取当前线程的ThreadLocalMap map 。</li>
<li>如果map不为null则调用map.set()方法设置值。</li>
<li>如果map为null则调用createMap方法创建。</li>
<li>createMap()方法通过ThreadLocalMap的构造方法创建，构造方法主要做了初始化Entry[] table容量16，通过ThreadLocal的threadLocalHashCode调用nextHashCode()方法获取hashCode值计算出下标，table数组通过下标赋值，初始化存储的元素数量，初始化数组扩容阙值。</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1746612417635.webp" alt="" loading="lazy"></figure>
<p>ThreadLocalMap在构造方法里处理的时候用到hash算法，源码如下：</p>
<pre><code class="language-java">int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);

private final int threadLocalHashCode = nextHashCode();

private static final int HASH_INCREMENT = 0x61c88647;

private static int nextHashCode() {
    return nextHashCode.getAndAdd(HASH_INCREMENT);
}
</code></pre>
<p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，ThreadLocal中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code>，每创建一个ThreadLocal就会调用一次nextHashCode()方法，这个HASH_INCREMENT值就会增长0x61c88647，这个值很特殊，是斐波那契数也叫黄金分割数，这个值可以让hash分布非常均匀。</p>
<p>ThreadLocalMap.set()方法分为好几种情况，主要有以下四种情况，针对不同的情况我们通过画图来说明。</p>
<blockquote>
<p>说明： 下面所有图中，绿色块Entry代表正常数据，灰色代表Entry的key值为null，已被GC回收，白色代表Entry为null。</p>
</blockquote>
<p><strong>第一种情况</strong>：通过hash计算得到的下标，该下标对应的Entry为null，这种情况直接将该数据放入该槽位即可。<br>
<img src="https://q456qq520.github.io/post-images/1746612601919.webp" alt="" loading="lazy"></p>
<p><strong>第二种情况</strong>：通过hash计算得到的下标，该下标对应的Entry不为null，但是key相同，这种情况直接更新该槽位的value值。<br>
<img src="https://q456qq520.github.io/post-images/1746612706011.webp" alt="" loading="lazy"></p>
<p><strong>第三种情况</strong>：通过hash计算得到的下标，该下标对应的Entry不为null，且key不相同，这种时候会遍历数组，线性往后查找，查找Entry为null的槽位，且在找到Entry为null之前没有遇到key过期的Entry，就该数据放入该槽位中，如果遍历过程中，遇到了key相等的槽位，直接更新value即可：</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1746612782318.webp" alt="" loading="lazy"></figure>
<p>注意：每次循环查找都会判断key是否相等，如果相等则更新value直接返回。</p>
<p><strong>第四种情况</strong>：基于第三种情况，如果在找到Entry为null之前遇到了key过期的Entry，如下图：</p>
<figure data-type="image" tabindex="5"><img src="https://q456qq520.github.io/post-images/1746612801162.webp" alt="" loading="lazy"></figure>
<p>如上图散列数组下标为7位置对应的Entry数据key为null，说明此数据key值已经被垃圾回收掉了，此时会执行<code>replaceStaleEntry()</code>方法，该方法含义是替换过期数据的逻辑，以index=7为起点开始向前遍历，进行探测式数据清理工作。</p>
<p>初始化探测式清理过期数据扫描的开始位置：<code>slotToExpunge = stateSlot = 7</code>。</p>
<p>以当前stateSlot 开始向前迭代找到，找到其他过期的数据，然后更新过期数据起始扫描下标的slotToExpunge ，直到找到了Entry为null的槽位则结束。</p>
<p>如果找到过期数据，继续向前迭代，直到遇到Entry=null的槽位则停止迭代。</p>
<figure data-type="image" tabindex="6"><img src="https://q456qq520.github.io/post-images/1746612982058.webp" alt="" loading="lazy"></figure>
<p>上图以当前节点index = 7向前迭代，检测是否有过期的Entry数据，如果有则更新slotToExpunge的值，遇到Entry为null则结束探测，以上图为例slotToExpunge被更新为0。</p>
<p>上面向前迭代的操作是为了更新探测清理过期数据的起始位置soltToExpunge的值，这个值是用来判断当前过期槽位staleSlot之前是否还有过期元素。</p>
<p>接着开始staleSolt位置index = 7向后迭代，如果找到了相等key的Entry的数据则更新value值，如下图：</p>
<figure data-type="image" tabindex="7"><img src="https://q456qq520.github.io/post-images/1746612994133.webp" alt="" loading="lazy"></figure>
<p>从当前节点staleSolt位置开始向后寻找key相等的Entry位置，如果找到了key相等的Entry，则会交换staleSlot元素的位置，且更新value值，然后进行过期Entry的清理工作，如下图：</p>
<figure data-type="image" tabindex="8"><img src="https://q456qq520.github.io/post-images/1746613005200.webp" alt="" loading="lazy"></figure>
<p>如果没有找到相等key的Entry的数据，如下图：</p>
<figure data-type="image" tabindex="9"><img src="https://q456qq520.github.io/post-images/1746613019830.webp" alt="" loading="lazy"></figure>
<p>从当前节点staleSlot向后查找key值相等的Entry，如果没有找到，则会继续往后查找直到找到Entry为null停止，然后创建新的Entry，替换stableSlot的位置。</p>
<p>替换完成之后也是进行过期元素的清理工作，清理工作的方法主要有两个<code>expungeStaleEntry</code>和<code>cleanSomeSlots</code>。</p>
<pre><code class="language-java">private void set(ThreadLocal&lt;?&gt; key, Object value) {
    // 获取Entry表
    Entry[] tab = table;
    // 获取表长度
    int len = tab.length;
    // 获取当前要放入元素的下标
    int i = key.threadLocalHashCode &amp; (len - 1);
    
    // 循环查找
    for (Entry e = tab[i]; 
         e != null;
         e = tab[i = nextIndex(i, len)]){
        ThreadLocal&lt;?&gt; k = e.get();
        
        // 如果查找到key相等的entry，则更新value
        if (k == key) {
            v.value = value;
            return;
        }
        
        // 如果查找到为key为null的entry，说明key过期，被GC回收
        // 这个时候要初始化探测式清理的起始位置
        // 替换过期元素
        if (k == null) {
            replaceStateEntry(key, value, i);
            return;
        }
    }
    
    // 循环查找过程中，没有找到key相等的entry，且没有key过期的entry
    // 则新建一个entry放入entry表中
    table[i] = new Entry(key, value);
    
    // 存放元素数量+1
    int sz = ++size;
    // 调用启发式清理， 且元素数量大于扩容阙值
    // 则调用rehash方法，该方法会进行key过期的entry清理工作，清理完成之后再判断是否需要扩容
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        rehash();
}
</code></pre>
<p>上面代码流程主要如下：</p>
<ol>
<li>首先获取Entry表，Entry表长度，通过hashCode计算下标，然后for循环Entry表。</li>
<li>如果循环查找过程中找到了key相等的Entry则更新value对应我们上面说的第二种情况。</li>
<li>如果循环查找过程找到了key为null的Entry，说明key过期了，替换过期元素，需要初始化探测式清理的其实位置，调用replaceStaleEntry()方法，这个方法我们下面再说，这个对应我们上面说的第四种情况。</li>
<li>for循环查找完毕，说明在查找过程中该下标对应的Entry为null，则在新建一个Entry放入该槽位，然后调用启发式清理工作。</li>
<li>如果启发式清理未清理任务数据，且size超过扩容阙值(2/3)，则调用rehash()方法，该方法会先进行一次探测式清理，清理过期元素，清理完毕之后如果size &gt;= threshold - threshold / 4 ，则会进行扩容操作。</li>
</ol>
<p>接下来看核心方法<code>replaceStaleEntry()</code>，该方法在查找过程中遇到key = null数据的时候会执行，该方法提供了替换过期数据的功能，可以对应上面说第四种情况来看，源码如下：</p>
<pre><code class="language-java">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,
                                       int staleSlot) {
    // 获取Entry表
    Entry[] tab = table;
    // 获取Entry表长度
    int len = tab.length;
    Entry e;

    // 定义探测式清理起始位置 slotToExpunge = staleSlot
    int slotToExpunge = staleSlot;
    
    // 从staleSlot开始向前迭代查找是否有key=null的entry
    // 如果有则更新slotToExpunge
    for (int i = prevIndex(staleSlot, len);
         (e = tab[i]) != null;
         i = prevIndex(i, len))
        if (e.get() == null)
            slotToExpunge = i;

    // staleSlot开始向后循环
    for (int i = nextIndex(staleSlot, len);
         (e = tab[i]) != null;
         i = nextIndex(i, len)) {
        ThreadLocal&lt;?&gt; k = e.get();

        // 如果查找到了key相等entry
        // 则替换staleSlot和i的位置，且更新value的值
        if (k == key) {
            e.value = value;
            
               // 替换staleSlot和i的位置
            tab[i] = tab[staleSlot];
            // 更新value值
            tab[staleSlot] = e;
            
            // 如果slotToExpunge == staleSlot，说明向前循环的没有查找到key过期的entry
            // 更新slotToExpunge值
            // 则会调用启动式过期清理，先会进行一遍过期元素探测操作
            if (slotToExpunge == staleSlot)
                slotToExpunge = i;
            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
            return;
        }

        // 如果找到了key为null 且向前循环的没有查找到key过期的entry
        // 则更新slotToExpunge
        if (k == null &amp;&amp; slotToExpunge == staleSlot)
            slotToExpunge = i;
    }

    // 说明没有找到k == key的数据，且碰到Entry为null的数据
    // 则将数据放入该槽位
    tab[staleSlot].value = null;
    tab[staleSlot] = new Entry(key, value);

    // slotToExpunge != staleSlot 说明从staleSlot开始向前迭代查找有key=null的entry
    if (slotToExpunge != staleSlot)
        // 启动式清理之前，先会进行一次过期元素探测，如果发现了有过期的数据就会先进行探测式清理
        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
}
</code></pre>
<p>上面代码主要流程如下：</p>
<ol>
<li>首先获取Entry表，Entry表长度，定义探测式清理起始位置 slotToExpunge = staleSlot。</li>
<li>从staleSlot开始向前迭代查找是否有key=null的entry，如果有则更新slotToExpunge。</li>
<li>staleSlot开始向后循环，如果查找到了key相等entry，则替换staleSlot和i的位置，且更新value的值，然后判断slotToExpunge == staleSlot，说明向前循环的没有查找到key过期的entry， 然后更新slotToExpunge值，则会调用启动式过期清理，先会进行一遍过期元素探测操作，如果发现了有过期的数据就会先进行探测式清理。</li>
<li>如果找到了key为null 且向前循环的没有查找到key过期的entry，则更新slotToExpunge。</li>
<li>循环结束，方法没有退出，说明没有找到k == key的数据，且碰到Entry=null的数据，则将数据放入该槽位。</li>
<li>最后判断slotToExpunge != staleSlot，说明从staleSlot开始向前迭代查找有key=null的entry，则调用启动式清理，在启动式清理之前，先会进行一次过期元素探测，如果发现了有过期的数据就会先进行探测式清理。</li>
</ol>
<h3 id="threadlocalmap过期-key-的启发式清理流程">ThreadLocalMap过期 key 的启发式清理流程</h3>
<p>ThreadLocalMap两种过期key数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p>
<h4 id="探测式清理">探测式清理</h4>
<p>探测式清理方法expungeStaleEntry，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的Entry设置为null，遍历过程如果遇到未过期的数据则会将此数据rehash后重新在table数组中定位，如果定位的位置已经有了元素，则会将未过期的数据放在最靠近此位置的Entry = null的桶中，使rehash后的Entry数据距离正确的桶位置更近一点。这种优化会提高整个散列表查询性能。</p>
<pre><code class="language-java">// staleSlot探测式清理起始位置
private int expungeStaleEntry(int staleSlot) {
    Entry[] tab = table;
    int len = tab.length;
    
    // 将起始位置置空
    tab[staleSlot].value = null;
    tab[staleSlot] = null;
    // 元素数量减1
    size--;

    // 重新迭代散列，直到发现空槽
    Entry e;
    int i;
    for (i = nextIndex(staleSlot, len);
         (e = tab[i]) != null;
         i = nextIndex(i, len)) {
        ThreadLocal&lt;?&gt; k = e.get();
        // 如果key过期，则清空元素，数量减1
        if (k == null) {
            e.value = null;
            tab[i] = null;
            size--;
        } else {
            // 如果key没有过期，则重新计算hash，重新获取下标
            int h = k.threadLocalHashCode &amp; (len - 1);
            // 如果当前下标存在值，则寻找离冲突key所在entry最近的空槽
            if (h != i) {
                // i位置槽置空
                tab[i] = null;

                // 寻找离冲突key所在entry最近的空槽，放入该槽
                while (tab[h] != null)
                    h = nextIndex(h, len);
                tab[h] = e;
            }
        }
    }
    return i;
}
</code></pre>
<h4 id="启发式清理">启发式清理</h4>
<pre><code class="language-java">private boolean cleanSomeSlots(int i, int n) {
    boolean removed = false;
    Entry[] tab = table;
    int len = tab.length;
    do {
        i = nextIndex(i, len); // 从下一个位置开始
        Entry e = tab[i];
        // 遍历到key==null的Entry
        if (e != null &amp;&amp; e.get() == null) {
            n = len; // 重置n
            removed = true; // 标志有清理元素
            i = expungeStaleEntry(i); // 清理
        }
    } while ( (n &gt;&gt;&gt;= 1) != 0); // log(n) 限制--对数次
    return removed;
}
</code></pre>
<p>从i的下一个位置判断元素是否需要清除，如果遇到key==null的元素则会重置n，需要清除且更新i的值，判断且清除完毕之后，n = n &gt;&gt;&gt; 1直到n = 0则退出清理。</p>
<h2 id="五-threadlocalmapget方法详解">五、ThreadLocalMap.get()方法详解</h2>
<p>主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。</p>
<p>相等情况：相等情况处理很简单，直接返回value，如下图：</p>
<figure data-type="image" tabindex="10"><img src="https://q456qq520.github.io/post-images/1746613556386.webp" alt="" loading="lazy"></figure>
<p>上图中比如get(ThreadLocal1)计算下标为4，且4存在Entry，且key相等，则直接返回value = 11。</p>
<p>不相等情况：</p>
<p>以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。如下图：</p>
<figure data-type="image" tabindex="11"><img src="https://q456qq520.github.io/post-images/1746613716653.webp" alt="" loading="lazy"></figure>
<p>迭代到index=5的数据时，此时Entry.key=null，触发一次探测式数据回收操作，执行expungeStaleEntry()方法，执行完后，index 5,8的数据都会被回收，而index 6,7的数据都会前移，此时继续往后迭代，到index = 6的时候即找到了key值相等的Entry数据，如下图：</p>
<figure data-type="image" tabindex="12"><img src="https://q456qq520.github.io/post-images/1746613647463.webp" alt="" loading="lazy"></figure>
<pre><code class="language-java">public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    // 未找到的话，则调用setInitialValue()方法设置null
    return setInitialValue();
}

private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode &amp; (table.length - 1);
    Entry e = table[i];
    // key相等直接返回
    if (e != null &amp;&amp; e.get() == key)
        return e;
    else
        // key不相等调用getEntryAfterMiss()方法
        return getEntryAfterMiss(key, i, e);
}

private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;
    
    // 迭代往后查找key相等的entry
    while (e != null) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key)
            return e;
        // 遇到key=null的entry，先进行探测式清理工作
        if (k == null)
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}
</code></pre>
<h3 id="threadlocalmap的扩容机制">ThreadLocalMap的扩容机制</h3>
<p>在ThreadLocalMap.set()方法最后，如果执行完启发式清理工作之后，未清理任何数据，且当前散列数组中元素已经超过扩容阙值len*2/3，则执行rehash()逻辑：</p>
<pre><code class="language-java">if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
    rehash();
</code></pre>
<pre><code class="language-java">private void rehash() {
    //先进行探测式清理工作
    expungeStaleEntries();

    //探测式清理完毕之后 如果size &gt;= threshold - threshold / 4
    // 也就是size &gt;= threshold * 3/4，也就是 size &gt;= len * 1/2，则扩容
    if (size &gt;= threshold - threshold / 4)
        resize();
}

private void expungeStaleEntries() {
    Entry[] tab = table;
    int len = tab.length;
    for (int j = 0; j &lt; len; j++) {
        Entry e = tab[j];
        if (e != null &amp;&amp; e.get() == null)
            expungeStaleEntry(j);
    }
}
</code></pre>
<p>rehash()方法源码流程如下：</p>
<ol>
<li>首先进行探测式清理工作</li>
<li>如果探测式清理工作完毕之后，如果size &gt;= threshold - threshold / 4， 也就是size &gt;= threshold * 3/4，也就是 size &gt;= len * 1/2，则调用resize()扩容。</li>
</ol>
<p>扩容方法resize()方法源码如下：</p>
<pre><code class="language-java">private void resize() {
    Entry[] oldTab = table;
    int oldLen = oldTab.length;
    int newLen = oldLen * 2;
    Entry[] newTab = new Entry[newLen];
    int count = 0;

    for (int j = 0; j &lt; oldLen; ++j) {
        Entry e = oldTab[j];
        if (e != null) {
            ThreadLocal&lt;?&gt; k = e.get();
            if (k == null) {
                e.value = null;
            } else {
                int h = k.threadLocalHashCode &amp; (newLen - 1);
                while (newTab[h] != null)
                    h = nextIndex(h, newLen);
                newTab[h] = e;
                count++;
            }
        }
    }

    setThreshold(newLen);
    size = count;
    table = newTab;
}
</code></pre>
<p>扩容方法执行之后tab的大小为原先的两倍oldLen * 2，然后变量老的散列表，重新计算hash位置，然后放到新的散列表中，如果出现hash冲突则往后寻找最近的entry为null的槽位放入，扩容完成之后，重新计算扩容阙值。</p>
<h2 id="六-threadlocalremove方法源码详解">六、ThreadLocal.remove()方法源码详解</h2>
<pre><code class="language-java">public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}

private void remove(ThreadLocal&lt;?&gt; key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len-1);
    
    // 从hash获取的下标开始，寻找key相等的entry元素清除
    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear();
            expungeStaleEntry(i);
            return;
        }
    }
}
</code></pre>
<p>ThreadLocal.remove()核心是调用ThreadLocalMap.remove()方法，流程如下：</p>
<ol>
<li>通过hash计算下标。</li>
<li>从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。</li>
</ol>
<blockquote>
<p>参考地址： <a href="https://javaguide.cn/java/concurrent/threadlocal.html">ThreadLocal详解</a>。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring bean的生命周期]]></title>
        <id>https://q456qq520.github.io/post/spring-bean-de-sheng-ming-zhou-qi/</id>
        <link href="https://q456qq520.github.io/post/spring-bean-de-sheng-ming-zhou-qi/">
        </link>
        <updated>2025-04-28T03:45:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是-bean">什么是 Bean</h2>
<blockquote>
<p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.</p>
</blockquote>
<p>简而言之，bean 是由 Spring IoC 容器实例化、组装和管理的对象。</p>
<h2 id="什么是-spring-bean-的生命周期">什么是 Spring Bean 的生命周期</h2>
<p>对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p>
<p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。</p>
<h2 id="bean生命周期">Bean生命周期</h2>
<p>⚠️这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>
<h3 id="bean-的作用域">bean 的作用域</h3>
<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<h3 id="spring-singleton-bean-的生命周期">Spring Singleton Bean 的生命周期</h3>
<ol>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ol>
<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<blockquote>
<p>Bean实例化的时机也分为两种，BeanFactory管理的Bean是在使用到Bean的时候才会实例化Bean，ApplicantContext管理的Bean在容器初始化的时候就会完成Bean实例化。</p>
</blockquote>
<blockquote>
<p>“实例化”和“初始化”是两个完全不同的过程，千万不要搞混，实例化只是给 Bean 分配了内存空间，而初始化则是将程序的执行权，从系统级别转换到用户级别，并开始执行用户添加的业务代码。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1745812173127.png" alt="" loading="lazy"></figure>
<p>Bean实例化前后，可以进行一些处理，但是如果从Bean实例化前算开始，那么就要追溯到容器的初始化、beanDefiinition的加载开始。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1745812261215.png" alt="" loading="lazy"></figure>
<ol>
<li>实例化：第 1 步，实例化一个 Bean 对象</li>
<li>属性赋值：第 2 步，为 Bean 设置相关属性和依赖</li>
<li>初始化：初始化的阶段的步骤比较多，5、6步是真正的初始化，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean就可以被使用了</li>
<li>销毁：第 8~10步，第8步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 Bean 时再执行相应的方法</li>
</ol>
<h3 id="spring-singleton-bean-的生命周期详解">Spring Singleton Bean 的生命周期详解</h3>
<h4 id="docreatebean">doCreateBean</h4>
<pre><code class="language-java">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
    }

    if (instanceWrapper == null) {
        // 实例化阶段
        instanceWrapper = this.createBeanInstance(beanName, mbd, args);
    }

    ...

    Object exposedObject = bean;

    try {
        // 属性赋值阶段
        this.populateBean(beanName, mbd, instanceWrapper);
        // 初始化阶段
        exposedObject = this.initializeBean(beanName, exposedObject, mbd);
    } catch (Throwable var18) {
        ...
    }

    ...
}
</code></pre>
<p>至于销毁，是在容器关闭时调用的，详见<code>ConfigurableApplicationContext#close()</code></p>
<h4 id="createbeaninstance">createBeanInstance</h4>
<pre><code class="language-java">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
		//首先确保bean 已经被解析过
		Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);
        // 如果beanClass 不是public 类型，那么就 抛出异常，提示   non-public access not allowed
		if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
			throw new BeanCreationException(mbd.getResourceDescription(), beanName,
					&quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName());
		}
        // 如果存在，就返回一个  callback回调函数，在 obtainFromSupplier 方法里面
        //调用对应的具体方法 ，并转换成 BeanWrapper 类型
		Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
		if (instanceSupplier != null) {
		   // 这里转换成 BeanWrapper  类型
			return obtainFromSupplier(instanceSupplier, beanName);
		}
        // 如果存在对应的工厂方法，那么就使用工厂方法进行初始化
		if (mbd.getFactoryMethodName() != null) {
			return instantiateUsingFactoryMethod(beanName, mbd, args);
		}

		// Shortcut when re-creating the same bean...
		boolean resolved = false;
		boolean autowireNecessary = false;
		if (args == null) {
			synchronized (mbd.constructorArgumentLock) {
			//一个类有多个构造函数，每个构造商数都有不同的参数,所以调用前前需要先根据参数锁定构 
            //边的数或对应的工厂方法 
				if (mbd.resolvedConstructorOrFactoryMethod != null) {
				    // 设置 已经解析
					resolved = true;
					autowireNecessary = mbd.constructorArgumentsResolved;
				}
			}
		}
		//如果已经解析过则使用解析好的构造函数方法，不用再次锁定 
		if (resolved) {
		    // 构造函数参数都已经解析完
			if (autowireNecessary) {
			    // 使用构造函数自动注入
				return autowireConstructor(beanName, mbd, null, null);
			}
			else {
      			//使用其默认构造函数实例化给定的bean
				return instantiateBean(beanName, mbd);
			}
		}

		// Candidate constructors for autowiring?
		// 如果上面没有解析好对应的构造函数， 这里看看有没有指定构造函数
		/**
		  具体里面其实 是 SmartInstantiationAwareBeanPostProcessor , 这个类 继承了
		  InstantiationAwareBeanPostProcessor， 调用里面的determineCandidateConstructors 方法 
		  来确认有没有指定的构造函数
		*/
		Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
		if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
			// 构造函数自动注入
			return autowireConstructor(beanName, mbd, ctors, args);
		}

		// 获取确定用于默认构造的首选构造函数（如果有）。 如有必要，构造函数参数将自动装配。
		ctors = mbd.getPreferredConstructors();
		if (ctors != null) {
			return autowireConstructor(beanName, mbd, ctors, null);
		}

		// 默认使用无参构造函数
		return instantiateBean(beanName, mbd);
	}
</code></pre>
<h4 id="populatebean">populateBean</h4>
<pre><code class="language-java"> protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
    if (bw == null) {
       // 如果beanWrapper为空，说明bean实例为null，需要跳过property值的设置
       // 但是如果beanWrapper为空而且mbd.hasPropertyValues()为true，说明bean实例为null，bean定义中存在property值，需要抛出异常
       if (mbd.hasPropertyValues()) {
          throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
       }
       else {
          // Skip property population phase for null instance.
          return;
       }
    }
 ​
    // 如果Bean是记录类型，那么Spring将跳过属性填充阶段，因为记录类型的属性是不可变的，无法进行属性注入
    if (bw.getWrappedClass().isRecord()) {
       if (mbd.hasPropertyValues()) {
          throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to a record&quot;);
       }
       else {
          // Skip property population phase for records since they are immutable.
          return;
       }
    }
 ​
    // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
    // state of the bean before properties are set. This can be used, for example,
    // to support styles of field injection.
    // 在设置属性之前，让任何InstantiationAwareBeanPostProcessors都有机会修改bean的状态。例如，这可以用于支持现场注入的样式。
    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
       for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
          if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
             return;
          }
       }
    }
 ​
    // 属性填充值
    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
 ​
    // 自动装配类型 byName byType
    int resolvedAutowireMode = mbd.getResolvedAutowireMode();
    if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
       // 根据pvs 封装属性值
       MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
       // Add property values based on autowire by name if applicable.
       if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
          // 添加属性值，根据byName
          autowireByName(beanName, mbd, bw, newPvs);
       }
       // Add property values based on autowire by type if applicable.
       if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
          // 添加属性值，根据byType
          autowireByType(beanName, mbd, bw, newPvs);
       }
       pvs = newPvs;
    }
    // 此工厂是否持有InstantiationAwareBeanPostProcessor后置处理器
    if (hasInstantiationAwareBeanPostProcessors()) {
       if (pvs == null) {
          pvs = mbd.getPropertyValues();
       }
       // 遍历后置处理器，如果返回非空的PropertyValues，将pvs更新为返回的PropertyValues
       for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
          PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
          if (pvsToUse == null) {
             return;
          }
          pvs = pvsToUse;
       }
    }
 ​
    boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);
    if (needsDepCheck) {
       PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
       checkDependencies(beanName, mbd, filteredPds, pvs);
    }
 ​
    if (pvs != null) {
       // 将属性应用到 bean 中
       applyPropertyValues(beanName, mbd, bw, pvs);
    }
 }
</code></pre>
<h4 id="initializebean">initializeBean</h4>
<p>如果bean实现了InitializingBean接口，那么initializeBean会调用bean的afterPropertiesSet方法。这个方法在bean的属性初始化后会被执行。</p>
<p>如果在配置文件中通过init-method或注解指定了初始化方法，那么initializeBean会调用这个方法。</p>
<pre><code class="language-java"> protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
    //用于执行BeanNameAware、BeanClassLoaderAware和BeanFactoryAware等Aware回调方法
    invokeAwareMethods(beanName, bean);
 ​
    Object wrappedBean = bean;
    // 如果mbd不为空并且不是合成bean，则执行BeanPostProcessor的beforeInitialization方法
    // 这里明明是mbd == null，为什么要解释成不为空呢，下面会有解释
    if (mbd == null || !mbd.isSynthetic()) {
       wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }
 ​
    try {
       // 执行bean的初始化方法
       invokeInitMethods(beanName, wrappedBean, mbd);
    }
    catch (Throwable ex) {
       throw new BeanCreationException(
             (mbd != null ? mbd.getResourceDescription() : null), beanName, ex.getMessage(), ex);
    }
    // 如果bean定义不存在或者bean不是合成的，则调用applyBeanPostProcessorsAfterInitialization方法，对bean进行初始化后的后处理器。
    if (mbd == null || !mbd.isSynthetic()) {
       wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }
 ​
    return wrappedBean;
 }

</code></pre>
<h2 id="什么是循环依赖">什么是循环依赖</h2>
<p>循环依赖就是循环引用，就是两个或多个 bean 相互之间的持有对方，比如 TestA 引用 TestB，TestB 引用 TestC，TestC引用 TestA，则他们最终会形成一个闭环。</p>
<h3 id="spring-是如何解决循环依赖的">Spring 是如何解决循环依赖的</h3>
<h4 id="构造器循环依赖">构造器循环依赖</h4>
<ol>
<li>表示通过构造器注入构成的循环依赖，此依赖是无法解决的，只能拋出 BeanCurcenlylCreationException 异常表示循环依赖</li>
<li>如在创建 TestA类时，构造器需要 TestB 类，那将去创建 TestB，在创建 TestB 类时又发现需要 TestC 类，则又去创建TestC，最终在创建 TestC 时发现又需要 TestA，从而形成一个环，没办法创建。</li>
<li>Spring 容器将每一个正在创建的 bean 标识符放在一个当前创建 bean 池中，bean标识符在创建过程中将一直保持在这个池中，因此如果在创建 bean 过程中发现自己已经在当的创建bean 池里时，将抛出 BeanCurrentlyInCreationException 异常表示循环依赖；而对于创建完毕的bean 将从当前创建bean池中清除掉。</li>
</ol>
<h4 id="setter-循环依赖">setter 循环依赖</h4>
<p>表示通过 setter 注入方式构成的循环依赖。对于 setter 注人造成的依赖是通过 Spring 容器提前暴露刚完成构造器注入但未完成其他步骤（如 setter 注入）的bean来完成的，而且只能解决单例作用域的bean 循环依赖。通过提前暴露一个单例工厂方法，从而使其他 bean 能引用到该bean。</p>
<ol>
<li>Spring 容器创建单例 testA bean，首先根据无参构造器创建 bean，并暴露一个ObjectFactory用于返回一个提前暴露一个创建中的bean，并将testA 标识符放到当前创建bean 池，然后进行 setter 注入testB。</li>
<li>Spring 容器创建单例 testB bean，首先根据无参构造器创建 bean，并暴露一个ObjectFactory用于返回一个提前暴露一个创建中的 bean，并将testB 标识符放到当前创建 bean池，然后进行 setter 注入testC。</li>
<li>Spring 容器创建单例 testC bean，首先根据无参构造器创建 bean，并暴露一个ObjectFactory用于返回一个提前暴露一个创建中的 bean，并将testC 标识符放到当前创建 bean池，然后进行 setter 注入testA。进行注入testA 时由于提前暴露了ObjectFactory工厂，从而使用它返回提前暴露一个创建中的bean。</li>
<li>最后在依赖注入testB 和 testA，完成 setter 注入。</li>
<li>对于单例 bean 来说，可以通过 setAllowCircularRefernces(false)来禁用循环引用</li>
</ol>
<h3 id="三级缓存">三级缓存</h3>
<p>第⼀级缓存：singletonObjects，⽤于保存实例化、注⼊、初始化完成的 bean 实例；<br>
第⼆级缓存：earlySingletonObjects，⽤于保存实例化完成的 bean 实例；<br>
第三级缓存：singletonFactories，⽤于保存 bean 创建⼯⼚，以便后⾯有机会创建代理对象。</p>
<pre><code class="language-java">/** Cache of singleton objects: bean name --&gt; bean instance */
/** 一级缓存：用于存放完全初始化好的 bean **/
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);
 
/** Cache of early singleton objects: bean name --&gt; bean instance */
/** 二级缓存：存放原始的 bean 对象（尚未填充属性），用于解决循环依赖 */
private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);

/** Cache of singleton factories: bean name --&gt; ObjectFactory */
/** 三级级缓存：存放 bean 工厂对象，用于解决循环依赖 */
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);

</code></pre>
<h3 id="getsingleton方法中三级缓存的使用">getSingleton方法中三级缓存的使用</h3>
<pre><code class="language-java">protected Object getSingleton(String beanName, boolean allowEarlyReference) {
  // Spring首先从singletonObjects（一级缓存）中尝试获取
  Object singletonObject = this.singletonObjects.get(beanName);
  // 若是获取不到而且对象在建立中，则尝试从earlySingletonObjects(二级缓存)中获取
  if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
    synchronized (this.singletonObjects) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null &amp;&amp; allowEarlyReference) {
          ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
          if (singletonFactory != null) {
            //若是仍是获取不到而且允许从singletonFactories经过getObject获取，则经过singletonFactory.getObject()(三级缓存)获取
              singletonObject = singletonFactory.getObject();
              //若是获取到了则将singletonObject放入到earlySingletonObjects,也就是将三级缓存提高到二级缓存中
              this.earlySingletonObjects.put(beanName, singletonObject);
              this.singletonFactories.remove(beanName);
          }
        }
    }
  }
  return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
</code></pre>
<p>三级缓存的使用过程如下</p>
<ol>
<li>Spring 会先从一级缓存 singletonObjects 中尝试获取 Bean。</li>
<li>若是获取不到，而且对象正在建立中，就会尝试从二级缓存 earlySingletonObjects 中获取 Bean。</li>
<li>若还是获取不到，且允许从三级缓存 singletonFactories 中经过 singletonFactory 的 getObject() 方法获取 Bean 对象，就会尝试从三级缓存 singletonFactories 中获取 Bean。</li>
<li>若是在三级缓存中获取到了 Bean，会将该 Bean 存放到二级缓存中。</li>
</ol>
<h3 id="为什么要三级缓存">为什么要三级缓存?</h3>
<p>二级缓存也是可以解决循环依赖的。为什么 Spring 不选择二级缓存，而要额外多添加一层缓存，使用三级缓存呢？</p>
<p>如果 Spring 选择二级缓存来解决循环依赖的话，那么就意味着所有 Bean 都需要在实例化完成之后就立马为其创建代理，而 Spring 的设计原则是在 Bean 初始化完成之后才为其创建代理。</p>
<p>使用三级缓存而非二级缓存并不是因为只有三级缓存才能解决循环引用问题，其实二级缓存同样也能很好解决循环引用问题。使用三级而非二级缓存并非出于 IOC 的考虑，而是出于 AOP 的考虑，即若使用二级缓存，在 AOP 情形注入到其他 Bean的，不是最终的代理对象，而是原始对象。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql物化和半连接]]></title>
        <id>https://q456qq520.github.io/post/mysql-wu-hua-he-ban-lian-jie/</id>
        <link href="https://q456qq520.github.io/post/mysql-wu-hua-he-ban-lian-jie/">
        </link>
        <updated>2025-04-23T02:28:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="物化materialization">物化（Materialization）</h2>
<p>物化应该是指将子查询的结果存储到一个临时表中，这样后续的查询可以直接使用这个临时表，而不需要每次都重新执行子查询。这样可以减少重复计算，尤其是在子查询结果集较大的情况下，可能提高性能。</p>
<h3 id="适用场景">适用场景：</h3>
<ol>
<li>非相关子查询：子查询不依赖外层查询的值，可以独立执行并缓存结果。</li>
<li>子查询结果集较大：如果子查询返回的结果集较大，物化可以避免重复计算，提高效率。</li>
<li>需要多次访问子查询结果：例如子查询被用于JOIN或WHERE条件多次时，物化临时表可以复用。</li>
<li>子查询复杂度高：若子查询包含聚合、排序或复杂过滤（如GROUP BY, DISTINCT），物化可减少计算开销。</li>
</ol>
<h3 id="示例">示例</h3>
<pre><code>SELECT * FROM customers 
WHERE id IN (SELECT customer_id FROM orders WHERE amount &gt; 100);
</code></pre>
<p>若子查询SELECT customer_id FROM orders的结果集大且无索引，优化器可能物化结果到临时表，再与customers表JOIN。</p>
<p>优化提示：</p>
<p>使用SUBQUERY提示强制物化：</p>
<pre><code>SELECT /*+ SUBQUERY(MATERIALIZATION) */ * FROM customers ...;
</code></pre>
<h2 id="半连接">半连接</h2>
<p>半连接通常用于存在性检查，比如使用IN或者EXISTS子句时。半连接和普通连接的不同之处在于，半连接只需要返回外层表中存在匹配的记录，而不会返回多条匹配记录导致重复。</p>
<h3 id="适用场景-2">适用场景：</h3>
<ol>
<li>存在性检查：使用IN或EXISTS时，只需判断外层记录是否存在匹配，无需返回所有匹配项。</li>
<li>相关子查询：子查询依赖外层查询的值，需逐行判断。</li>
<li>索引可用性高：若子查询字段有索引（如customer_id上的索引），半连接可通过索引快速定位匹配项。</li>
<li>结果集较小：子查询结果集较小时，半连接避免物化开销，直接通过索引高效匹配。</li>
</ol>
<pre><code class="language-mysql">SELECT * FROM departments d 
WHERE EXISTS (SELECT 1 FROM employees e WHERE e.dept_id = d.id);
</code></pre>
<p>若employees.dept_id有索引，优化器可能选择半连接策略，仅检查是否存在匹配记录。</p>
<p>优化提示：</p>
<p>使用SEMIJOIN提示强制半连接策略：</p>
<pre><code>SELECT /*+ SEMIJOIN(DUPSWEEDOUT) */ * FROM departments ...;
</code></pre>
<h2 id="关键选择因素">关键选择因素</h2>
<table>
<thead>
<tr>
<th>因素</th>
<th>物化</th>
<th>半连接</th>
</tr>
</thead>
<tbody>
<tr>
<td>子查询相关性</td>
<td>非相关子查询</td>
<td>相关或非相关子查询</td>
</tr>
<tr>
<td>结果集大小</td>
<td>大结果集</td>
<td>小结果集</td>
</tr>
<tr>
<td>索引情况</td>
<td>无高效索引时更优</td>
<td>子查询字段有索引时更优</td>
</tr>
<tr>
<td>执行频率</td>
<td>结果需多次访问时更优</td>
<td>单次存在性检查更优</td>
</tr>
<tr>
<td>资源消耗</td>
<td>占用临时表空间</td>
<td>通常内存友好</td>
</tr>
</tbody>
</table>
<h3 id="调试与优化建议">调试与优化建议</h3>
<ol>
<li>使用EXPLAIN分析：通过执行计划查看优化器选择的策略（如MATERIALIZED或SEMIJOIN）。</li>
<li>强制策略：通过优化器提示（如/*+ SEMIJOIN(...) */）干预选择。</li>
<li>索引优化：为子查询字段添加索引，提升半连接效率。</li>
<li>权衡资源：物化可能占用更多内存/磁盘，需根据系统资源调整。</li>
</ol>
<p>总结：非相关大结果集优先物化，相关或索引友好场景选半连接，结合EXPLAIN和实际性能测试进行调优。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTPS]]></title>
        <id>https://q456qq520.github.io/post/https-qing-qiu-jie-duan-fen-xi/</id>
        <link href="https://q456qq520.github.io/post/https-qing-qiu-jie-duan-fen-xi/">
        </link>
        <updated>2024-04-10T06:15:39.000Z</updated>
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2022147586&auto=1&height=66"></iframe>
<h2 id="1-请求阶段分析">1. 请求阶段分析</h2>
<p>一个完整、无任何缓存、未复用连接的 HTTPS 请求需要经过以下几个阶段：DNS 域名解析、TCP 握手、SSL 握手、服务器处理、内容传输。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1712729855422.png" alt="" loading="lazy"></figure>
<h2 id="2-请求阶段耗时分析">2. 请求阶段耗时分析</h2>
<p>HTTPS 请求的各个阶段可以使用 curl 命令进行详细的耗时分析[2]。如表 2-2 所示， curl 提供了详细的耗时分析选项，这样我们就可以更准确地掌握每一个环节的消耗时间，进一步提升网络优化的效率和精度。</p>
<p>表-网络请求阶段分析</p>
<table>
<thead>
<tr>
<th>请求阶段</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>time_namelookup</td>
<td>从请求开始到域名解析完成的耗时</td>
</tr>
<tr>
<td>time_connect</td>
<td>从请求开始到 TCP 三次握手完成耗时</td>
</tr>
<tr>
<td>time_appconnect</td>
<td>从请求开始到 TLS 握手完成的耗时</td>
</tr>
<tr>
<td>time_pretransfer</td>
<td>从请求开始到向服务器发送第一个 GET/POST 请求开始之前的耗时</td>
</tr>
<tr>
<td>time_redirect</td>
<td>重定向时间，包括到内容传输前的重定向的 DNS 解析、TCP 连接、内容传输等时间</td>
</tr>
<tr>
<td>time_starttransfer</td>
<td>从请求开始到内容传输前的时间</td>
</tr>
<tr>
<td>time_total</td>
<td>从请求开始到完成的总耗时</td>
</tr>
</tbody>
</table>
<p>对一个接口使用 curl 测试：</p>
<pre><code class="language-java">$ curl -w '\n time_namelookup=%{time_namelookup}\n time_connect=%{time_connect}\n time_appconnect=%{time_appconnect}\n time_redirect=%{time_redirect}\n time_pretransfer=%{time_pretransfer}\n time_starttransfer=%{time_starttransfer}\n time_total=%{time_total}\n' -o /dev/null -s 'https://www.thebyte.com.cn/'
// 输出的结果
time_namelookup=0.025021
time_connect=0.033326
time_appconnect=0.071539
time_redirect=0.000000
time_pretransfer=0.071622
time_starttransfer=0.088528
time_total=0.088744
</code></pre>
<blockquote>
<p>curl 操作参见 https://catonmat.net/cookbooks/curl ↩︎</p>
</blockquote>
<h2 id="3-域名解析环节实践">3. 域名解析环节实践</h2>
<h3 id="31-域名解析的工作原理">3.1 域名解析的工作原理</h3>
<p>域名解析靠的是 DNS，我们在浏览器输入一个域名时，DNS 负责将该域名解析为相应的 IP 地址，以便后续与目标服务器建立 TCP/IP 连接。探寻 DNS 工作原理之前，我们先了解域名的结构。如图 2-3 所示，域名是一种树状结构，最顶层的域名是根域名（注意是一个点“.”，它是 .root 的含义），然后是顶级域名（top-level domain，简写 TLD），再是一级域名、二级域名、三级域名。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1712731210190.webp" alt="" loading="lazy"></figure>
<p><strong>DNS 解析流程</strong></p>
<ol>
<li>用户向 DNS 解析器（也称为递归解析器，例如电信运营商的 114.114.114.114）发出解析 example.com 域名请求。</li>
<li>DNS解析器 判断是否存在解析缓存，如存在返回缓存结果。如无则就近向 Root nameserver (根域名服务器)请求所属 TLD 域名服务器。</li>
<li>获取 com.域的 TLD 域名服务器后， 向该地址请求 example.com. 的 权威解析服务器（Authoritative nameserver）。</li>
<li>得到权威解析服务器地址后，向该服务获取域名对应的 IP 地址，域名解析过程结束。</li>
</ol>
<h3 id="32-dns-故障排查">3.2 DNS 故障排查</h3>
<ol>
<li>使用 nslookup 命令<br>
第一个介绍的是 nslookup 命令，该命令用于查询 DNS 的记录、域名解析是否正常等。</li>
</ol>
<p>nslookup 命令示例：</p>
<pre><code class="language-java">$ nslookup thebyte.com.cn        
Server:		8.8.8.8
Address:	8.8.8.8#53

Non-authoritative answer:
Name:	thebyte.com.cn
Address: 110.40.229.45
</code></pre>
<p>第一行的 Server 为当前使用的 DNS解析器。<br>
Non-authoritative answer 因为 DNS 解析器只是转发权威解析服务器的记录，所以为非权威应答。<br>
Address 为解析结果，上面的解析可以看到是一个A记录 110.40.229.45。</p>
<ol start="2">
<li>使用 dig 命令<br>
nslookup 返回的结果比较简单，如果想获取更多的信息，可以尝试使用 dig 命令。</li>
</ol>
<p>dig命令示例：</p>
<pre><code class="language-java">$ dig thebyte.com.cn

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; thebyte.com.cn
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 63697
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;thebyte.com.cn.			IN	A

;; ANSWER SECTION:
thebyte.com.cn.		599	IN	A	110.40.229.45

;; Query time: 14 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Fri May 12 15:22:33 CST 2023
;; MSG SIZE  rcvd: 59
</code></pre>
<p>第一段 opcode 为 QUERY，表示执行查询操作，status 为 NOERROR，表示解析成功。<br>
第二段 QUESTION SECTION 部分显示了发起的 DNS 请求参数，A 表示我们默认查询 A 类型记录。<br>
第三段 ANSWER SECTION 部分为 DNS 查询结果，可以看到 thebyte.com.cn. 的解析结果为 110.40.229.45。<br>
最后一段为查询所用的DNS解析器、耗时等信息。</p>
<h2 id="4-http-请求优化">4. HTTP 请求优化</h2>
<ul>
<li>包体积优化：传输数据的包体大小与传输耗时成正相关，压缩算法是减小包体的最有效手段(没有之一)。</li>
<li>SSL 层优化：升级 TLS 算法以及 HTTPS 证书，降低 SSL 层的性能消耗。</li>
<li>传输层优化：升级拥塞控制算法（例如由默认的 Cubic 升级为 BBR 算法）提升数据传输效率。</li>
<li>网络层优化：使用一些商业网络加速服务，在网络层对数据包进行路由优化，实现动态服务加速。</li>
<li>使用更现代的 HTTP 协议：升级至 HTTP/2，进一步可以使用 QUIC。</li>
</ul>
<h3 id="41-对传输内容进行压缩">4.1 对传输内容进行压缩</h3>
<p>所有的现代浏览器、客户端及 HTTP 服务器软件都支持压缩技术，唯一需要协商的是客户端与服务端所采用的压缩算法。</p>
<p>为了选择采用的压缩算法，HTTP 客户端和服务器之间会使用主动协商机制：HTTP 客户端发送 Accept-Encoding 首部（其中包含它所支持的压缩算法，以及各自的优先级），服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知 HTTP 客户端它选择了哪一种算法。</p>
<h2 id="5-https-原理及-ssl-层优化实践">5. HTTPS 原理及 SSL 层优化实践</h2>
<p>HTTPS 是什么？简单理解就是 HTTP+SSL/TLS。</p>
<h3 id="51-理解-https-流程">5.1 理解 HTTPS 流程</h3>
<p>HTTP 添加 SSL 层的本质是为了实现信息传递“绝对”的安全性。</p>
<p>如图，如果是一个 1 v 1 的通信模型，想实现信息传递安全性，使用对称加密就可以。只要保证密钥不被第三者知道，信息传递的安全问题就能解决！</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1712731764166.png" alt="" loading="lazy"></figure>
<p>但是，对称加密方式在 HTTP 场景下就出现问题了。如图所示，对称加密的关键操作是如何保证秘钥的安全性，而 HTTP 通信模型是 1 v N，使用对称加密这种方式等同没有加密。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1712731768876.png" alt="" loading="lazy"></figure>
<p>为了解决秘钥暴露的问题，我们使每个客户端使用不同的算法/密钥，并再增加一个协商的过程，用于确定双方采用哪一种加密算法/密钥（这个协商的过程就是 TLS 协议做的事情）<br>
<img src="https://q456qq520.github.io/post-images/1712731829129.png" alt="" loading="lazy"></p>
<p>不过问题还是存在，协商过程解决了对称加密算法或秘钥独立性问题，但协商过程依旧是明文的，密钥依然存在被截获的可能性。</p>
<p>解决这个问题就必须换一种思路，只使用对称加密就会陷入“无限套娃”的死胡同。我们引入一个新的概念：非对称加密算法。</p>
<blockquote>
<p>非对称加密有两个密钥：公钥、私钥，私钥加密的密文只能公钥解，公钥加密的密文只能私钥解。</p>
</blockquote>
<p>由于对称加解密效率远比非对称加解密效率高得多，所以我们这样：</p>
<ol>
<li>对 HTTP 内容使用对称加密</li>
<li>协商流程中，通过一个随机数确定对称加密算法/密钥，然后使用非对称加密算法的私钥对其加密。</li>
<li>客户端先公钥解密获得对称加密的密钥，再用该密钥解密 HTTP 内容，从而获得明文。</li>
</ol>
<h5 id="证书认证机构">证书认证机构</h5>
<p>如果服务端直接发送公钥证书给客户端，仍然无法避免中间被截获的可能性。</p>
<p>此时，我们引入一个双方都信任的第三方机构，使用第三方机构的私钥将服务器公钥加密后传输给客户端，客户端再使用第三方公钥（内置在本地）进行解密。虽然流程绕了些，但至少离我们的目标”绝对“安全又近了些。</p>
<p>这个双方都信任的机构就是 HTTPS 中的 CA（CA，Certificate Authority，证书认证机构）。</p>
<p>HTTPS 中把公钥规范成数字证书的形式由 CA 签发（数字证书通常包含服务端公钥、持有者信息、CA 的信息以及过期信息等）。服务端向 CA 申请数字证书，再把数字证书下发给客户端。至于第三方 CA 公钥的问题，解决方案就是提前预装在系统内，这就是系统内根证书的由来。</p>
<p>总结 HTTPS 的通信逻辑如下：<br>
<img src="https://q456qq520.github.io/post-images/1712732068028.svg" alt="" loading="lazy"></p>
<ol>
<li>服务端向 CA 机构申请证书，</li>
<li>客户端请求服务端时，服务端向客户端下发证书</li>
<li>客户端根据本地根证书校验服务端的证书</li>
<li>客户端拿到证书的内公钥，加密之后传递服务端，服务端用本地的私钥进行解密获取正文。</li>
</ol>
<h3 id="52-ssl-层优化实践">5.2 SSL 层优化实践</h3>
<p>HTTPS 建立连接的过程中，TLS 握手阶段最长可以花费 2-RTT，除去握手延迟外，SSL 层还有其他的一些隐形消耗，不做任何优化措施情况下，网络耗时和加解密耗时影响会让 HTTPS 连接效率比 HTTP 慢上几百毫秒，在高延迟网络环境下，HTTPS 延迟问题更加明显。</p>
<h5 id="协议升级">协议升级</h5>
<p>优化 SSL 层，效果最为明显的方式是升级最新 TLS1.3 协议[1]。TLS 1.3 协议放弃了安全性较低的加密功能的支持，并改进了 TLS 握手流程。TLS 1.3 协议中的 TLS 握手只需要一次 RTT 而不是两次，如果客户端复用之前连接，TLS 握手的往返次数可以为零，这使 HTTPS 连接更快，能显著减少延迟并改善用户体验。如图所示，如果使用 TLS 1.2 需要两次往返（ 2-RTT ）才能完成握手，然后才能发送请求。</p>
<figure data-type="image" tabindex="5"><img src="https://q456qq520.github.io/post-images/1712732331870.png" alt="" loading="lazy"></figure>
<p>相比 TLS1.2 协议，TLS 1.3 协议的握手时间减半，如图所示。这意味着访问一个网站，使用 TLS 1.3 协议，会降低将近 100ms 的延时。</p>
<figure data-type="image" tabindex="6"><img src="https://q456qq520.github.io/post-images/1712732336578.png" alt="" loading="lazy"></figure>
<h5 id="证书优化">证书优化</h5>
<p>SSL 层中的证书验证也是一个比较耗时的环节：服务器需要把自己的证书链全发给客户端，客户端接收后再逐一验证。证书环节我们关注两个方面优化：<strong>证书传输优化</strong> 、** 证书中非对称算法升级 **。</p>
<p>客户端在验证证书过程中，需要判断当前证书状态，是否被撤销/过期等，需要再去访问 CA 下载 CRL 或者 OCSP 数据，这又会产生 DNS 查询、建立连接、收发数据等一系列网络通信，增加多个 RTT。</p>
<blockquote>
<p>TIP<br>
CRL（Certificate Revocation List）证书撤销列表，是由 CA 机构维护的一个列表，列表中包含已经被吊销的证书序列号和吊销时间。<br>
OCSP（Online Certificate Status Protocol）在线证书状态协议，是一种改进的证书状态确认方法，用于减轻证书吊销检查的负载和提高数据传输的私密性，相比于 CRL ，OCSP提供了实时验证证书状态的能力。<br>
OCSP Stapling 是 OCSP 的改进方案，将原本需要客户端实时发起的 OCSP 请求转嫁给服务端，服务端通过预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的环节，解决了 OCSP 的隐私和性能问题。</p>
</blockquote>
<ol>
<li>在 Nginx 中配置 OCSP Stapling 服务。</li>
</ol>
<pre><code class="language-Nginx">server {
    listen 443 ssl;
    server_name  thebyte.com.cn;
    index index.html;

    ssl_certificate         server.pem;#证书的.cer文件路径
    ssl_certificate_key     server-key.pem;#证书的.key文件

    # 开启 OCSP Stapling 当客户端访问时 NginX 将去指定的证书中查找 OCSP 服务的地址，获得响应内容后通过证书链下发给客户端。
    ssl_stapling on;
    ssl_stapling_verify on;# 启用OCSP响应验证，OCSP信息响应适用的证书
    ssl_trusted_certificate /path/to/xxx.pem;# 若 ssl_certificate 指令指定了完整的证书链，则 ssl_trusted_certificate 可省略。
    resolver 8.8.8.8 valid=60s;# 添加resolver解析OSCP响应服务器的主机名，valid表示缓存。
    resolver_timeout 2s;# resolver_timeout表示网络超时时间
}
</code></pre>
<ol start="2">
<li>检查服务端是否已开启 OCSP Stapling。</li>
</ol>
<pre><code class="language-yml">openssl s_client -connect thebyte.com.cn:443 -servername thebyte.com.cn -status -tlsextdebug &lt; /dev/null 2&gt;&amp;1 | grep &quot;OCSP&quot; 
</code></pre>
<p>若结果中存在”successful“，则表示已开启 OCSP Stapling 服务。</p>
<pre><code class="language-yml">OCSP response:
OCSP Response Data:
    OCSP Response Status: successful (0x0)
    Response Type: Basic OCSP Response
</code></pre>
<h5 id="证书算法优化">证书算法优化</h5>
<p>目前 SSL 密钥交换 + 签名有三种主流的方式：</p>
<ul>
<li>RSA 密钥交换（无需签名）。</li>
<li>ECDHE 密钥交换、RSA 签名。</li>
<li>ECDHE 密钥交换、ECDSA 签名。</li>
</ul>
]]></content>
    </entry>
</feed>