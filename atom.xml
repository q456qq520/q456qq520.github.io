<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKECAT</title>
    <updated>2025-05-14T03:42:36.425Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2025, LIKECAT</rights>
    <entry>
        <title type="html"><![CDATA[中台架构与实现：基于DDD和微服务]]></title>
        <id>https://q456qq520.github.io/post/zhong-tai-jia-gou-yu-shi-xian-ji-yu-ddd-he-wei-fu-wu/</id>
        <link href="https://q456qq520.github.io/post/zhong-tai-jia-gou-yu-shi-xian-ji-yu-ddd-he-wei-fu-wu/">
        </link>
        <updated>2025-05-13T05:26:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-传统架构的弊端">一、传统架构的弊端</h2>
<h3 id="11-弊端">1.1 弊端</h3>
<ol>
<li>单体架构的问题<br>
集中式单体应用往往会将多个功能放到一个应用中，经过日积月累，这个应用就会变成一个庞大而复杂的“怪物”。随着项目团队成员的更替，时间一长就很少有人能完全搞懂这些代码之间的逻辑关系了。这样会导致应用越来越庞大，越来越复杂，可读性越来越差，最终陷入恶性循环。</li>
</ol>
<p>单体应用还存在诸多问题。由于单体应用的各个模块之间耦合度高，很可能因为一个局部的小Bug，而导致整个单体应用不可用。另外，单体应用部署包过于庞大，难以上云实现资源的弹性扩缩，导致应用扩展能力差且资源利用率不高。</p>
<ol start="2">
<li>
<p>研发运维能力滞后<br>
传统开发模式的弊端在于开发和测试周期耗时长，交付质量和周期难以保证，不能实现持续快速交付，对业务需求和市场的响应能力相对较慢，难以实施敏捷开发。</p>
</li>
<li>
<p>IT能力重复建设的问题</p>
</li>
</ol>
<h3 id="12-akf可扩展能力立方体模型">1.2 AKF可扩展能力立方体模型</h3>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1747117099666.png" alt="" loading="lazy"></figure>
<p>Y轴关注应用的业务职责划分，如根据数据类型、交易类型或根据两者组合来划分业务和应用边界，在划分过程中会遵循单一职责原则。Y轴主要用于划分业务和应用边界，解决业务能力复用的问题。</p>
<p>Y轴的典型实践案例是从单体向微服务的演进。这个过程会有业务和应用边界拆分的问题。但是在单体拆分为微服务时经常会有人问：单体到底应该如何拆分为微服务？是否有成熟的方法来完成应用和业务边界的划分呢？</p>
<p><code>DDD（Domain Driven Design，领域驱动设计）</code>方法就是一种行之有效的划分业务领域边界的方法，以帮助完成应用的拆分和微服务的设计。它会按照流程或功能边界分解业务领域，根据业务上下文边界，构建领域模型，并将其作为微服务设计的输入。</p>
<h2 id="二-何为中台">二、何为中台</h2>
<h2 id=""></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高可用架构和系统设计]]></title>
        <id>https://q456qq520.github.io/post/gao-ke-yong-jia-gou-he-xi-tong-she-ji/</id>
        <link href="https://q456qq520.github.io/post/gao-ke-yong-jia-gou-he-xi-tong-she-ji/">
        </link>
        <updated>2025-05-13T04:16:04.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[异步线程异常如何捕捉]]></title>
        <id>https://q456qq520.github.io/post/yi-bu-xian-cheng-yi-chang-ru-he-bu-zhuo/</id>
        <link href="https://q456qq520.github.io/post/yi-bu-xian-cheng-yi-chang-ru-he-bu-zhuo/">
        </link>
        <updated>2025-05-13T03:54:06.000Z</updated>
        <content type="html"><![CDATA[<p>Java的异常在线程之间不是共享的，在线程中抛出的异常是线程自己的异常，主线程并不能捕获到。也就是说你把线程执行的代码看成另一个主函数。</p>
<h2 id="一-单独线程的异常捕捉">一、单独线程的异常捕捉</h2>
<p>在Thread中，Java提供了一个<code>setUncaughtExceptionHandler</code>的方法来设置线程的异常处理函数，你可以把异常处理函数传进去，当发生线程的未捕获异常的时候，由JVM来回调执行。</p>
<pre><code class="language-java">//写个异常，int肯定格式化转换失败抛 java.lang.NumberFormatException:异常
public class ThreadExceptionRun implements Runnable {


    @Override
    public void run() {
        int i = Integer.parseInt(&quot;uncaughtException&quot;);
        System.out.println(i);
    }
}

//写个异常处理器，实现Thread.UncaughtExceptionHandler重写uncaughtException方法
public class ThreadException implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println(&quot;处理异常信息&quot;);
    }
}

3.使用

public class ThreadExceptionMain {
    public static void main(String[] args) {
        Thread thread  = new Thread(new ThreadExceptionRun());
        thread.setUncaughtExceptionHandler(new ThreadException());
        thread.start();
    }
}
</code></pre>
<h2 id="二-线程池异步线程异常捕捉">二、线程池异步线程异常捕捉</h2>
<h3 id="21-run方法里面trycatch所有处理逻辑">2.1 run方法里面try/catch所有处理逻辑</h3>
<pre><code class="language-java">public class ThreadPoolException {
    public static void main(String[] args) {
        
        //创建一个线程池
        ExecutorService executorService = Executors.newFixedThreadPool(1);

        //当线程池抛出异常后 submit无提示，其他线程继续执行
        executorService.submit(new task());

        //当线程池抛出异常后 execute抛出异常，其他线程继续执行新任务
        executorService.execute(new task());
    }
}
// 任务类
class task implements Runnable {
    @Override
    public void run() {
        try {
            System.out.println(&quot;进入了task方法！！！&quot;);
            int i = 1 / 0;
        } catch (Exception e) {
            System.out.println(&quot;使用了try -catch 捕获异常&quot; + e);
        }
    }
}

</code></pre>
<h3 id="22-重写threadpoolexecutorafterexecute方法">2.2 重写ThreadPoolExecutor.afterExecute方法</h3>
<pre><code class="language-java">public class ThreadPoolException3 {
    public static void main(String[] args) throws InterruptedException, ExecutionException {


        //1.创建一个自己定义的线程池
        ExecutorService executorService = new ThreadPoolExecutor(
                2,
                3,
                0,
                TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue(10)
        ) {
            //重写afterExecute方法
            @Override
            protected void afterExecute(Runnable r, Throwable t) {
                System.out.println(&quot;afterExecute里面获取到异常信息，处理异常&quot; + t.getMessage());
            }
        };
        
        //当线程池抛出异常后 execute
        executorService.execute(new task());
    }
}

class task3 implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;进入了task方法！！！&quot;);
        int i = 1 / 0;
    }
}
</code></pre>
<p>如果要用这个afterExecute处理submit提交的异常， 要额外处理。判断Throwable是否是FutureTask，如果是代表是submit提交的异常，代码如下：</p>
<pre><code class="language-java">public class ThreadPoolException3 {
    public static void main(String[] args) throws InterruptedException, ExecutionException {


        //1.创建一个自己定义的线程池
        ExecutorService executorService = new ThreadPoolExecutor(
                2,
                3,
                0,
                TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue(10)
        ) {
            //重写afterExecute方法
            @Override
            protected void afterExecute(Runnable r, Throwable t) {
                //这个是excute提交的时候
                if (t != null) {
                    System.out.println(&quot;afterExecute里面获取到excute提交的异常信息，处理异常&quot; + t.getMessage());
                }
                //如果r的实际类型是FutureTask 那么是submit提交的，所以可以在里面get到异常
                if (r instanceof FutureTask) {
                    try {
                        Future&lt;?&gt; future = (Future&lt;?&gt;) r;
                        //get获取异常
                        future.get();

                    } catch (Exception e) {
                        System.out.println(&quot;afterExecute里面获取到submit提交的异常信息，处理异常&quot; + e);
                    }
                }
            }
        };
        //当线程池抛出异常后 execute
        executorService.execute(new task());
        
        //当线程池抛出异常后 submit
        executorService.submit(new task());
    }
}

class task3 implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;进入了task方法！！！&quot;);
        int i = 1 / 0;
    }
}
</code></pre>
<h3 id="23-使用submit执行任务">2.3 使用submit执行任务</h3>
<p>我们知道在使用submit执行任务，该方法将返回一个Future对象，不仅仅是任务的执行结果，异常也会被封装到Future对象中，通过get()方法获取。</p>
<p>execute方法被线程工厂factory中设置的 UncaughtExceptionHandler捕捉到异常，而submit方法却没有任何反应！说明UncaughtExceptionHandler在submit中并没有被调用。这是为什么呢？</p>
<p>在日常使用中，我们知道，execute和submit最大的区别就是execute没有返回值，submit有返回值。submit返回的是一个future ，可以通过这个future取到线程执行的结果或者异常信息。</p>
<p>submit源码在底层还是调用的execute方法，只不过多一层Future封装，并返回了这个Future，这也解释了为什么submit会有返回值</p>
<pre><code class="language-java">//submit()方法
 public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
     if (task == null) throw new NullPointerException();
     
     //execute内部执行这个对象内部的逻辑，然后将结果或者异常 set到这个ftask里面
     RunnableFuture&lt;T&gt; ftask = newTaskFor(task); 
     // 执行execute方法
     execute(ftask); 
     //返回这个ftask
     return ftask;
 }
</code></pre>
<p>可以看到submit也是调用的execute，在execute方法中，我们的任务被提交到了addWorker(command, true) ，然后为每一个任务创建一个Worker去处理这个线程，这个Worker也是一个线程，执行任务时调用的就是Worker的run方法！run方法内部又调用了runworker方法！如下所示：</p>
<pre><code class="language-java">public void run() {
        runWorker(this);
 }
     
final void runWorker(Worker w) {
     Thread wt = Thread.currentThread();
     Runnable task = w.firstTask;
     w.firstTask = null;
     w.unlock(); // allow interrupts
     boolean completedAbruptly = true;
     try {
      //这里就是线程可以重用的原因，循环+条件判断，不断从队列中取任务        
      //还有一个问题就是非核心线程的超时删除是怎么解决的
      //主要就是getTask方法()见下文③
         while (task != null || (task = getTask()) != null) {
             w.lock();
             if ((runStateAtLeast(ctl.get(), STOP) ||
                  (Thread.interrupted() &amp;&amp;
                   runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                 !wt.isInterrupted())
                 wt.interrupt();
             try {
                 beforeExecute(wt, task);
                 Throwable thrown = null;
                 try {
                  //执行线程
                     task.run();
                     //异常处理
                 } catch (RuntimeException x) {
                     thrown = x; throw x;
                 } catch (Error x) {
                     thrown = x; throw x;
                 } catch (Throwable x) {
                     thrown = x; throw new Error(x);
                 } finally {
                  //execute的方式可以重写此方法处理异常
                     afterExecute(task, thrown);
                 }
             } finally {
                 task = null;
                 w.completedTasks++;
                 w.unlock();
             }
         }
         //出现异常时completedAbruptly不会被修改为false
         completedAbruptly = false;
     } finally {
      //如果如果completedAbruptly值为true，则出现异常，则添加新的Worker处理后边的线程
         processWorkerExit(w, completedAbruptly);
     }
 }
</code></pre>
<p>核心就在 <code>task.run()</code>; 这个方法里面了， 期间如果发生异常会被抛出。</p>
<ol>
<li>如果用execute提交的任务，会被封装成了一个runable任务，然后进去 再被封装成一个worker,最后在worker的run方法里面调用runWoker方法， runWoker方法里面执行任务任务，如果任务出现异常，用try-catch捕获异常往外面抛，我们在最外层使用try-catch捕获到了 runWoker方法中抛出的异常。因此我们在execute中看到了我们的任务的异常信息。</li>
<li>那么为什么submit没有异常信息呢？ 因为submit是将任务封装成了一个futureTask ，然后这个futureTask被封装成worker，在woker的run方法里面，最终调用的是futureTask的run方法， 猜测里面是直接吞掉了异常，并没有抛出异常，因此在worker的runWorker方法里面无法捕获到异常。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dubbo常见面试题及答案]]></title>
        <id>https://q456qq520.github.io/post/dubbo-chang-jian-mian-shi-ti-ji-da-an/</id>
        <link href="https://q456qq520.github.io/post/dubbo-chang-jian-mian-shi-ti-ji-da-an/">
        </link>
        <updated>2025-05-12T09:09:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dubbo是什么rpc又是什么">Dubbo是什么？RPC又是什么？</h2>
<p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p>
<p><strong>RPC</strong><br>
RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底&gt;层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。<br>
RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p>
<blockquote>
<p>远程调用就是本地机器调用远程机器的一个方法，远程机器返回结果的过程。</p>
</blockquote>
<h2 id="dubbo能做什么">Dubbo能做什么？</h2>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1747041696454.png" alt="" loading="lazy"></figure>
<ul>
<li>远程通讯:dubbo-remoting模块， 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li>
<li>集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>
<li>自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>
</ul>
<h2 id="能说下dubbo的总体的调用过程吗">能说下Dubbo的总体的调用过程吗？</h2>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1747041789865.png" alt="" loading="lazy"></figure>
<ol>
<li>Proxy持有一个Invoker对象，使用Invoker调用</li>
<li>之后通过Cluster进行负载容错，失败重试</li>
<li>调用Directory获取远程服务的Invoker列表</li>
<li>负载均衡<br>
用户配置了路由规则，则根据路由规则过滤获取到的Invoker列表<br>
用户没有配置路由规则或配置路由后还有很多节点，则使用LoadBalance方法做负载均衡，选用一个可以调用的Invoker</li>
<li>经过一个一个过滤器链，通常是处理上下文、限流、计数等。</li>
<li>会使用Client做数据传输</li>
<li>私有化协议的构造(Codec)</li>
<li>进行序列化</li>
<li>服务端收到这个Request请求，将其分配到ThreadPool中进行处理</li>
<li>Server来处理这些Request</li>
<li>根据请求查找对应的Exporter</li>
<li>之后经过一个服务提供者端的过滤器链</li>
<li>然后找到接口实现并真正的调用，将请求结果返回</li>
</ol>
<h2 id="说说dubbo-支持哪些协议每种协议的应用场景和优缺点">说说Dubbo 支持哪些协议，每种协议的应用场景和优缺点</h2>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1747042084875.png" alt="" loading="lazy"></figure>
<ol>
<li>dubbo 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化</li>
<li>http 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实 现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用</li>
<li>webservice 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。</li>
</ol>
<h2 id="dubbo中都用到哪些设计模式">Dubbo中都用到哪些设计模式？</h2>
<ol>
<li>
<p>责任链模式:<br>
责任链模式在Dubbo中发挥的作用举足轻重，就像是Dubbo框架的骨架。Dubbo的调用链组织是用责任链模式串连起来的。责任链中的每个节点实现Filter接口，然后由ProtocolFilterWrapper，将所有Filter串连起来。Dubbo的许多功能都是通过Filter扩展实现的，比如监控、日志、缓存、安全、telnet以及RPC本身都是。</p>
</li>
<li>
<p>观察者模式:<br>
Dubbo中使用观察者模式最典型的例子是RegistryService。消费者在初始化的时候回调用subscribe方法，注册一个观察者，如果观察者引用的服务地址列表发生改变，就会通过NotifyListener通知消费者。此外，Dubbo的InvokerListener、ExporterListener 也实现了观察者模式，只要实现该接口，并注册，就可以接收到consumer端调用refer和provider端调用export的通知。</p>
</li>
<li>
<p>修饰器模式:<br>
Dubbo中还大量用到了修饰器模式。比如ProtocolFilterWrapper类是对Protocol类的修饰。在export和refer方法中，配合责任链模式，把Filter组装成责任链，实现对Protocol功能的修饰。其他还有ProtocolListenerWrapper、 ListenerInvokerWrapper、InvokerWrapper等。</p>
</li>
<li>
<p>工厂方法模式:<br>
CacheFactory的实现采用的是工厂方法模式。CacheFactory接口定义getCache方法，然后定义一个AbstractCacheFactory抽象类实现CacheFactory，并将实际创建cache的createCache方法分离出来，并设置为抽象方法。这样具体cache的创建工作就留给具体的子类去完成。</p>
</li>
<li>
<p>抽象工厂模式:<br>
ProxyFactory及其子类是Dubbo中使用抽象工厂模式的典型例子。ProxyFactory提供两个方法，分别用来生产Proxy和Invoker（这两个方法签名看起来有些矛盾，因为getProxy方法需要传入一个Invoker对象，而getInvoker方法需要传入一个Proxy对象，看起来会形成循环依赖，但其实两个方式使用的场景不一样）。AbstractProxyFactory实现了ProxyFactory接口，作为具体实现类的抽象父类。然后定义了JdkProxyFactory和JavassistProxyFactory两个具体类，分别用来生产基于jdk代理机制和基于javassist代理机制的Proxy和Invoker。</p>
</li>
<li>
<p>适配器模式:<br>
为了让用户根据自己的需求选择日志组件，Dubbo自定义了自己的Logger接口，并为常见的日志组件（包括jcl, jdk, log4j, slf4j）提供相应的适配器。并且利用简单工厂模式提供一个LoggerFactory，客户可以创建抽象的Dubbo自定义Logger，而无需关心实际使用的日志组件类型。在LoggerFactory初始化时，客户通过设置系统变量的方式选择自己所用的日志组件，这样提供了很大的灵活性。</p>
</li>
<li>
<p>代理模式:<br>
Dubbo consumer使用Proxy类创建远程服务的本地代理，本地代理实现和远程服务一样的接口，并且屏蔽了网络通信的细节，使得用户在使用本地代理的时候，感觉和使用本地服务一样。</p>
</li>
</ol>
<h2 id="服务暴露的流程是怎么样的">服务暴露的流程是怎么样的？</h2>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1747042302593.png" alt="" loading="lazy"></figure>
<ol>
<li>通过ServiceConfig解析标签，创建dubbo标签解析器来解析dubbo的标签，容器创建完成之后，触发ContextRefreshEvent事件回调开始暴露服务</li>
<li>通过proxyFactory.getInvoker方法，并利用javassist或DdkProxyFactory来进行动态代理，将服务暴露接口封装成invoker对象，里面包含了需要执行的方法的对象信息和具体的URL地址。</li>
<li>再通过DubboProtocol的实现把包装后的invoker转换成exporter，</li>
<li>然后启动服务器server，监听端口</li>
<li>最后RegistryProtocol保存URL地址和invoker的映射关系，同时注册到服务中心</li>
</ol>
<h2 id="服务引用的流程是怎么样的">服务引用的流程是怎么样的？</h2>
<ol>
<li>首先客户端根据config文件信息从注册中心订阅服务，首次会全量缓存到本地，后续的更新会监听动态更新到本地。</li>
<li>之后DubboProtocol根据provider的地址和接口信息连接到服务端server，开启客户端client，然后创建invoker</li>
<li>之后通过invoker为服务接口生成代理对象，这个代理对象用于远程调用provider，至此完成了服务引用</li>
</ol>
<h2 id="dubbo的注册中心有哪些">Dubbo的注册中心有哪些？</h2>
<p>Zookeeper、Redis、Multicast、Simple 等都可以作为Dubbo的注册中心</p>
<h2 id="聊聊dubbo-spi机制">聊聊Dubbo SPI机制？</h2>
<p><code>SPI(Service Provider Interface)，是一种服务发现机制</code>，其实就是将结构的实现类写入配置当中，在服务加载的时候将配置文件独处，加载实现类，这样就可以在运行的时候，动态的帮助接口替换实现类。</p>
<p>Dubbo的SPI其实是对java的SPI进行了一种增强,可以按需加载实现类之外，增加了 IOC 和 AOP 的特性，还有自适应扩展机制。</p>
<p>SPI在dubbo应用很多，包括协议扩展、集群扩展、路由扩展、序列化扩展等等。</p>
<p>Dubbo对于文件目录的配置分为了三类。</p>
<ol>
<li>META-INF/services/ 目录：该目录下的 SPI 配置文件是为了用来兼容 Java SPI 。</li>
<li>META-INF/dubbo/ 目录：该目录存放用户自定义的 SPI 配置文件。</li>
<li>META-INF/dubbo/internal/ 目录：该目录存放 Dubbo 内部使用的 SPI 配置文件。</li>
</ol>
<h2 id="有哪些负载均衡策略">有哪些负载均衡策略？</h2>
<ol>
<li>加权随机：比如我们有三台服务器[A, B, C]，给他们设置权重为[4, 5, 6]，然后讲这三个数平铺在水平线上,和为15。然后在15以内生成一个随机数，0～4是服务器A，4～9是服务器B，9～15是服务器C</li>
<li>最小活跃数：每个服务提供者对应一个活跃数 active，初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求。</li>
<li>一致性hash：首先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上。</li>
<li>加权轮询：比如我们有三台服务器[A, B, C]，给他们设置权重为[4, 5, 6]，那么假如总共有15次请求，那么会有4次落在A服务器，5次落在B服务器，6次落在C服务器。</li>
</ol>
<h2 id="集群容错方式有哪些">集群容错方式有哪些？</h2>
<ol>
<li>
<p>Failover Cluster失败自动切换：dubbo的默认容错方案，当调用失败时自动切换到其他可用的节点，具体的重试次数和间隔时间可用通过引用服务的时候配置，默认重试次数为1是只调用一次。</p>
</li>
<li>
<p>Failback Cluster失败自动恢复：在调用失败，记录日志和调用信息，然后返回空结果给consumer，并且通过定时任务每隔5秒对失败的调用进行重试</p>
</li>
<li>
<p>Failfast Cluster快速失败：只会调用一次，失败后立刻抛出异常</p>
</li>
<li>
<p>Failsafe Cluster失败安全：调用出现异常，记录日志不抛出，返回空结果</p>
</li>
<li>
<p>Forking Cluster并行调用多个服务提供者：通过线程池创建多个线程，并发调用多个provider，结果保存到阻塞队列，只要有一个provider成功返回了结果，就会立刻返回结果</p>
</li>
<li>
<p>Broadcast Cluster广播模式：逐个调用每个provider，如果其中一台报错，在循环调用结束后，抛出异常。</p>
</li>
</ol>
<h2 id="dubbo的分层">Dubbo的分层？</h2>
<ul>
<li><code>business</code>业务逻辑层由我们自己来提供接口和实现还有一些配置信息</li>
<li><code>RPC层</code>就是真正的RPC调用的核心层，封装整个RPC的调用过程、负载均衡、集群容错、代理</li>
<li><code>remoting</code>则是对网络传输协议和数据转换的封装。</li>
</ul>
<h2 id="服务提供者能实现失效踢出是什么原理">服务提供者能实现失效踢出是什么原理？</h2>
<p>服务失效踢出基于Zookeeper的临时节点原理。</p>
<p>Zookeeper中节点是有生命周期的，具体的生命周期取决于节点的类型，节点主要分为持久节点(Persistent)和临时节点(Ephemeral) 。</p>
<h2 id="为什么要通过代理对象通信">为什么要通过代理对象通信？</h2>
<p>其实主要就是为了将调用细节封装起来，将调用远程方法变得和调用本地方法一样简单，还可以做一些其他方面的增强，比如负载均衡，容错机制，过滤操作，调用数据的统计。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSO 和 OAuth2.0 ]]></title>
        <id>https://q456qq520.github.io/post/sso-he-oauth20/</id>
        <link href="https://q456qq520.github.io/post/sso-he-oauth20/">
        </link>
        <updated>2025-05-12T03:33:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-简介">一、简介</h2>
<ul>
<li>
<p>SSO：单点登录。SSO用于在一处系统中登录， 切换到其他系统时，不必再次输入用户名密码。</p>
</li>
<li>
<p>OAuth2.0：开放授权。 OAuth 2.0授权框架允许第三方应用程序通过协调资源所有者和HTTP服务之间的审批交互，或允许第三方应用程序自己获得访问权限，从而获得对HTTP服务的有限访问。也就是授权别人(client)访问我们的资源。</p>
</li>
</ul>
<p>区别：SSO和OAuth2.0在应用场景上的区别在于，SSO是为了解决一个用户在鉴权服务器登陆过一次以后，可以在任何应用（通常是一个厂家的各个系统）中畅通无阻。OAuth2.0解决的是通过令牌（token）而不是密码获取某个系统的操作权限（不同厂家之间的账号共享）。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>SSO</th>
<th>OAuth2.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>含义</td>
<td>Single Sign On，单点登录</td>
<td>OAuth 的 2.0 版本</td>
</tr>
<tr>
<td>本质</td>
<td>一种思想 / 解决方案，抽象的</td>
<td>一种协议，具体的</td>
</tr>
<tr>
<td>应用场景</td>
<td>一次鉴权，畅通多个应用</td>
<td>发放令牌，授予操作权限</td>
</tr>
<tr>
<td>在业务系统中存储账密</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>验证用户身份的方式</td>
<td>session、cookie、token</td>
<td>token</td>
</tr>
<tr>
<td>互相信任的应用群</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>资源提供方</td>
<td>客户端+用户</td>
<td>用户</td>
</tr>
</tbody>
</table>
<h2 id="二-sso">二、SSO</h2>
<p>SSO实现的最关键是，在传统的多应用切换中，面临着cookie 跨域和session共享的问题，解决这两个问题是实现SSO(CAS)的关键。</p>
<p>下面介绍了一种单点登录的方式CAS(中央认证服务Central Authentication Service)</p>
<h3 id="21-cas">2.1 CAS</h3>
<ol>
<li>CAS是对用户的账号和密码进行保存，同时也记录着用户与资源关系（是否可以访问资源）。</li>
<li>各个业务系统获得的信息是，这个用户能不能访问我的资源。资源都在各个业务那边。</li>
<li>用户登陆成功后会获得Ticket，CAS给业务系统一个Ticket，业务系统是不能确定这个Ticket是否是用户伪造的，还是真的有效，所以要拿着这个Ticket去CAS服务器再问一下，这个用户给我的Token是否有效，以及会询问当前用户在我系统中的权限是什么样子的。</li>
</ol>
<h3 id="22-cas实现流程">2.2 CAS实现流程</h3>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1747021394744.webp" alt="" loading="lazy"></figure>
<p>上图具体流程如下：</p>
<ol>
<li>用户访问APP1系统，APP1系统是需要登录的，但用户现在没有登录。</li>
<li>跳转到CAS server，即SSO登录系统。SSO系统也没有登录，弹出用户登录页。</li>
<li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的Session，浏览器（Browser）中写入SSO域下的Cookie。【此处的Cookie可以确保不用重复登陆SSO系统】</li>
<li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到APP1系统，同时将ST作为参数传递给APP1系统。</li>
<li>APP1系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li>
<li>验证通过后，APP1系统将登录状态写入Session并设置APP1域下的Cookie。【仅仅是在APP1域下的Cookie】</li>
</ol>
<p>至此，跨域单点登录就完成了。以后我们再访问APP1系统时，用户状态就已经有了。接下来，我们再看看访问APP2系统时的流程。</p>
<ol>
<li>用户访问APP2系统，app2系统没有登录，跳转到SSO。</li>
<li>由于SSO已经登录了，不需要重新登录认证。【在APP1登陆成功后写入的Cookie】</li>
<li>SSO生成ST，浏览器跳转到APP2系统，并将ST作为参数传递给APP2。</li>
<li>APP2拿到ST，后台访问SSO，验证ST是否有效。</li>
<li>验证成功后，app2将登录状态写入Session，并在app2域下写入Cookie。</li>
</ol>
<p>这样，APP2系统不需要走登录流程，就已经是登录了。SSO，APP1和APP2在不同的域下，它们之间的Session不应该是的共享的，这样可以更加保证用户信息安全。</p>
<h2 id="三-oauth2">三、OAuth2</h2>
<p>OAuth 2.0授权框架支持第三方支持访问有限的HTTP服务，通过在资源所有者和HTTP服务之间进行一个批准交互来代表资源者去访问这些资源，或者通过允许第三方应用程序以自己的名义获取访问权限。</p>
<p>对应资源解释：</p>
<ol>
<li>资源所有者（Resource Owner）：很多时候就是我们普通人（但不限于普通人，如某些应用程序也会创建资源），拥有资源的所有权。</li>
<li>资源服务器（Resource Server）：保存着受保护的用户资源。（微信个人信息服务器）</li>
<li>应用程序（Client）：准备访问用户资源的应用程序，其可能是一个web应用，或是一个后端web服务应用，或是一个移动端应用，也或是一个桌面可执行程序。（第三方应用）</li>
<li>授权服务器（Authorization Server）：授权服务器，在获取用户的同意授权后，颁发访问令牌给应用程序，以便其获取用户资源。（微信授权服务器）</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1747022741690.webp" alt="" loading="lazy"></figure>
<h3 id="31-授权码模式">3.1 授权码模式</h3>
<ol>
<li>用户在第三方应用程序中，应用程序尝试获取用户保存在 微信资源服务器上 的信息，比如用户的身份信息和头像，应用程序首先让重定向用户到授权服务器，告知申请资源的读权限，并提供自己的client id。</li>
<li>到授权服务器，用户输入用户名和密码，服务器对其认证成功后，提示用户即将要颁发一个读权限给应用程序，在用户确认后，授权服务器颁发一个授权码（authorization code）并重定向用户回到应用程序。</li>
<li>应用程序获取到授权码之后，使用这个授权码和自己的Client id/Secret向认证服务器 申请访问令牌/刷新令牌（access token/refresh token）。授权服务器对这些信息进行校验，如果一切OK，则颁发给应用程序。</li>
<li>应用程序在拿到访问令牌之后，向资源服务器申请用户的资源信息</li>
<li>资源服务器在获取到访问令牌后，对令牌进行解析（如果令牌已加密，则需要进行使用相应算法进行解密）并校验，并向授权服务器校验其合法性，如果一起OK，则返回应用程序所需要的资源信息。</li>
</ol>
<p>注意的是，访问令牌对于应用程序来说是透明的，应用程序无需关注访问令牌所带的任何信息，只需在访问资源服务器时带上它。但是资源服务器需要知道访问令牌的组成和加密方式，资源服务器需要解析或解密这个访问令牌，查看并校验里面的信息。</p>
<h3 id="32-简化模式">3.2 简化模式</h3>
<p>这种场景经常运用应用程序没有服务端的情况。 应用程序运行在客户端，一个最大的变化就是其变成了公开应用程序（Public Client），应用程序的运行完全暴露在用户的控制之中。在这种场景下，应用程序是无法隐藏自己的一些敏感数据，比如client secret和授权码，在这个方式下，再向授权服务器获取授权码是多此一举。</p>
<p>为此OAuth 2.0提供简化模式，授权服务器在校验好用户信息后，直接颁发给应用程序访问资源服务器的访问令牌。换句话说，<code>应用程序在获取访问令牌时无需提供授权码和client secret</code>。</p>
<p>整个授权流程如下，</p>
<ol>
<li>用户在应用程序中，应用程序尝试获取用户保存在资源服务器上的信息，比如用户的身份信息和头像，应用程序首先让用户重定向到授权服务器，告知申请资源的读权限，并提供自己的client id。在重定向的过程中，应用程序指定使用Implicit Grant授权方式。</li>
<li>在授权服务器，用户输入用户名和密码，服务器对其认证成功后，提示用户即将要颁发一个读权限给应用程序，在用户确认后，授权服务器直接颁发一个访问令牌并重定向用户回到应用程序。</li>
<li>应用程序在拿到访问令牌之后，向资源服务器申请用户的资源信息</li>
<li>资源服务器在获取到访问令牌后，对令牌进行解析（如果令牌已加密，则需要进行使用相应算法进行解密）并校验，并向授权服务器校验其合法性，如果一起OK，则返回应用程序所需要的资源信息。</li>
</ol>
<p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p>
<h3 id="33-应用授信">3.3 应用授信</h3>
<p>这种授信模式特点是：应用程序角色本身就是资源所有者 （应用程序和资源服务器之间是完全可信的）</p>
<p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p>
<ol>
<li>应用程序尝试获取在资源服务器上的信息，应用程序直接向授权服务器申请访问令牌，告知申请资源的读权限，并提供自己的授信凭证（client id/secret）。在申请请求中，应用程序指定使用client credentials授权方式。在授权服务器，服务器对其client credentials校验成功后，授权服务器直接颁发一个访问令牌给应用程序。</li>
<li>应用程序在拿到访问令牌之后，向资源服务器申请用户的资源信息。</li>
<li>资源服务器在获取到访问令牌后，对令牌进行解析（如果令牌已加密，则需要进行使用相应算法进行解密）并校验，并向授权服务器校验其合法性，如果一起OK，则返回应用程序所需要的资源信息。</li>
</ol>
<p>这个授权流程被称为应用授信模式，其命名原因是由于应用程序是通过自己的授信凭证（client id/secret）直接向授权服务器申请访问令牌。这种模式一般用在可信的应用程序。</p>
<h3 id="34-用户授信模式">3.4 用户授信模式</h3>
<p>在基本的授权码模式中，用户需要跳转到授权服务器上，使用用户名和密码登录后拿到授权码，然后把授权码交给应用程序，然后再去申请访问令牌。</p>
<p>用户授信模式流程如下，</p>
<ol>
<li>用户在应用程序中，应用程序首先让用户到登录页面输入用户名和密码。</li>
<li>应用程序拿到资源所有者的用户名和密码，加上自己的client id/secret一同向认证服务器申请访问令牌/刷新令牌。授权服务器对这些信息进行校验，如果通过，则颁发给应用程序访问令牌/刷新令牌。</li>
<li>应用程序在拿到访问令牌/刷新令牌之后，向资源服务器申请用户的资源信息。</li>
<li>资源服务器在获取到访问令牌后，对令牌进行解析（如果令牌已加密，则需要进行使用相应算法进行解密）并校验，并向授权服务器校验其合法性，如果一起OK，则返回应用程序所需要的资源信息。</li>
</ol>
<h3 id="35-四种授权模式的联系和区别">3.5 四种授权模式的联系和区别</h3>
<p>各个模式获取访问令牌的手段:</p>
<ul>
<li>授权码模式：授权码+应用的授信凭据</li>
<li>简化模式：应用client id + 用户的授信凭据</li>
<li>应用授信模式：应用的授信凭据</li>
<li>用户授信模式：应用的授信凭据+用户的授信凭据</li>
</ul>
<p>这四种授权模式中，授权码模式是基本的授权模式。</p>
<ol>
<li>授权码模式：基本授权模式，它需要有四个角色同时在场才能完成授权：资源所有者、应用程序、授权服务器、资源服务器。</li>
<li>简化模式：开放应用程序，应用程序运行在公开开放的环境。即：无需应用程序的认证。</li>
<li>应用授信模式：应用程序即为资源所有者，或资源所有者不参与授权交互。即：无资源所有者的认证。</li>
<li>用户授信模式：无授权码的颁发过程，直接通过用户名和密码换取授权。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解析Jdk与Cglib代理]]></title>
        <id>https://q456qq520.github.io/post/jie-xi-jdk-yu-cglib-dai-li/</id>
        <link href="https://q456qq520.github.io/post/jie-xi-jdk-yu-cglib-dai-li/">
        </link>
        <updated>2025-05-11T05:45:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-jdk动态代理">一、JDK动态代理</h1>
<h2 id="11-jdk动态代理简介">1.1 JDK动态代理简介</h2>
<p>JDK动态代理是Java语言提供的一种实现动态代理的方式，其基本原理是利用反射机制在运行时动态生成代理类和代理对象。</p>
<h3 id="111-基本原理">1.1.1 基本原理</h3>
<ol>
<li>接口定义：定义一个接口（或者是一组接口），用于描述需要被代理的行为。</li>
<li>InvocationHandler接口：编写一个实现了<code>InvocationHandle</code>r接口的类，该类负责实际的代理逻辑。InvocationHandler接口只有一个方法<code>invoke(Object proxy, Method method, Object[] args)</code>，当代理对象的方法被调用时，invoke方法会被调用，并在其中执行代理逻辑。</li>
<li>Proxy类：使用<code>Proxy</code>类的<code>newProxyInstance</code>方法动态地创建代理对象。newProxyInstance方法接受三个参数：ClassLoader、一个接口数组和一个InvocationHandler对象。在运行时，Proxy类会动态生成一个实现了指定接口的代理类，并通过传入的InvocationHandler对象来调用实际的代理逻辑。</li>
<li>代理对象调用：当调用代理对象的方法时，实际上是调用了InvocationHandler接口的invoke方法，该方法会根据被调用的方法和传入的参数执行相应的代理逻辑。</li>
</ol>
<h3 id="112-使用场景">1.1.2 使用场景</h3>
<p>日志记录：通过代理可以在方法执行前后记录日志，实现日志记录的功能。<br>
性能监控：可以在方法执行前后记录方法的执行时间，从而进行性能监控。<br>
事务管理：在方法执行前后开启和提交事务，实现事务管理的功能。<br>
权限控制：在方法执行前进行权限验证，实现权限控制的功能。<br>
远程调用：可以通过代理在调用远程对象的方法时添加网络通信的逻辑，实现远程调用的功能。</p>
<h2 id="12-spring-如何利用动态代理实现-aop">1.2 Spring 如何利用动态代理实现 AOP</h2>
<p>Spring AOP的实现基于<code>代理模式</code>和<code>装饰器模式</code>，在目标方法执行前后或异常抛出时，通过代理对象来执行额外的逻辑，如日志记录、事务管理、权限控制等。通过配置<code>切面</code>和<code>通知</code>，可以将这些额外逻辑统一地应用到多个目标类的方法中，从而实现横切关注点的分离和复用。</p>
<p>在Spring AOP中，主要利用了JDK动态代理和CGLIB动态代理两种方式。</p>
<ol>
<li>JDK动态代理：</li>
</ol>
<ul>
<li>当被代理的目标对象实现了接口时，Spring会使用JDK动态代理。</li>
<li>Spring AOP利用java.lang.reflect.Proxy类来创建代理对象，该类要求被代理的类必须实现至少一个接口。</li>
<li>Spring在运行时动态生成了一个实现了相同接口的代理对象，代理对象中的方法会委托给InvocationHandler接口的实现类来执行增强逻辑。</li>
<li>JDK动态代理的优势在于它不需要引入额外的库，但缺点是被代理的类必须实现接口。</li>
</ul>
<ol>
<li>CGLIB动态代理：</li>
</ol>
<ul>
<li>当被代理的目标对象没有实现接口时，Spring会使用CGLIB动态代理。</li>
<li>CGLIB是一个强大的，高性能的代码生成库，它通过在运行时生成字节码的方式来动态创建代理类。</li>
<li>Spring AOP利用CGLIB来生成被代理对象的子类，并在子类中重写需要增强的方法，将增强逻辑织入到重写的方法中。</li>
<li>CGLIB动态代理的优势在于它可以代理没有实现接口的类，但缺点是需要引入CGLIB库，并且生成的代理类会比较庞大。</li>
</ul>
<h2 id="13-jdkdynamicaopproxy-类">1.3 JdkDynamicAopProxy 类</h2>
<h3 id="131-jdkdynamicaopproxy-类结构">1.3.1 JdkDynamicAopProxy 类结构</h3>
<p><code>JdkDynamicAopProxy</code>类的实现做一些准备工作，包括声明变量、初始化变量、定义静态成员等。</p>
<pre><code class="language-java">//final 类不能被继承
final class JdkDynamicAopProxy implements org.springframework.aop.framework.AopProxy, InvocationHandler, Serializable {

	/** use serialVersionUID from Spring 1.2 for interoperability. */
	private static final long serialVersionUID = 5531744639992436476L;


	private static final String COROUTINES_FLOW_CLASS_NAME = &quot;kotlinx.coroutines.flow.Flow&quot;;

	private static final boolean coroutinesReactorPresent = ClassUtils.isPresent(
			&quot;kotlinx.coroutines.reactor.MonoKt&quot;, JdkDynamicAopProxy.class.getClassLoader());

	/** We use a static Log to avoid serialization issues. */
	private static final Log logger = LogFactory.getLog(JdkDynamicAopProxy.class);

	/** Config used to configure this proxy. 用于保存代理配置信息 */
	private final org.springframework.aop.framework.AdvisedSupport advised;

	/** Cached in {@link org.springframework.aop.framework.AdvisedSupport#proxyMetadataCache}.
	 *  保存被代理的接口
	 * */
	private transient ProxiedInterfacesCache cache;
    
}
</code></pre>
<pre><code class="language-java">/**
	 * Holder for the complete proxied interfaces and derived metadata,
	 * to be cached in {@link org.springframework.aop.framework.AdvisedSupport#proxyMetadataCache}.
	 * @since 6.1.3
	 */
	private static final class ProxiedInterfacesCache {

		//保存被代理的接口
		final Class&lt;?&gt;[] proxiedInterfaces;

		//表示被代理的接口是否定义类equals方法
		final boolean equalsDefined;

		final boolean hashCodeDefined;
}
</code></pre>
<h3 id="132-getproxy-方法的实现">1.3.2 getProxy 方法的实现</h3>
<pre><code class="language-java">//重写父类的接口或者方法
@Override
public Object getProxy() {//使用默认类加载器
    return getProxy(ClassUtils.getDefaultClassLoader());
}

@Override
public Object getProxy(@Nullable ClassLoader classLoader) {//允许传入自定义类加载器
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Creating JDK dynamic proxy: &quot; + this.advised.getTargetSource());
    }
    return Proxy.newProxyInstance(determineClassLoader(classLoader), this.cache.proxiedInterfaces, this);
}
</code></pre>
<h3 id="133-determineclassloader-方法的实现">1.3.3 determineClassLoader 方法的实现</h3>
<pre><code class="language-java">/**
    * Determine whether the JDK bootstrap or platform loader has been suggested -&gt;
    * use higher-level loader which can see Spring infrastructure classes instead.
    * 确定最终使用的类加载器
    */
private ClassLoader determineClassLoader(@Nullable ClassLoader classLoader) {
    if (classLoader == null) {
        // JDK bootstrap loader -&gt; use spring-aop ClassLoader instead.
        //返回当前类的类加载器，通常是应用程序类加载器
        return getClass().getClassLoader();
    }
    if (classLoader.getParent() == null) {
        // Potentially the JDK platform loader on JDK 9+
        //获取当前类的类加载器
        ClassLoader aopClassLoader = getClass().getClassLoader();
        //获取父类加载器
        ClassLoader aopParent = aopClassLoader.getParent();
        while (aopParent != null) {//找到最顶层父类加载器
            if (classLoader == aopParent) {
                // Suggested ClassLoader is ancestor of spring-aop ClassLoader
                // -&gt; use spring-aop ClassLoader itself instead.
                //如果当前类加载器等于当前父类加载器，直接返回
                return aopClassLoader;
            }
            aopParent = aopParent.getParent();
        }
    }
    // Regular case: use suggested ClassLoader as-is.
    return classLoader;
}
</code></pre>
<h3 id="134-newproxyinstance-方法的实现">1.3.4 newProxyInstance 方法的实现</h3>
<p>主要用于创建代理实例，其中包含了一些安全性检查和异常处理。</p>
<pre><code class="language-java">//传入类加载器、代理接口数组、调用处理程序
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                        Class&lt;?&gt;[] interfaces,
                                        InvocationHandler h)
    throws IllegalArgumentException
{
    //检查调用处理程序是否为null
    Objects.requireNonNull(h);

    //复制接口数组，确保不会修改原始数组
    final Class&lt;?&gt;[] intfs = interfaces.clone();
    final SecurityManager sm = System.getSecurityManager();
    //安全检查
    if (sm != null) {
        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
    }

    /*
    * Look up or generate the designated proxy class.
    * 生存代理对象
    */
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);

    /*
        * Invoke its constructor with the designated invocation handler.
        */
    try {
        if (sm != null) {
            checkNewProxyPermission(Reflection.getCallerClass(), cl);
        }
        //获取代理类构造函数
        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h;
        if (!Modifier.isPublic(cl.getModifiers())) {
            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                public Void run() {
                    cons.setAccessible(true);
                    return null;
                }
            });
        }
        //返回代理对象
        return cons.newInstance(new Object[]{h});
    } catch (IllegalAccessException|InstantiationException e) {
        throw new InternalError(e.toString(), e);
    } catch (InvocationTargetException e) {
        Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new InternalError(t.toString(), t);
        }
    } catch (NoSuchMethodException e) {
        throw new InternalError(e.toString(), e);
    }
}
</code></pre>
<h3 id="135-invocationhandler-接口">1.3.5 InvocationHandler 接口</h3>
<p>InvocationHandler接口定义了一个用于处理代理对象方法调用的统一入口，当代理对象的方法被调用时，会触发invoke方法的执行，通过实现invoke方法来定义代理对象方法调用时的行为，例如添加日志、实现权限控制等。</p>
<pre><code class="language-java">public interface InvocationHandler {
    //传入代理对象，被调用的方法、方法 参数
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}

在 invoke 方法中，会根据方法名和参数，调用对应的拦截器。

```java
/**
    * Implementation of {@code InvocationHandler.invoke}.
    * &lt;p&gt;Callers will see exactly the exception thrown by the target,
    * unless a hook method throws an exception.
    */
@Override
public @Nullable Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Object oldProxy = null;
    boolean setProxyContext = false;

    TargetSource targetSource = this.advised.targetSource;
    Object target = null;

    try {
        if (!this.cache.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {
            // The target does not implement the equals(Object) method itself.
            return equals(args[0]);
        }
        else if (!this.cache.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {
            // The target does not implement the hashCode() method itself.
            return hashCode();
        }
        else if (method.getDeclaringClass() == DecoratingProxy.class) {
            // There is only getDecoratedClass() declared -&gt; dispatch to proxy config.
            return org.springframework.aop.framework.AopProxyUtils.ultimateTargetClass(this.advised);
        }
        else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;
                method.getDeclaringClass().isAssignableFrom(org.springframework.aop.framework.Advised.class)) {
            // Service invocations on ProxyConfig with the proxy config...
            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
        }

        Object retVal;

        if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = org.springframework.aop.framework.AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
        }

        // Get as late as possible to minimize the time we &quot;own&quot; the target,
        // in case it comes from a pool.
        target = targetSource.getTarget();
        Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);

        // Get the interception chain for this method.
        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        // Check whether we have any advice. If we don't, we can fall back on direct
        // reflective invocation of the target, and avoid creating a MethodInvocation.
        if (chain.isEmpty()) {
            // We can skip creating a MethodInvocation: just invoke the target directly
            // Note that the final invoker must be an InvokerInterceptor so we know it does
            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
            @Nullable Object[] argsToUse = org.springframework.aop.framework.AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
        }
        else {
            // We need to create a method invocation...
            MethodInvocation invocation =
                    new org.springframework.aop.framework.ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            // Proceed to the joinpoint through the interceptor chain.
            retVal = invocation.proceed();
        }

        // Massage return value if necessary.
        Class&lt;?&gt; returnType = method.getReturnType();
        if (retVal != null &amp;&amp; retVal == target &amp;&amp;
                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;
                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
            // Special case: it returned &quot;this&quot; and the return type of the method
            // is type-compatible. Note that we can't help if the target sets
            // a reference to itself in another returned object.
            retVal = proxy;
        }
        else if (retVal == null &amp;&amp; returnType != void.class &amp;&amp; returnType.isPrimitive()) {
            throw new AopInvocationException(
                    &quot;Null return value from advice does not match primitive return type for: &quot; + method);
        }
        if (coroutinesReactorPresent &amp;&amp; KotlinDetector.isSuspendingFunction(method)) {
            return COROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName()) ?
                    org.springframework.aop.framework.CoroutinesUtils.asFlow(retVal) : org.springframework.aop.framework.CoroutinesUtils.awaitSingleOrNull(retVal, args[args.length - 1]);
        }
        return retVal;
    }
    finally {
        if (target != null &amp;&amp; !targetSource.isStatic()) {
            // Must have come from TargetSource.
            targetSource.releaseTarget(target);
        }
        if (setProxyContext) {
            // Restore old proxy.
            org.springframework.aop.framework.AopContext.setCurrentProxy(oldProxy);
        }
    }
}
</code></pre>
<h2 id="13-实践与应用">1.3 实践与应用</h2>
<h3 id="131-编写自定义的-aop-拦截器步骤">1.3.1 编写自定义的 AOP 拦截器步骤</h3>
<ol>
<li>编写自定义拦截器：</li>
</ol>
<ul>
<li>创建一个类，实现 Spring 的 MethodInterceptor 接口，该接口定义了拦截器的核心方法 invoke。</li>
<li>在 invoke 方法中编写自定义的拦截逻辑，比如在目标方法执行前后执行一些操作，或者替换目标方法的执行等。</li>
</ul>
<pre><code class="language-java">public class CustomInterceptor implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // 在目标方法执行前输出日志
        System.out.println(&quot;Before invoking method: &quot; + invocation.getMethod().getName());

        // 执行目标方法
        Object result = invocation.proceed(); 

        // 在目标方法执行后输出日志
        System.out.println(&quot;After invoking method: &quot; + invocation.getMethod().getName());

        return result;
    }
}
</code></pre>
<p>创建一个注解 CustomAnnotation，用来标记需要被拦截的方法。</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomAnnotation {
}
</code></pre>
<p>修改 UserService 和 UserServiceImpl，在需要拦截的方法上添加 CustomAnnotation 注解。</p>
<pre><code class="language-java">public interface UserService {
    @CustomAnnotation
    void addUser(String username);
}

public class UserServiceImpl implements UserService {
    @Override
    @CustomAnnotation
    public void addUser(String username) {
        System.out.println(&quot;User added: &quot; + username);
    }
}
</code></pre>
<ol start="2">
<li>配置拦截器：</li>
</ol>
<ul>
<li>使用 Spring 的配置方式（XML、Java Config、注解）将自定义的拦截器配置到 Spring 容器中。</li>
<li>将拦截器与目标 bean 关联起来，可以通过切点表达式或其他方式指定在哪些方法上应用拦截器。</li>
</ul>
<p>使用 Spring 的 Java Config 来配置拦截器和切面。</p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    /**
     * 返回一个 UserService 实例
     */
    @Bean
    public UserService userService() {
        return new UserServiceImpl();
    }

    /**
     * 返回一个 CustomInterceptor 的实例，即自定义的拦截器
     */
    @Bean
    public CustomInterceptor customInterceptor() {
        return new CustomInterceptor();
    }

    /**
     * 返回一个 DefaultAdvisorAutoProxyCreator 实例，负责自动代理被 @AspectJ 注解标记的 Bean
     */
    @Bean
    public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() {
        return new DefaultAdvisorAutoProxyCreator();
    }

    /**
     * 返回一个 DefaultPointcutAdvisor 实例，将拦截器和切点绑定在一起
     */
    @Bean
    public DefaultPointcutAdvisor defaultPointcutAdvisor() {
        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor();
        // 将自定义的拦截器设置为 Advisor 的 advice，即在目标方法执行前后所执行的逻辑
        advisor.setAdvice(customInterceptor());
       // 设置切点，即确定在哪些方法上应用拦截器的条件
        advisor.setPointcut(annotationMatchingPointcut());
        return advisor;
    }

    /**
     * 返回一个 AnnotationMatchingPointcut 实例，切点用于匹配带有 CustomAnnotation 注解的方法
     */
    @Bean
    public AnnotationMatchingPointcut annotationMatchingPointcut() {
        return AnnotationMatchingPointcut.forMethodAnnotation(CustomAnnotation.class);
    }
}
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        UserService userService = context.getBean(UserService.class);
        // 在执行 addUser 方法之前，拦截器执行了自定义的前置逻辑，并在方法执行完毕后执行了自定义的后置逻辑
        userService.addUser(&quot;Alice&quot;);
    }
}

// 输出结果
Before invoking method: addUser
User added: Alice
After invoking method: addUser
</code></pre>
<ol start="4">
<li>调试和优化</li>
</ol>
<h1 id="二-cglib代理">二、Cglib代理</h1>
<h2 id="21-cglib-代理简介">2.1 CGLIB 代理简介</h2>
<p>CGLIB是一个强大的、高性能的代码生成库。它被广泛应用于AOP（面向切面编程）、ORM（对象关系映射）和其他一些框架中。</p>
<h3 id="211-cglib代理的基本原理">2.1.1 CGLIB代理的基本原理</h3>
<ol>
<li>创建代理类：CGLIB通过<code>ASM</code>字节码操作框架，在运行时动态生成目标类的子类。这个子类会继承自目标类。</li>
<li>方法拦截：在生成的子类中，会覆盖所有非final的方法。覆盖的方法会委托给一个用户定义的拦截器（MethodInterceptor），拦截器中包含了增强的代码。<br>
调用流程：当调用代理类的方法时，实际上是在调用被覆盖的方法。这些方法内部会调用拦截器，拦截器再去调用原始类的相应方法。</li>
</ol>
<h3 id="212-cglib代理的特点">2.1.2 CGLIB代理的特点</h3>
<ol>
<li>无需接口：CGLIB代理不需要目标类实现任何接口，因为它是通过继承的方式来实现代理的。</li>
<li>性能：CGLIB生成的代理类是目标类的子类，相比于JDK动态代理（接口代理），CGLIB代理通常有更好的性能，因为它直接调用父类的方法，减少了反射调用的开销。</li>
<li>灵活性：由于CGLIB代理是通过继承实现的，它无法代理final类和方法。但是，它提供了比JDK代理更高的灵活性，因为它可以代理任何类，而不受接口限制。</li>
<li>复杂性：CGLIB代理的实现比JDK动态代理复杂，因为它涉及到字节码生成和类加载机制。</li>
<li>兼容性：CGLIB代理通常与Spring框架结合使用，Spring AOP默认使用JDK动态代理，但如果目标对象没有实现接口，Spring AOP会自动切换到CGLIB代理。</li>
</ol>
<h2 id="22-分析-cglib-如何通过字节码技术创建代理类">2.2 分析 CGLIB 如何通过字节码技术创建代理类</h2>
<p>CGLIB通过操纵字节码，创建出目标类的子类，并在子类中覆盖非final的方法，从而实现方法拦截和增强。</p>
<h3 id="221-cglib创建代理类的基本步骤">2.2.1 CGLIB创建代理类的基本步骤</h3>
<ol>
<li>确定目标类：首先要确定需要被代理的目标类。CGLIB代理不需要目标类实现任何接口，因为它是通过继承的方式来实现代理的。</li>
<li>创建<code>Enhancer对</code>象：Enhancer是CGLIB中的一个核心类，用于创建代理类。首先创建一个Enhancer实例，并设置其父类（即目标类）。</li>
<li>设置<code>Callback</code>：Callback是一个接口，用于定义代理类中覆盖方法的逻辑。通常使用<code>MethodInterceptor</code>接口，它允许我们在调用原始方法之前和之后插入自定义代码。将实现的Callback对象设置给Enhancer。</li>
<li>创建代理类：调用Enhancer的<code>create()</code>方法，CGLIB会使用ASM字节码操作框架来动态生成一个继承自目标类的子类。这个子类会覆盖所有<code>非final</code>的方法，并将调用委托给Callback对象。</li>
<li>使用代理类：create()方法返回的是一个代理类的实例，这个实例可以被当作目标类的实例来使用。当调用代理类的方法时，实际上会调用MethodInterceptor中的<code>intercept()</code>方法。</li>
<li>方法调用流程：在intercept()方法中，可以调用Method对象的invoke()方法来执行原始方法。这样，我们就可以在原始方法执行前后插入自定义的逻辑，实现方法的拦截和增强。</li>
</ol>
<h3 id="222-深入分析-cglibaopproxy-类的结构">2.2.2 深入分析 CglibAopProxy 类的结构</h3>
<h4 id="cglibaopproxy-类结构">CglibAopProxy 类结构</h4>
<ol>
<li>成员变量：<br>
AdvisedSupport advised：存储了AOP配置信息的数据结构，如目标对象、切面等。<br>
Callback callback：CGLIB 回调对象，负责实现代理逻辑。</li>
<li>构造方法：<br>
CglibAopProxy(AdvisedSupport config)：构造方法接收一个 AdvisedSupport 参数，用于设置AOP配置信息。</li>
<li>核心方法：<br>
getProxy(ClassLoader classLoader)：生成代理对象的核心方法，接收一个 ClassLoader 参数用于加载代理类。<br>
createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks)：使用 CGLIB 的 Enhancer 创建代理类，并返回代理对象的实例。<br>
proxy(ClassLoader classLoader, Callback[] callbacks)：创建代理类并生成代理对象的实现逻辑， 使用 Enhancer 创建代理类，并指定 Callback 对象，完成代理类的生成和实例化。<br>
createEnhancer()：创建 Enhancer 对象，用于生成代理类， Enhancer 是 CGLIB 中负责生成代理类的核心类。</li>
</ol>
<h4 id="cglibaopproxy-类源码">CglibAopProxy 类源码</h4>
<pre><code class="language-java">class CglibAopProxy implements org.springframework.aop.framework.AopProxy, Serializable {

	// Constants for CGLIB callback array indices
	//表示aop代理类型
	private static final int AOP_PROXY = 0;

	//表示直接调用目标对象
	private static final int INVOKE_TARGET = 1;

	//表示不覆盖方法
	private static final int NO_OVERRIDE = 2;

	//表示分派到目标对象
	private static final int DISPATCH_TARGET = 3;

	//表示分派到通知器
	private static final int DISPATCH_ADVISED = 4;

	//表示调用equals方法
	private static final int INVOKE_EQUALS = 5;

	//表示调用hashCode方法
	private static final int INVOKE_HASHCODE = 6;


	private static final String COROUTINES_FLOW_CLASS_NAME = &quot;kotlinx.coroutines.flow.Flow&quot;;

	private static final boolean coroutinesReactorPresent = ClassUtils.isPresent(
			&quot;kotlinx.coroutines.reactor.MonoKt&quot;, CglibAopProxy.class.getClassLoader());

	private static final GeneratorStrategy undeclaredThrowableStrategy =
			new UndeclaredThrowableStrategy(UndeclaredThrowableException.class);

	/** Logger available to subclasses; static to optimize serialization. */
	protected static final Log logger = LogFactory.getLog(CglibAopProxy.class);

	/** Keeps track of the Classes that we have validated for final methods. */
	private static final Map&lt;Class&lt;?&gt;, Boolean&gt; validatedClasses = new WeakHashMap&lt;&gt;();

	//用于存储aop的配置信息，如目标对象、切面等
	/** The configuration used to configure this proxy. */
	protected final org.springframework.aop.framework.AdvisedSupport advised;

	//对象数组，用于存储构造器参数
	protected Object @Nullable [] constructorArgs;

	//类对象数组，用于存储构造器参数类型
	protected Class&lt;?&gt; @Nullable [] constructorArgTypes;

	/** Dispatcher used for methods on Advised. */
	//用于分派通知器
	private final transient AdvisedDispatcher advisedDispatcher;

	private transient Map&lt;Method, Integer&gt; fixedInterceptorMap = Collections.emptyMap();

	private transient int fixedInterceptorOffset;


	/**
	 * Create a new CglibAopProxy for the given AOP configuration.
	 * @param config the AOP configuration as AdvisedSupport object
	 * @throws org.springframework.aop.framework.AopConfigException if the config is invalid. We try to throw an informative
	 * exception in this case, rather than let a mysterious failure happen later.
	 */
	public CglibAopProxy(org.springframework.aop.framework.AdvisedSupport config) throws org.springframework.aop.framework.AopConfigException {
		Assert.notNull(config, &quot;AdvisedSupport must not be null&quot;);
		this.advised = config;
		this.advisedDispatcher = new AdvisedDispatcher(this.advised);
	}

	/**
	 * Set constructor arguments to use for creating the proxy.
	 * @param constructorArgs the constructor argument values
	 * @param constructorArgTypes the constructor argument types
	 */
	public void setConstructorArguments(Object @Nullable [] constructorArgs, Class&lt;?&gt; @Nullable [] constructorArgTypes) {
		if (constructorArgs == null || constructorArgTypes == null) {
			throw new IllegalArgumentException(&quot;Both 'constructorArgs' and 'constructorArgTypes' need to be specified&quot;);
		}
		if (constructorArgs.length != constructorArgTypes.length) {
			throw new IllegalArgumentException(&quot;Number of 'constructorArgs' (&quot; + constructorArgs.length +
					&quot;) must match number of 'constructorArgTypes' (&quot; + constructorArgTypes.length + &quot;)&quot;);
		}
		this.constructorArgs = constructorArgs;
		this.constructorArgTypes = constructorArgTypes;
	}
}
</code></pre>
<h3 id="223-cglib-代理对象的创建过程">2.2.3 CGLIB 代理对象的创建过程</h3>
<blockquote>
<p>代理对象的创建过程： 检查是否可以使用缓存的代理对象 -&gt; 准备 CGLIB Enhancer -&gt;  配置 Enhancer -&gt; 设置回调处理器（Callback） -&gt; 生成代理类字节码 -&gt; 创建代理对象实例  -&gt;  将代理对象缓存起来</p>
</blockquote>
<h4 id="createhelper-方法用来实际创建代理对象">createHelper() 方法用来实际创建代理对象。</h4>
<pre><code class="language-java">private Object createHelper() {
    preValidate();
    // SPRING PATCH BEGIN
    Object key = new EnhancerKey((superclass != null ? superclass.getName() : null),
            (interfaces != null ? Arrays.asList(ReflectUtils.getNames(interfaces)) : null),
            (filter == ALL_ZERO ? null : new WeakCacheKey&lt;&gt;(filter)),
            Arrays.asList(callbackTypes),
            useFactory,
            interceptDuringConstruction,
            serialVersionUID);
    // SPRING PATCH END
    this.currentKey = key;
    //创建代理对象
    Object result = super.create(key);
    return result;
}
</code></pre>
<p>AbstractClassGenerator 对象通过调用 create() 方法，根据给定的键值（key）创建对象实例。</p>
<pre><code class="language-java">protected Object create(Object key) {
    try {
        //获取当前类加载器
        ClassLoader loader = getClassLoader();
        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;
        ClassLoaderData data = cache.get(loader);
        if (data == null) {
            synchronized (AbstractClassGenerator.class) {
                cache = CACHE;
                data = cache.get(loader);
                if (data == null) {
                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = new WeakHashMap&lt;&gt;(cache);
                    data = new ClassLoaderData(loader);
                    newCache.put(loader, data);
                    CACHE = newCache;
                }
            }
        }
        this.key = key;
        Object obj = data.get(this, getUseCache());
        if (obj instanceof Class&lt;?&gt; clazz) {
            //创建第一个实例
            return firstInstance(clazz);
        }
        return nextInstance(obj);
    }
    catch (RuntimeException | Error ex) {
        throw ex;
    }
    catch (Exception ex) {
        throw new CodeGenerationException(ex);
    }
}
</code></pre>
<h3 id="224-实践与应用">2.2.4 实践与应用</h3>
<p>编写自定义的 CGLIB 拦截器</p>
<blockquote>
<p>假设有一个简单的服务类 UserService，其中包含一些方法，希望能够在调用这些方法之前和之后记录日志。使用CGLIB来实现一个拦截器，记录方法调用的开始和结束时间。</p>
</blockquote>
<h4 id="1服务类-userservice模拟创建和更新用户信息">1.服务类 UserService，模拟创建和更新用户信息。</h4>
<pre><code class="language-java">public class UserService {

    public void createUser(String username) {
        System.out.println(&quot;Creating user: &quot; + username);
        // 模拟创建用户的逻辑
    }

    public void updateUser(String username) {
        System.out.println(&quot;Updating user: &quot; + username);
        // 模拟更新用户的逻辑
    }
}
</code></pre>
<h4 id="2自定义的cglib拦截器用于记录方法调用的开始和结束时间">2.自定义的CGLIB拦截器，用于记录方法调用的开始和结束时间。</h4>
<pre><code class="language-java">/**
 * 创建 LoggingInterceptor 类，实现 MethodInterceptor 接口
 */
public class LoggingInterceptor implements MethodInterceptor {
    
    /**
     * 参数：obj 是被代理的对象实例
     *      method 是被调用的方法对象
     *      args 是方法的参数数组
     *      proxy 是用于调用父类（被代理类）方法的代理对象
     */
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 获取方法调用开始时的时间戳
        long startTime = System.currentTimeMillis();
        System.out.println(&quot;Method &quot; + method.getName() + &quot; start at: &quot; + startTime);

        // 调用被代理类的原始方法，而不是代理对象的方法，以避免循环调用
        Object result = proxy.invokeSuper(obj, args);

        // 获取方法调用结束时的时间戳
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;Method &quot; + method.getName() + &quot; end at: &quot; + endTime);
        // 方法执行所花费的时间
        System.out.println(&quot;Method &quot; + method.getName() + &quot; execution time: &quot; + (endTime - startTime) + &quot; milliseconds&quot;);

        // 调用原始方法后的返回值
        return result;
    }

    public static void main(String[] args) {
        UserService userService = new UserService();

        // 使用CGLIB的 Enhancer 类创建了 UserService 类的代理对象，并将拦截器设置为回调方法
        Enhancer enhancer = new Enhancer();
        // 设置了要代理的目标类是 UserService
        enhancer.setSuperclass(UserService.class);
        // 指定了在方法调用时应该执行的拦截逻辑
        enhancer.setCallback(new LoggingInterceptor());

        // 创建代理对象，将会在方法调用时执行我们定义的拦截逻辑
        UserService userServiceProxy = (UserService) enhancer.create();

        // 调用代理对象的 createUser 和 updateUser 方法来触发拦截器的拦截逻辑
        userServiceProxy.createUser(&quot;John Doe&quot;);
        userServiceProxy.updateUser(&quot;Jane Smith&quot;);
    }
}

//输出结果：
Method createUser start at: 1621802728000
Creating user: John Doe
Method createUser end at: 1621802728000
Method createUser execution time: 0 milliseconds
Method updateUser start at: 1621802728000
Updating user: Jane Smith
Method updateUser end at: 1621802728000
Method updateUser execution time: 0 milliseconds
</code></pre>
<h3 id="225-实现对非接口类的代理和增强功能">2.2.5 实现对非接口类的代理和增强功能</h3>
<p>实现对非接口类的代理和增强功能通常使用 Spring AOP来实现，提供了一种便捷的方式来在方法执行前、执行后、方法抛出异常时等时机插入特定逻辑，而无需修改原始类的代码。</p>
<blockquote>
<p>假设有一个订单管理系统，其中包含一个 OrderService 类，该类负责处理订单相关的业务逻辑，比如创建订单、更新订单状态等。希望在处理订单相关业务时，记录日志并统计方法执行时间。</p>
</blockquote>
<ol>
<li>切面类 OrderAspect。</li>
</ol>
<pre><code class="language-java">@Aspect
@Component
public class OrderAspect {

    /**
     * 切面方法，用于实现切面的逻辑 -&gt; 表示正在执行目标方法之前
     * 接受一个 JoinPoint 参数，连接点 -&gt; 被增强的目标方法
     */
    @Before(&quot;execution(* com.example.service.OrderService.*(..))&quot;)
    public void logBefore(JoinPoint joinPoint) {
        System.out.println(&quot;Before executing method: &quot; + joinPoint.getSignature());
    }

     /**
     * 切面方法，用于实现切面的逻辑 -&gt; 表示目标方法执行完成后
     * 接受一个 JoinPoint 参数，连接点 -&gt; 被增强的目标方法
     */
    @After(&quot;execution(* com.example.service.OrderService.*(..))&quot;)
    public void logAfter(JoinPoint joinPoint) {
        System.out.println(&quot;After executing method: &quot; + joinPoint.getSignature());
    }
}
</code></pre>
<ol start="2">
<li>
<p>配置类中启用 Spring AOP 功能。</p>
</li>
<li>
<p>OrderService 类</p>
</li>
</ol>
<pre><code class="language-java">/**
 * 调用 OrderService 类的 createOrder() 或 updateOrderStatus() 方法时，OrderAspect 切面中定义的增强逻辑会在方法执行前后生效，从而实现了对非接口类的代理和增强功能
 */
@Service
public class OrderService {

    public void createOrder() {
        // 模拟创建订单的业务逻辑
        System.out.println(&quot;Creating order...&quot;);
    }

    public void updateOrderStatus() {
        // 模拟更新订单状态的业务逻辑
        System.out.println(&quot;Updating order status...&quot;);
    }
}

// 输出结果：
Before executing method: public void com.example.service.OrderService.createOrder()
Creating order...
After executing method: public void com.example.service.OrderService.createOrder()

Before executing method: public void com.example.service.OrderService.updateOrderStatus()
Updating order status...
After executing method: public void com.example.service.OrderService.updateOrderStatus()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring @Transactional原理]]></title>
        <id>https://q456qq520.github.io/post/spring-transactional-yuan-li/</id>
        <link href="https://q456qq520.github.io/post/spring-transactional-yuan-li/">
        </link>
        <updated>2025-05-11T04:21:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-简介">一 简介</h2>
<p>@Transactional是spring中声明式事务管理的注解配置方式，相信这个注解的作用大家都很清楚。@Transactional注解可以帮助我们把事务开启、提交或者回滚的操作，通过aop的方式进行管理。</p>
<p>通过@Transactional注解就能让spring为我们管理事务，免去了重复的事务管理逻辑，减少对业务代码的侵入，使我们开发人员能够专注于业务层面开发。</p>
<p>Spring事务管理采用切面（AOP）的核心原因在于实现声明式事务控制，将事务逻辑与业务逻辑解耦，从而提升代码的可维护性、灵活性和复用性</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1746937993921.png" alt="" loading="lazy"></figure>
<h2 id="二-transactional">二 @Transactional</h2>
<p>打开<code>TransactionAutoConfiguration</code>自动配置类可以看到一个比较重要的注解<code>@EnableTransactionManagement</code>用于开启事务管理功能，@EnableTransactionManagement注解又导入了<code>AutoProxyRegistrar</code>和<code>ProxyTransactionManagementConfiguration</code>。</p>
<h3 id="21-事务配置">2.1 事务配置</h3>
<p>首先是@Transactional，作用是定义代理植入点。我们知道代理对象创建的通过BeanPostProcessor的实现类AnnotationAwareAspectJAutoProxyCreator的postProcessAfterInstantiation方法来实现个，如果需要进行代理，那么在这个方法就会返回一个代理对象给容器，同时判断植入点也是在这个方法中。</p>
<p>在配置好注解驱动方式的事务管理之后，spring会在ioc容器创建一个<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例，这个实例可以看作是一个切点，在判断一个bean在初始化过程中是否需要创建代理对象，都需要验证一次<code>BeanFactoryTransactionAttributeSourceAdvisor</code>是否是适用这个bean的切点。如果是，就需要创建代理对象，并且把<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例注入到代理对象中。</p>
<p>我们知道在<code>AopUtils#findAdvisorsThatCanApply</code>中判断切面是否适用当前bean，最终调用<code>SpringTransactionAnnotationParser#parseTransactionAnnotation(java.lang.reflect.AnnotatedElement)</code></p>
<pre><code class="language-java">@Override
public TransactionAttribute parseTransactionAnnotation(AnnotatedElement ae) {
    //这里就是分析Method是否被@Transactional注解标注，有的话，不用说BeanFactoryTransactionAttributeSourceAdvisor适配当前bean，进行代理，并且注入切点
    //BeanFactoryTransactionAttributeSourceAdvisor
   AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ae, Transactional.class);
   if (attributes != null) {
      return parseTransactionAnnotation(attributes);
   }
   else {
      return null;
   }
}
</code></pre>
<p>上面就是判断是否需要根据<code>@Transactional</code>进行代理对象创建的判断过程。@Transactional的作用一个就是标识方法需要被代理，一个就是携带事务管理需要的一些属性信息。</p>
<h3 id="22-事务流程">2.2 事务流程</h3>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1746939646593.png" alt="" loading="lazy"></figure>
<h3 id="23-transactional注解作用域">2.3 @Transactional注解作用域</h3>
<p>@Transactional可以作用在接口、类、类方法；</p>
<ol>
<li>作用于类：当把@Transactional 注解放在类上时，表示所有该类的public方法都配置相同的事务属性信息，会导致事务控制的粒度太大，注解参数无法根据每个类方法的实际需求设置；因此，一般@Transactional注解都会直接添加的需要的方法上</li>
<li>作用于方法：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息</li>
<li>作用于接口：不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效</li>
</ol>
<h3 id="24-事务回滚">2.4 事务回滚</h3>
<p>@Transactional默认只能回滚RuntimeException和RuntimeException下面的子类抛出的异常，不能回滚Exception异常；如果需要支持回滚Exception异常，需要显示的指明，如@Transactional(rollbackFor = Exception.class)</p>
<h3 id="25-失效场景">2.5 失效场景</h3>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1746939916629.png" alt="" loading="lazy"></figure>
<p>参考<a href="https://blog.csdn.net/wang_luwei/article/details/121549005">&quot;事务失效场景&quot;</a></p>
<ol>
<li>@Transactional注解未打在public方法上<br>
Java的访问权限主要有四种：private、default、protected、public；如果事务方法定义了错误的访问权限（非public方法），会导致事务失效。</li>
<li>目标方法用final修饰<br>
某个方法不想被子类重写，可以将该方法定义成final的；如果将事务方法定义成final，会导致事务失效<br>
原因：Spring事务基于Spring AOP，通过JDK动态代理或者CGlib代理，在代理类中实现的事务功能；但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法；同样，static修饰的方法，同样无法通过动态代理，变成事务方法</li>
<li>同一个类中的方法直接内部调用<br>
方法被事务管理是因为Apring AOP为其生成代理了对象，但是直接this调用同类方法，调用的是目标类对象的方法，而非代理类方法，因此，在同类中的方法直接内部调用，会导致事务失效。</li>
<li>事务方法所在的类未被Spring管理</li>
<li>多线程调用<br>
如果两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务</li>
<li>存储引擎不支持事务</li>
<li>未开启事务</li>
</ol>
<h3 id="26-事务不回滚">2.6 事务不回滚</h3>
<ol>
<li>错误的传播特性</li>
</ol>
<p>其实，我们在使用@Transactional注解时，是可以指定propagation参数的。</p>
<p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p>
<ul>
<li>REQUIRED 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li>
<li>SUPPORTS 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。</li>
<li>MANDATORY 如果当前上下文中存在事务，否则抛出异常。</li>
<li>REQUIRES_NEW 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</li>
<li>NOT_SUPPORTED 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。</li>
<li>NEVER 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。</li>
<li>NESTED 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</li>
</ul>
<ol start="2">
<li>自己吞了异常<br>
这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。</li>
</ol>
<p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p>
<ol start="3">
<li>手动抛了别的异常</li>
<li>自定义了回滚异常</li>
<li>嵌套事务回滚多了</li>
</ol>
<h2 id="三-源码分析">三 源码分析</h2>
<p>aop最终的代理对象的代理方法是</p>
<p><code>DynamicAdvisedInterceptor#intercept</code></p>
<pre><code class="language-java">@Override
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
   Object oldProxy = null;
   boolean setProxyContext = false;
   Class&lt;?&gt; targetClass = null;
   Object target = null;
   try {
      if (this.advised.exposeProxy) {
         // Make invocation available if necessary.
         oldProxy = AopContext.setCurrentProxy(proxy);
         setProxyContext = true;
      }
      // May be null. Get as late as possible to minimize the time we
      // &quot;own&quot; the target, in case it comes from a pool...
      target = getTarget();
      if (target != null) {
         targetClass = target.getClass();
      }
       //follow
      List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
      Object retVal;
      // Check whether we only have one InvokerInterceptor: that is,
      // no real advice, but just reflective invocation of the target.
      if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {
         // We can skip creating a MethodInvocation: just invoke the target directly.
         // Note that the final invoker must be an InvokerInterceptor, so we know
         // it does nothing but a reflective operation on the target, and no hot
         // swapping or fancy proxying.
         Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
         retVal = methodProxy.invoke(target, argsToUse);
      }
      else {
         // We need to create a method invocation...
         retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
      }
      retVal = processReturnType(proxy, target, method, retVal);
      return retVal;
   }
   finally {
      if (target != null) {
         releaseTarget(target);
      }
      if (setProxyContext) {
         // Restore old proxy.
         AopContext.setCurrentProxy(oldProxy);
      }
   }
}
</code></pre>
<p><code>getInterceptorsAndDynamicInterceptionAdvice</code>返回的是<code>TransactionInterceptor</code>，发现最终是调用<code>TransactionInterceptor#invoke</code>方法，并且把CglibMethodInvocation注入到invoke方法中，从上面可以看到CglibMethodInvocation是包装了目标对象的方法调用的所有必须信息，因此，在TransactionInterceptor#invoke里面也是可以调用目标方法的，并且还可以实现类似@Around的逻辑，在目标方法调用前后继续注入一些其他逻辑，比如事务管理逻辑。</p>
<h3 id="23-transactioninterceptor最终事务管理者">2.3 TransactionInterceptor–最终事务管理者</h3>
<pre><code class="language-java">@Override
public Object invoke(final MethodInvocation invocation) throws Throwable {
 // Work out the target class: may be {@code null}.
 // The TransactionAttributeSource should be passed the target class
 // as well as the method, which may be from an interface.
 Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

 // Adapt to TransactionAspectSupport's invokeWithinTransaction...
 return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {
  @Override
  public Object proceedWithInvocation() throws Throwable {
   return invocation.proceed();
  }
 });
}
</code></pre>
<pre><code class="language-java">protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)
      throws Throwable {

   // If the transaction attribute is null, the method is non-transactional.
   final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);
   final PlatformTransactionManager tm = determineTransactionManager(txAttr);
   final String joinpointIdentification = methodIdentification(method, targetClass);

   if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
      // Standard transaction demarcation with getTransaction and commit/rollback calls.
       //开启事务
      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
      Object retVal = null;
      try {
         // This is an around advice: Invoke the next interceptor in the chain.
         // This will normally result in a target object being invoked.
          //方法调用
         retVal = invocation.proceedWithInvocation();
      }
      catch (Throwable ex) {
         // target invocation exception
     //回滚事务
         completeTransactionAfterThrowing(txInfo, ex);
         throw ex;
      }
      finally {
         cleanupTransactionInfo(txInfo);
      }
       //提交事务
      commitTransactionAfterReturning(txInfo);
      return retVal;
   }

   else {
      // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
      try {
         Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,
               new TransactionCallback&lt;Object&gt;() {
                  @Override
                  public Object doInTransaction(TransactionStatus status) {
                     TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
                     try {
                        return invocation.proceedWithInvocation();
                     }
                     catch (Throwable ex) {
                        if (txAttr.rollbackOn(ex)) {
                           // A RuntimeException: will lead to a rollback.
                           if (ex instanceof RuntimeException) {
                              throw (RuntimeException) ex;
                           }
                           else {
                              throw new ThrowableHolderException(ex);
                           }
                        }
                        else {
                           // A normal return value: will lead to a commit.
                           return new ThrowableHolder(ex);
                        }
                     }
                     finally {
                        cleanupTransactionInfo(txInfo);
                     }
                  }
               });

         // Check result: It might indicate a Throwable to rethrow.
         if (result instanceof ThrowableHolder) {
            throw ((ThrowableHolder) result).getThrowable();
         }
         else {
            return result;
         }
      }
      catch (ThrowableHolderException ex) {
         throw ex.getCause();
      }
   }
}
</code></pre>
<p>这里做了几件事情：</p>
<ol>
<li>获取事务的属性</li>
<li>加载配置中配的transactionManager</li>
<li>不同的事务处理方式使用不同的事务</li>
<li>在目标方法执行前获取事务并收集事务信息</li>
<li>执行目标方法</li>
<li>一旦出现异常，尝试异常处理，不是所有的异常都回滚， Spring 只对RuntimeException 处理</li>
<li>提交事务前的事务信息清除</li>
<li>提交事务</li>
</ol>
<h4 id="gettransactionattribute">getTransactionAttribute</h4>
<p>getTransactionAttribute 方法比较简单，就是获取事务属性并缓存， 如果事务存在，那就对事务 加一个属性描述，对应的值为 类名.方法名</p>
<pre><code class="language-java">public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {
		// 如果是Object.class 类，直接返回
		if (method.getDeclaringClass() == Object.class) {
			return null;
		}

		/** 
		首先 去查看是否有缓存，getCacheKey 里面 就是一个单纯的 new 了一个对象 MethodClassKey，MethodClassKey重写了
		toString() 方法， 主要就是 用了 method+targetClass
		**/
		Object cacheKey = getCacheKey(method, targetClass);
		TransactionAttribute cached = this.attributeCache.get(cacheKey);
		// 如果不为null, 要么就是具体的事务属性，要么就是 默认的空属性， 如果是默认的空事务属性，那就 返回null
		if (cached != null) {
			if (cached == NULL_TRANSACTION_ATTRIBUTE) {
				return null;
			}
			else {
				return cached;
			}
		}
		else {
			// 如果是空 ，那就再次获取一遍
			TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);
			// 放入缓存， 如果 属性为null, 设置 对应的value 为NULL_TRANSACTION_ATTRIBUTE
			if (txAttr == null) {
				this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
			}
			else {
			    // 放入属性之前， 对 事务属性 设置一个 描述，就是用 类名.方法名
				String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
				if (txAttr instanceof DefaultTransactionAttribute) {
					((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);
				}
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Adding transactional method '&quot; + methodIdentification + &quot;' with attribute: &quot; + txAttr);
				}
				this.attributeCache.put(cacheKey, txAttr);
			}
			return txAttr;
		}
	}
</code></pre>
<h4 id="computetransactionattribute">computeTransactionAttribute</h4>
<p>computeTransactionAttribute 方法主要是 寻找事务属性的， 主要流程如下：</p>
<ol>
<li>首先判断方法是什么类型的，如果不是 public 类型的，直接返回null</li>
<li>接下来获取 事务属性，这里是按照 targetClass.Method -&gt;tragetClass -&gt;interface.Method -&gt; interface 的顺序获取属性的， 也就是说，如果你接口上有事务属性， 但是如果你目标类的方法上还有属性，那就以目标类的方法的属性为准</li>
</ol>
<pre><code class="language-java">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {
		/** 这里要求 事务的方法是 public的，不然不生效
           注解式事务里面 AnnotationTransactionAttributeSource 里面默认是 true 的
          **/
		if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {
			return null;
		}

		/**
		 这里的方法可能是在一个接口上，所以这里是获取target class 的具体方法
		 比如： method 为IFoo.bar() , targetClass 是 DefaultFoo ,这里是需要获取 DefaultFoo.bar()方法
		 同时这里还处理了可能出现桥接的问题
		 如果 targetClass 为null ,那方法就不会变
		**/
		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);

		/**
		第一次尝试： 先对 方法上 @Transactional 进行解析
		 解析 方法上的@Transactional属性，利用 springTransactionAnnotationParser 对 方法上的
		 @Transactional 进行解析里面的属性， 返回 TransactionAttribute 
		**/
		TransactionAttribute txAttr = findTransactionAttribute(specificMethod);
		if (txAttr != null) {
			return txAttr;
		}

		/**
		第二次： 如果上一步没有获取到，那就可能在 target class上面
		对 target class 进行解析， 如果找到对应的事务属性， 并且是 
		用户级别的方法，那就返回
		**/
		txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());
		if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {
			return txAttr;
		}

        /**
         第三步 如果 在目标类上的 方法和类上都没有找到 对应的 事务属性
         那就去 原始的接口上去寻找， 还是 先从 method 上面开始，
         如果没有，那就看接口上有没有 配置事务属性
        **/
		if (specificMethod != method) {
			// Fallback is to look at the original method.
			txAttr = findTransactionAttribute(method);
			if (txAttr != null) {
				return txAttr;
			}
			// Last fallback is the class of the original method.
			txAttr = findTransactionAttribute(method.getDeclaringClass());
			if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {
				return txAttr;
			}
		}
         // 最后都没有找到，那就返回null
		return null;
	}
</code></pre>
<h4 id="transactionaspectsupportdeterminetransactionmanager">TransactionAspectSupport#determineTransactionManager</h4>
<p>方法的逻辑也比较简单：</p>
<ol>
<li>判断是否有事务属性，如果没有直接返回</li>
<li>根据事务的名字，获取对应的事务管理器</li>
<li>如果事务没有设置名字， 获取默认的事务管理器</li>
</ol>
<pre><code class="language-java">protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) {
		// 如果 事务属性 txAttr 为null， 那就直接返回
		if (txAttr == null || this.beanFactory == null) {
			return getTransactionManager();
		}
        // 获取对应的事务注解上的名字
		String qualifier = txAttr.getQualifier();
		if (StringUtils.hasText(qualifier)) {
		    // 根据指定的事务注解name去查询
			return determineQualifiedTransactionManager(this.beanFactory, qualifier);
		}
		//根据默认的事务注解name查询
		else if (StringUtils.hasText(this.transactionManagerBeanName)) {
			return determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName);
		}
		else {
		    // 获取默认的 事务管理器
			TransactionManager defaultTransactionManager = getTransactionManager();
			if (defaultTransactionManager == null) {
				defaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);
				if (defaultTransactionManager == null) {
					defaultTransactionManager = this.beanFactory.getBean(TransactionManager.class);
					this.transactionManagerCache.putIfAbsent(
							DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);
				}
			}
			return defaultTransactionManager;
		}
	}

    /**
     这里从(cache-&gt;beanFactory)里面获取 指定名字的事务管理器
    **/
	private TransactionManager determineQualifiedTransactionManager(BeanFactory beanFactory, String qualifier) {
	   // 这里首先也是先从缓存里面获取
		TransactionManager txManager = this.transactionManagerCache.get(qualifier);
		//如果缓存不存在，那就从BeanFactory 里面获取，然后再放进缓存
		if (txManager == null) {
			txManager = BeanFactoryAnnotationUtils.qualifiedBeanOfType(
					beanFactory, TransactionManager.class, qualifier);
			this.transactionManagerCache.putIfAbsent(qualifier, txManager);
		}
		return txManager;
	}
</code></pre>
<h4 id="transactionaspectsupportcreatetransactionifnecessary">TransactionAspectSupport#createTransactionIfNecessary</h4>
<p>这个方法主要是判断是否有必要创建事务</p>
<pre><code class="language-java">	protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {
		/**
		如果没有指定名称，则将方法标识应用为事务名称，就是之前设置的 class.method
		**/
		if (txAttr != null &amp;&amp; txAttr.getName() == null) {
			txAttr = new DelegatingTransactionAttribute(txAttr) {
				@Override
				public String getName() {
					return joinpointIdentification;
				}
			};
		}

		TransactionStatus status = null;
		if (txAttr != null) {
			if (tm != null) {
				status = tm.getTransaction(txAttr);
			}
			else {
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification +
							&quot;] because no transaction manager has been configured&quot;);
				}
			}
		}
		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
	}
</code></pre>
<h4 id="abstractplatformtransactionmanagergettransaction">AbstractPlatformTransactionManager#getTransaction</h4>
<p>getTransaction方法 比较核心了， 主要做了以下几件事：</p>
<ol>
<li>获取事务</li>
<li>如果当前线程存在事务，则转向嵌套事务处理</li>
<li>事务的超时设置验证</li>
<li>事务的传播属性验证</li>
<li>隔离级别， timeout ,connectinHolder 等配置</li>
<li>绑定到当前线程</li>
</ol>
<pre><code class="language-java">public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException {

		// 如果传入的definition 为null , 就从新定义一个新的definition (StaticTransactionDefinition 类型)
		TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());
        //这里时获取 当前线程缓存在 threadlocal里面的 connection, 如果没有connection,那DataSourceTransactionObject 里面的
        //connectionHolder 为null
		Object transaction = doGetTransaction();
		boolean debugEnabled = logger.isDebugEnabled();
        // 这里时判断如果上面的 connectionHolder 不为空，并且是有效的
		if (isExistingTransaction(transaction)) {
			// Existing transaction found -&gt; check propagation behavior to find out how to behave.
			// 这里是 为已经存在的 transaction创建一个 TransactionStatus对象
			return handleExistingTransaction(def, transaction, debugEnabled);
		}

		// Check definition settings for new transaction.
		if (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) {
			throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, def.getTimeout());
		}

		//如果事务定义为MANDATORY，那就是必须在一个已有事务里面运行， 这里没有事务就会报错
		if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
			throw new IllegalTransactionStateException(
					&quot;No existing transaction found for transaction marked with propagation 'mandatory'&quot;);
		}
		else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
				def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
				def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
				// 这块空挂起，不做任何操作
			SuspendedResourcesHolder suspendedResources = suspend(null);
			if (debugEnabled) {
				logger.debug(&quot;Creating new transaction with name [&quot; + def.getName() + &quot;]: &quot; + def);
			}
			try {
			   // 这里就是开启事务
				return startTransaction(def, transaction, debugEnabled, suspendedResources);
			}
			catch (RuntimeException | Error ex) {
				resume(null, suspendedResources);
				throw ex;
			}
		}
		else {
			// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.
			if (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) {
				logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +
						&quot;isolation level will effectively be ignored: &quot; + def);
			}
			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);
		}
	}
</code></pre>
<h4 id="datasourcetransactionmanagerdogettransaction">DataSourceTransactionManager#doGetTransaction</h4>
<p>doGetTransaction 方法主要就是为了获取当前线程的 connection, 通过查看缓存在 TransactionSynchronizationManager.class里面的resources 的threadLocal 里面的connection,如果没有就为null</p>
<p>后面doBegin 方法里面最好是绑定数据源，就是存放在一个 ThreadLocal里面， 里面存放的是Map,key 就是 datasource,Value 就是对应的connection</p>
<pre><code class="language-java">	protected Object doGetTransaction() {
	    // 创建一个 DataSourceTransactionObject 对象
		DataSourceTransactionObject txObject = new DataSourceTransactionObject();
		// 设置 此事务中是否允许保存点, isNestedTransactionAllowed() 为true，是在事务创建时设置的
		txObject.setSavepointAllowed(isNestedTransactionAllowed());
		/**获取当前线程的connection 缓存，如果不存在，那就为null
		这里是一个Map 存储的， key 是datasource ，value 是connection
		**/
		ConnectionHolder conHolder =
				(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());
		txObject.setConnectionHolder(conHolder, false);
		return txObject;
	}
</code></pre>
<h4 id="abstractplatformtransactionmanagersuspend">AbstractPlatformTransactionManager#suspend</h4>
<p>suspend 方法主要是对事务进行挂起，对于挂起操作主要的目的是记录原有事务的状态，以便后续操作对原有事务的恢复.</p>
<pre><code class="language-java">protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {
        // 如果当前线程的事务同步器是否是活跃状态
		if (TransactionSynchronizationManager.isSynchronizationActive()) {
		    /** 这里获取所有事务同步器的 快照，先悬挂住，并把当前线程清空，最后返回一个 
		    new SuspendedResourcesHolder  对象
		    **/
			List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();
			try {
				Object suspendedResources = null;
				if (transaction != null) {
					suspendedResources = doSuspend(transaction);
				}
				String name = TransactionSynchronizationManager.getCurrentTransactionName();
				TransactionSynchronizationManager.setCurrentTransactionName(null);
				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);
				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);
				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();
				TransactionSynchronizationManager.setActualTransactionActive(false);
				return new SuspendedResourcesHolder(
						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);
			}
			catch (RuntimeException | Error ex) {
				// doSuspend failed - original transaction is still active...
				doResumeSynchronization(suspendedSynchronizations);
				throw ex;
			}
		}
		else if (transaction != null) {
			// Transaction active but no synchronization active.
			Object suspendedResources = doSuspend(transaction);
			return new SuspendedResourcesHolder(suspendedResources);
		}
		else {
			// Neither transaction nor synchronization active.
			return null;
		}
	}
</code></pre>
<h4 id="abstractplatformtransactionmanagerstarttransaction">AbstractPlatformTransactionManager#startTransaction</h4>
<p>startTransaction方法 主要就是 开启新事务 ,详细逻辑在下面的doBegin</p>
<pre><code class="language-java">	private TransactionStatus startTransaction(TransactionDefinition definition, Object transaction,
			boolean debugEnabled, @Nullable SuspendedResourcesHolder suspendedResources) {

		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
		DefaultTransactionStatus status = newTransactionStatus(
				definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
				// 这里主要是构造transaction, 包括设置ConnectionHolder ，隔离级别，timeout ，如果是新连接，绑定到当前线程
		doBegin(transaction, definition);
		// 新同步事务的设置
		prepareSynchronization(status, definition);
		return status;
	}
</code></pre>
<h4 id="datasourcetransactionmanagerdobegin">DataSourceTransactionManager#doBegin</h4>
<p>doBegin 主要是构造transaction, 包括设置ConnectionHolder ，隔离级别，timeout ，这类不是spring 完成，而是交给底层的数据连接去做的，如果是新连接，绑定到当前线程</p>
<pre><code class="language-java">protected void doBegin(Object transaction, TransactionDefinition definition) {
        // 转换为 DataSourceTransactionObject
		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
		Connection con = null;

		try {
		    // 如果没有数据连接connection
			if (!txObject.hasConnectionHolder() ||
					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {
				// 这里就是调用数据源进行获取 connection 并进行绑定
				Connection newCon = obtainDataSource().getConnection();
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Acquired Connection [&quot; + newCon + &quot;] for JDBC transaction&quot;);
				}
				txObject.setConnectionHolder(new ConnectionHolder(newCon), true);
			}

			txObject.getConnectionHolder().setSynchronizedWithTransaction(true);
			con = txObject.getConnectionHolder().getConnection();
            // 对connection 设置 隔离级别和 是否只读属性
			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);
			txObject.setPreviousIsolationLevel(previousIsolationLevel);
			txObject.setReadOnly(definition.isReadOnly());

			// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,
			// so we don't want to do it unnecessarily (for example if we've explicitly
			// configured the connection pool to set it already).
			/**
			这里就是关闭自动提交， 就是开启事务了，由Spring 控制提交
			**/
			if (con.getAutoCommit()) {
				txObject.setMustRestoreAutoCommit(true);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Switching JDBC Connection [&quot; + con + &quot;] to manual commit&quot;);
				}
				con.setAutoCommit(false);
			}
            /**
            设置只读事务,就是这事务内没有新增，修改，删除操作只有查询操作，不需要数据库锁等操作，减少数据库压力，
            还有就是其他事务提交的数据，在&quot;SET TRANSACTION READ ONLY&quot; 是看不到的
            **/
			prepareTransactionalConnection(con, definition);
			// 配置 判断当前线程是否有事务的 标志
			txObject.getConnectionHolder().setTransactionActive(true);
            // 设置timeout
			int timeout = determineTimeout(definition);
			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {
				txObject.getConnectionHolder().setTimeoutInSeconds(timeout);
			}

			// Bind the connection holder to the thread.
			// 绑定这connection 到当前线程
			if (txObject.isNewConnectionHolder()) {
				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());
			}
		}

		catch (Throwable ex) {
			if (txObject.isNewConnectionHolder()) {
				DataSourceUtils.releaseConnection(con, obtainDataSource());
				txObject.setConnectionHolder(null, false);
			}
			throw new CannotCreateTransactionException(&quot;Could not open JDBC Connection for transaction&quot;, ex);
		}
	}
</code></pre>
<h4 id="transactionaspectsupportpreparetransactioninfo">TransactionAspectSupport#prepareTransactionInfo</h4>
<p>当已经建立事务连接并完成了事务的提取后，我们需要将所有的事务信息统一记录在TransactionInfo 类型的实例里面，这个实例包含了目标方法开始前的所有状态信息，一旦事务执行失败，Spring 会通过TransactionInfo 类型的实例中的信息来进行回滚等后续工作.<br>
方法prepareTransactionInfo 主要做了以下几件事：</p>
<ol>
<li>创建了一个TransactionInfo 实例， 把tm,txAttr,joinpointIdentification,status 属性都填充进去了</li>
<li>先把之前的老的TransactionInfo 保存起来， 并把当前的TransactionInfo 放到ThreadLocal 里面暴露出去 ,这样就便于后续的<br>
还原，提交，回滚等一系列操作.</li>
</ol>
<pre><code class="language-java">protected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, String joinpointIdentification,
			@Nullable TransactionStatus status) {

		TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification);
		if (txAttr != null) {
			// We need a transaction for this method...
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Getting transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);
			}
			// The transaction manager will flag an error if an incompatible tx already exists.
			txInfo.newTransactionStatus(status);
		}
		else {
			// The TransactionInfo.hasTransaction() method will return false. We created it only
			// to preserve the integrity of the ThreadLocal stack maintained in this class.
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;No need to create transaction for [&quot; + joinpointIdentification +
						&quot;]: This method is not transactional.&quot;);
			}
		}

		// We always bind the TransactionInfo to the thread, even if we didn't create
		// a new transaction here. This guarantees that the TransactionInfo stack
		// will be managed correctly even if no transaction was created by this aspect.
		txInfo.bindToThread();
		return txInfo;
	}
</code></pre>
<h2 id="总结">总结</h2>
<p>Spring事务管理通过AOP实现声明式事务控制的核心价值在于：</p>
<ol>
<li>
<p>关注点分离：事务逻辑由框架统一处理，业务代码更纯粹。</p>
</li>
<li>
<p>降低复杂度：开发者无需手动管理事务生命周期。</p>
</li>
<li>
<p>提升健壮性：通过统一的事务模板减少人为错误（如忘记回滚）。</p>
</li>
<li>
<p>灵活配置：支持多种事务策略，适配不同业务场景。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring常用拓展点]]></title>
        <id>https://q456qq520.github.io/post/spring-chang-yong-tuo-zhan-dian/</id>
        <link href="https://q456qq520.github.io/post/spring-chang-yong-tuo-zhan-dian/">
        </link>
        <updated>2025-05-11T03:49:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1自定义拦截器">1.自定义拦截器</h2>
<p>spring mvc拦截器跟spring拦截器相比，它里面能够获取<code>HttpServletRequest</code>和<code>HttpServletResponse</code>等web对象实例。</p>
<p>spring mvc拦截器的顶层接口是：HandlerInterceptor，包含三个方法：<br>
- preHandle 目标方法执行前执行<br>
- postHandle 目标方法执行后执行<br>
- afterCompletion 请求完成时执行</p>
<p>假如有权限认证、日志、统计的场景，可以使用该拦截器，用HandlerInterceptor接口的实现类HandlerInterceptorAdapter类。</p>
<p>第一步，继承HandlerInterceptorAdapter类定义拦截器：</p>
<pre><code class="language-java">public class AuthInterceptor extends HandlerInterceptorAdapter {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        String requestUrl = request.getRequestURI();
        if (checkAuth(requestUrl)) {
            return true;
        }

        return false;
    }

    private boolean checkAuth(String requestUrl) {
        System.out.println(&quot;===权限校验===&quot;);
        return true;
    }
}
</code></pre>
<p>第二步，将该拦截器注册到spring容器：</p>
<pre><code class="language-java">@Configuration
public class WebAuthConfig extends WebMvcConfigurerAdapter {
 
    @Bean
    public AuthInterceptor getAuthInterceptor() {
        return new AuthInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new AuthInterceptor());
    }
}
</code></pre>
<p>第三步，在请求接口时spring mvc通过该拦截器，能够自动拦截该接口，并且校验权限。</p>
<h2 id="2获取spring容器对象">2.获取Spring容器对象</h2>
<h3 id="21-beanfactoryaware接口">2.1 BeanFactoryAware接口</h3>
<pre><code class="language-java">@Service
public class PersonService implements BeanFactoryAware {
    private BeanFactory beanFactory;

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }

    public void add() {
        Person person = (Person) beanFactory.getBean(&quot;person&quot;);
    }
}
</code></pre>
<p>实现BeanFactoryAware接口，然后重写setBeanFactory方法，就能从该方法中获取到spring容器对象。</p>
<h3 id="22-applicationcontextaware接口">2.2 ApplicationContextAware接口</h3>
<pre><code class="language-java">@Service
public class PersonService2 implements ApplicationContextAware {
    private ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    public void add() {
        Person person = (Person) applicationContext.getBean(&quot;person&quot;);
    }
}
</code></pre>
<p>实现ApplicationContextAware接口，然后重写setApplicationContext方法，也能从该方法中获取到spring容器对象。</p>
<h3 id="23-applicationlistener接口">2.3 ApplicationListener接口</h3>
<pre><code class="language-java">@Service
public class PersonService3 implements ApplicationListener&lt;ContextRefreshedEvent&gt; {
    private ApplicationContext applicationContext;
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        applicationContext = event.getApplicationContext();
    }

    public void add() {
        Person person = (Person) applicationContext.getBean(&quot;person&quot;);
    }
}
</code></pre>
<p>实现接口ApplicationListener方式和实现ApplicationRunner，CommandLineRunner接口都不影响服务，都可以正常提供服务，注意监听的事件，通常是ApplicationStartedEvent 或者ApplicationReadyEvent，其他的事件可能无法注入bean。</p>
<h2 id="3全局异常处理">3.全局异常处理</h2>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public String handleException(Exception e) {
        if (e instanceof ArithmeticException) {
            return &quot;数据异常&quot;;
        }
        if (e instanceof Exception) {
            return &quot;服务器内部异常&quot;;
        }
        retur nnull;
    }
}
</code></pre>
<h2 id="4类型转换器">4.类型转换器</h2>
<p>spring目前支持3中类型转换器：</p>
<ol>
<li>Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象</li>
<li>ConverterFactory&lt;S, R&gt;：将 S 类型对象转为 R 类型及子类对象</li>
<li>GenericConverter：它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。</li>
</ol>
<h2 id="5导入配置">5.导入配置</h2>
<p>有时我们需要在某个配置类中引入其他的类，引入的类也加入到Spring容器中。 这时候可以使用注解<code>@Import</code>来完成这个功能。</p>
<h3 id="51-通用类">5.1 通用类</h3>
<pre><code class="language-java">public class A {
}

@Import(A.class)
@Configuration
public class TestConfiguration {
    
}
</code></pre>
<p>通过@Import注解引入类A，spring可以自动实例化A对象，然后在需要使用的地方通过注解@Autowired注入。</p>
<h3 id="52-配置类">5.2 配置类</h3>
<p>这种引入方式是最复杂的，因为@Configuration支持还支持多种组合注解，比如：</p>
<ul>
<li>@Import</li>
<li>@ImportResource</li>
<li>@PropertySource</li>
</ul>
<pre><code class="language-java">public class A {
}

public class B {
}

@Import(B.class)
@Configuration
public class AConfiguration {

    @Bean
    public A a() {
        return new A();
    }
}

@Import(AConfiguration.class)
@Configuration
public class TestConfiguration {
}
</code></pre>
<h3 id="53-importselector">5.3 ImportSelector</h3>
<pre><code class="language-java">public class AImportSelector implements ImportSelector {

    private static final String CLASS_NAME = &quot;com.test.A&quot;;

    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{CLASS_NAME};
    }
}

@Import(AImportSelector.class)
@Configuration
public class TestConfiguration {
}
</code></pre>
<p>这种方法的好处是selectImports方法返回的是一个数组，也就是说可以同时引入多个类。</p>
<h3 id="54-importbeandefinitionregistrar">5.4 ImportBeanDefinitionRegistrar</h3>
<pre><code class="language-java">public class AImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(A.class);
        registry.registerBeanDefinition(&quot;a&quot;, rootBeanDefinition);
    }
}

@Import(AImportBeanDefinitionRegistrar.class)
@Configuration
public class TestConfiguration {
}
</code></pre>
<p>这种方法是最灵活的。 容器注册对象可以在registerBeanDefinitions方法中获取，可以手动创建BeanDefinition注册到BeanDefinitionRegistry种。</p>
<h2 id="6-项目启动时">6. 项目启动时</h2>
<p>有时候我们需要在项目启动时定制化一些附加功能，比如：加载一些系统参数、完成初始化、预热本地缓存等，spring提供了：</p>
<ul>
<li>CommandLineRunner</li>
<li>ApplicationRunner</li>
</ul>
<pre><code class="language-java">@Component
public class TestRunner implements ApplicationRunner {

    @Autowired
    private LoadDataService loadDataService;

    public void run(ApplicationArguments args) throws Exception {
        loadDataService.load();
    }
}
</code></pre>
<pre><code class="language-java">@SpringBootApplication
public class Application implements CommandLineRunner {

    public static void main(String[] args) {
        System.out.println(&quot;--- Application main begin to start...&quot;);
        SpringApplication.run(Application.class, args);
        System.out.println(&quot;--- Application main has start...&quot;);
    }

    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;--- CommandLineRunner in Application...&quot;);
    }
}
</code></pre>
<p>实现ApplicationRunner接口，重写run方法，在该方法中实现自己定制化需求。</p>
<p>如果项目中有多个类实现了ApplicationRunner接口，他们的执行顺序要怎么指定呢？</p>
<p>答案是使用@Order(n)注解，n的值越小越先执行。当然也可以通过@Priority注解指定顺序。</p>
<h2 id="7修改beandefinition">7.修改BeanDefinition</h2>
<p>Spring IOC在实例化Bean对象之前，需要先读取Bean的相关属性，保存到BeanDefinition对象中，然后通过BeanDefinition对象，实例化Bean对象。</p>
<p>如果想修改BeanDefinition对象中的属性，该怎么办呢？</p>
<p>可以实现<code>BeanFactoryPostProcessor</code>接口。</p>
<pre><code class="language-java">@Component
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {
        DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;
        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);
        beanDefinitionBuilder.addPropertyValue(&quot;id&quot;, 100);
        //--...---
        defaultListableBeanFactory.registerBeanDefinition(&quot;user&quot;, beanDefinitionBuilder.getBeanDefinition());
    }
}
</code></pre>
<h2 id="8初始化bean前后">8.初始化Bean前后</h2>
<p>想在初始化Bean前后，实现一些自己的逻辑。这时可以实现：<code>BeanPostProcessor</code>接口。</p>
<p>该接口目前有两个方法：</p>
<ul>
<li>postProcessBeforeInitialization 该在初始化方法之前调用。</li>
<li>postProcessAfterInitialization 该方法再初始化方法之后调用。</li>
</ul>
<pre><code class="language-java">@Component
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof User) {
            ((User) bean).setUserName(&quot;name&quot;);
        }
        return bean;
    }
}
</code></pre>
<p>其实，我们经常使用的注解，比如：@Autowired、@Value、@Resource、@PostConstruct等，是通过AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor实现的。</p>
<h2 id="9初始化方法">9.初始化方法</h2>
<p>目前spring中使用比较多的初始化bean的方法有：</p>
<ul>
<li>使用@PostConstruct注解</li>
<li>实现InitializingBean接口</li>
</ul>
<h3 id="91-使用postconstruct注解">9.1 使用@PostConstruct注解</h3>
<p>在需要初始化的方法上增加@PostConstruct注解</p>
<h3 id="92-实现initializingbean接口">9.2 实现InitializingBean接口</h3>
<p>实现InitializingBean接口，重写afterPropertiesSet方法，该方法中可以完成初始化功能。</p>
<h2 id="10关闭容器前">10.关闭容器前</h2>
<pre><code class="language-java">@Service
public class DService implements InitializingBean, DisposableBean {
 
    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;DisposableBean destroy&quot;);
    }
 
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;InitializingBean afterPropertiesSet&quot;);
    }
}
</code></pre>
<h2 id="11自定义作用域">11.自定义作用域</h2>
<p>spring默认支持的Scope只有两种：</p>
<ul>
<li>singleton 单例，每次从spring容器中获取到的bean都是同一个对象。</li>
<li>prototype 多例，每次从spring容器中获取到的bean都是不同的对象。</li>
</ul>
<p>spring web又对Scope进行了扩展，增加了：</p>
<ul>
<li>RequestScope 同一次请求从spring容器中获取到的bean都是同一个对象。</li>
<li>SessionScope 同一个会话从spring容器中获取到的bean都是同一个对象。</li>
</ul>
<p>我们想在同一个线程中从spring容器获取到的bean都是同一个对象，该怎么办？</p>
<p>这就需要自定义Scope了</p>
<ol>
<li>第一步实现Scope接口</li>
<li>第二步将新定义的Scope注入到spring容器中</li>
<li>第三步使用新定义的Scope</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis 分布式锁如何自动续期？]]></title>
        <id>https://q456qq520.github.io/post/redis-fen-bu-shi-suo-ru-he-zi-dong-xu-qi/</id>
        <link href="https://q456qq520.github.io/post/redis-fen-bu-shi-suo-ru-he-zi-dong-xu-qi/">
        </link>
        <updated>2025-05-10T15:38:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="redis-实现分布式锁">Redis 实现分布式锁</h2>
<ol>
<li>指定一个 key 作为锁标记，存入 Redis 中，指定一个 唯一的用户标识作为 value。</li>
<li>当 key 不存在时才能设置值，确保同一时间只有一个客户端进程获得锁，满足互斥性特性。</li>
<li>设置一个过期时间，防止因系统异常导致没能删除这个 key，满足防死锁特性。</li>
<li>当处理完业务之后需要清除这个 key 来释放锁，清除 key 时需要校验 value 值，需要满足只有加锁的人才能释放锁 。</li>
</ol>
<h2 id="存在问题">存在问题</h2>
<p>如果这个锁的过期时间是30秒，但是业务运行超过了30秒，比如40秒，当业务运行到30秒的时候，锁过期了，其他客户端拿到了这个锁，怎么办<br>
我们可以设置一个合理的过期时间，让业务能够在这个时间内完成业务逻辑，但LockTime的设置原本就很不容易。</p>
<pre><code>LockTime设置过小，锁自动超时的概率就会增加，锁异常失效的概率也就会增加；
LockTime设置过大，万一服务出现异常无法正常释放锁，那么出现这种异常锁的时间也就越长。
</code></pre>
<p>我们只能通过经验去配置，一个可以接受的值，基本上是这个服务历史上的平均耗时再增加一定的buff。总体来说，设置一个合理的过期时间并不容易<br>
我们也可以不设置过期时间，让业务运行结束后解锁，但是如果客户端出现了异常结束了或宕机了，那么这个锁就无法解锁，变成死锁；</p>
<h2 id="自动续期">自动续期</h2>
<p>我们可以先给锁设置一个LockTime，然后启动一个守护线程，让守护线程在一段时间后，重新去设置这个锁的LockTime。</p>
<ol>
<li>和释放锁的情况一样，我们需要先判断持有锁客户端是否有变化。否则会造成无论谁持有锁，守护线程都会去重新设置锁的LockTime。</li>
<li>守护线程要在合理的时间再去重新设置锁的LockTime，否则会造成资源的浪费。不能动不动就去续。</li>
<li>如果持有锁的线程已经处理完业务了，那么守护线程也应该被销毁。不能业务运行结束了，守护者还在那里继续运行，浪费资源。</li>
</ol>
<h2 id="redisson的看门狗机制">Redisson的看门狗机制</h2>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1746891777926.jpg" alt="" loading="lazy"></figure>
<p>Redisson 锁的加锁机制如上图所示，线程去获取锁，获取成功则执行lua脚本，保存数据到redis数据库。如果获取失败: 一直通过while循环尝试获取锁(可自定义等待时间，超时后返回失败)，获取成功后，执行lua脚本，保存数据到redis数据库。Redisson提供的分布式锁是支持锁自动续期的，也就是说，如果线程仍旧没有执行完，那么redisson会自动给redis中的目标key延长超时时间，这在Redisson中称之为 Watch Dog 机制。同时 redisson 还有公平锁、读写锁的实现。</p>
<pre><code class="language-java">public void test() throws Exception{
        RLock lock = redissonClient.getLock(&quot;guodong&quot;);    // 拿锁失败时会不停的重试
        // 具有Watch Dog 自动延期机制 默认续30s 每隔30/3=10 秒续到30s
        lock.lock();
        // 尝试拿锁10s后停止重试,返回false 具有Watch Dog 自动延期机制 默认续30s
        boolean res1 = lock.tryLock(10, TimeUnit.SECONDS); 
        // 没有Watch Dog ，10s后自动释放
        lock.lock(10, TimeUnit.SECONDS);
        // 尝试拿锁100s后停止重试,返回false 没有Watch Dog ，10s后自动释放
        boolean res2 = lock.tryLock(100, 10, TimeUnit.SECONDS);
        Thread.sleep(40000L);
        lock.unlock();
    }

</code></pre>
<p>Redissson tryLock流程如下：</p>
<pre><code class="language-java">   public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
        long time = unit.toMillis(waitTime);
        long current = System.currentTimeMillis();
        long threadId = Thread.currentThread().getId();  // 1.尝试获取锁 
        Long ttl = tryAcquire(leaseTime, unit, threadId);  // lock acquired 
        if (ttl == null) {
            return true;
        }
        // 申请锁的耗时如果大于等于最大等待时间，则申请锁失败.  
        time -= System.currentTimeMillis() - current;
        if (time &lt;= 0) {
            acquireFailed(threadId);
            return false;
        }
        current = System.currentTimeMillis();
        /**  * 2.订阅锁释放事件，并通过 await 方法阻塞等待锁释放，有效的解决了无效的锁申请浪费资源的问题：  * 基于信息量，当锁被其它资源占用时，当前线程通过 Redis 的 channel 订阅锁的释放事件，一旦锁释放会发消息通知待等待的线程进行竞争.  *  * 当 this.await 返回 false，说明等待时间已经超出获取锁最大等待时间，取消订阅并返回获取锁失败.  * 当 this.await 返回 true，进入循环尝试获取锁.  */
        RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);  
        // await 方法内部是用 CountDownLatch 来实现阻塞，获取 subscribe 异步执行的结果（应用了 Netty 的 Future）  
        if (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) {
            if (!subscribeFuture.cancel(false)) {
                subscribeFuture.onComplete((res, e) -&gt; {
                    if (e == null) {
                        unsubscribe(subscribeFuture, threadId);
                    }
                });
            }
            acquireFailed(threadId);
            return false;
        }
        try {
            // 计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败.    
            time -= System.currentTimeMillis() - current;
            if (time &lt;= 0) {
                acquireFailed(threadId);
                return false;
            }
            /**    * 3.收到锁释放的信号后，在最大等待时间之内，循环一次接着一次的尝试获取锁    * 获取锁成功，则立马返回 true，    * 若在最大等待时间之内还没获取到锁，则认为获取锁失败，返回 false 结束循环    */
            while (true) {
                long currentTime = System.currentTimeMillis();        // 再次尝试获取锁    
                ttl = tryAcquire(leaseTime, unit, threadId);      // lock acquired     
                if (ttl == null) {
                    return true;
                }
                // 超过最大等待时间则返回 false 结束循环，获取锁失败     
                time -= System.currentTimeMillis() - currentTime;
                if (time &lt;= 0) {
                    acquireFailed(threadId);
                    return false;
                }
                /**      * 6.阻塞等待锁（通过信号量(共享锁)阻塞,等待解锁消息）：      */
                currentTime = System.currentTimeMillis();
                if (ttl &gt;= 0 &amp;&amp; ttl &lt; time) {
                    //如果剩余时间(ttl)小于wait time ,就在 ttl 时间内，从Entry的信号量获取一个许可(除非被中断或者一直没有可用的许可)。     
                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                } else {
                    //则就在wait time 时间范围内等待可以通过信号量      
                    getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);
                }
                // 更新剩余的等待时间(最大等待时间-已经消耗的阻塞时间)      
                time -= System.currentTimeMillis() - currentTime;
                if (time &lt;= 0) {
                    acquireFailed(threadId);
                    return false;
                }
            }
        } finally {
            // 7.无论是否获得锁,都要取消订阅解锁消息  
            unsubscribe(subscribeFuture, threadId);
        }
        return get(tryLockAsync(waitTime, leaseTime, unit));
    }
</code></pre>
<ol>
<li>尝试获取锁，返回 null 则说明加锁成功，返回一个数值，则说明已经存在该锁，ttl 为锁的剩余存活时间。</li>
<li>如果此时客户端 2 进程获取锁失败，那么使用客户端 2 的线程 id（其实本质上就是进程 id）通过 Redis 的 channel 订阅锁释放的事件。如果等待的过程中一直未等到锁的释放事件通知，当超过最大等待时间则获取锁失败，返回 false，如果等到了锁的释放事件的通知，则开始进入一个不断重试获取锁的循环。</li>
<li>循环中每次都先试着获取锁，并得到已存在的锁的剩余存活时间。如果在重试中拿到了锁，则直接返回。如果锁当前还是被占用的，那么等待释放锁的消息，具体实现使用了信号量 Semaphore 来阻塞线程，当锁释放并发布释放锁的消息后，信号量的 release() 方法会被调用，此时被信号量阻塞的等待队列中的一个线程就可以继续尝试获取锁了。</li>
<li>当锁正在被占用时，等待获取锁的进程并不是通过一个 while(true) 死循环去获取锁，而是利用了 Redis 的发布订阅机制,通过 await 方法阻塞等待锁的进程，有效的解决了无效的锁申请浪费资源的问题。</li>
</ol>
<h2 id="看门狗如何自动续期">看门狗如何自动续期</h2>
<p>Redisson看门狗机制， 只要客户端加锁成功，就会启动一个 Watch Dog。</p>
<pre><code class="language-java">  private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long leaseTime, TimeUnit unit, long threadId) {
        if (leaseTime != -1) {
            return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
        }
        RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; {
            if (e != null) {
                return;
            }        // lock acquired       
            if (ttlRemaining == null) {
                scheduleExpirationRenewal(threadId);
            }
        });
        return ttlRemainingFuture;
    }
</code></pre>
<p>⚠️同时需要注意的是：</p>
<ol>
<li>watchDog 只有在未显示指定加锁时间（leaseTime）时才会生效。（这点很重要）</li>
<li>lockWatchdogTimeout设定的时间不要太小 ，比如我之前设置的是 100毫秒，由于网络直接导致加锁完后，watchdog去延期时，这个key在redis中已经被删除了。</li>
</ol>
<h2 id="续期原理">续期原理</h2>
<p>续期原理其实就是用lua脚本，将锁的时间重置为30s</p>
<pre><code class="language-java">   private void scheduleExpirationRenewal(long threadId) {
        ExpirationEntry entry = new ExpirationEntry();
        ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);
        if (oldEntry != null) {
            oldEntry.addThreadId(threadId);
        } else {
            entry.addThreadId(threadId);
            renewExpiration();
        }
    }

    protected RFuture&lt;Boolean&gt; renewExpirationAsync(long threadId) {
        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; + &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; + &quot;return 1; &quot; + &quot;end; &quot; + &quot;return 0;&quot;, Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
    }
</code></pre>
<p>Watch Dog 机制其实就是一个后台定时任务线程，获取锁成功之后，会将持有锁的线程放入到一个 RedissonLock.EXPIRATION_RENEWAL_MAP里面，然后每隔 10 秒 （internalLockLeaseTime / 3） 检查一下，如果客户端 还持有锁 key（判断客户端是否还持有 key，其实就是遍历 EXPIRATION_RENEWAL_MAP 里面线程 id 然后根据线程 id 去 Redis 中查，如果存在就会延长 key 的时间），那么就会不断的延长锁 key 的生存时间。</p>
<p>如果服务宕机了，Watch Dog 机制线程也就没有了，此时就不会延长 key 的过期时间，到了 30s 之后就会自动过期了，其他线程就可以获取到锁。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis选举流程]]></title>
        <id>https://q456qq520.github.io/post/redis-xuan-ju-liu-cheng/</id>
        <link href="https://q456qq520.github.io/post/redis-xuan-ju-liu-cheng/">
        </link>
        <updated>2025-05-10T03:17:28.000Z</updated>
        <content type="html"><![CDATA[<p>为了实现Redis读写分离的方式实现高可靠，我们使用redis集群模式，而且为了防止主节点压力过大，假设优化成了主-从-从模式。</p>
<p><strong>思考一个问题，主节点此时挂了怎么办</strong></p>
<p>这里主从模式下涉及到的几个问题：</p>
<ol>
<li>主库真的挂了吗？</li>
<li>我们应当选择哪个从库作为主库？</li>
<li>怎样让其他从库知道新的主库信息呢？</li>
<li>中断的数据如何恢复？</li>
</ol>
<p>所以我们引入哨兵机制</p>
<h2 id="什么是哨兵机制">什么是哨兵机制？</h2>
<p>在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这几个问题。</p>
<p>Redis引入哨兵（Sentinel）机制的主要目的是为了增强其高可用性和自动故障恢复能力。在分布式系统中，特别是用作数据存储的数据库系统中，保障高可用性是至关重要的，以确保系统在面对节点故障等情况时能够继续提供服务。</p>
<p><strong>哨兵实现了什么功能呢？</strong><br>
下面是Redis官方文档的描述：</p>
<ul>
<li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li>自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li>
<li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li>
<li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<h2 id="哨兵机制的基本流程">哨兵机制的基本流程</h2>
<p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1746849001674.png" alt="" loading="lazy"></figure>
<h3 id="监控">监控</h3>
<p>Redis哨兵的监控流程涉及多个步骤，用于实时监控Redis集群中各个节点的状态并采取必要的措施来确保集群的可用性和稳定性。</p>
<ol>
<li>
<p>节点发现和配置： 哨兵通过配置文件指定要监控的主节点和从节点。启动哨兵后，它会连接到指定的节点，并获取有关其他节点的信息，形成一个初始的监控拓扑。</p>
</li>
<li>
<p>心跳检测： 哨兵会定期向监控的节点发送PING命令来检测节点是否存活。这些节点可以是主节点、从节点或其他哨兵节点。如果哨兵在一定时间内没有收到响应，它会认为节点不可用。</p>
</li>
<li>
<p>节点状态变更： 当哨兵连续多次无法连接到一个节点时，它会将该节点标记为主观下线。当多个哨兵都将节点标记为主观下线时，这个节点会被认为是客观下线。</p>
</li>
<li>
<p>故障判断和选举： 当主节点被标记为客观下线时，哨兵会执行故障判断。它会从剩余的健康主节点中选举一个作为新的主节点，并将该信息广播给其他哨兵和客户端。故障判断的逻辑考虑了多个因素，包括优先级、最近一次复制偏移量等。</p>
</li>
<li>
<p>自动故障切换： 如果主节点被标记为客观下线，哨兵会通知从节点晋升为新的主节点。同时，哨兵会更新其他从节点的配置，使其复制新的主节点。这确保了即使主节点发生故障，集群仍然可以继续提供服务。</p>
</li>
<li>
<p>监控从节点： 哨兵还会监控从节点的状态，包括从节点是否与主节点保持同步，以及从节点的复制延迟情况。如果从节点无法同步或者复制延迟过高，哨兵会将其标记为不健康。</p>
</li>
<li>
<p>节点恢复： 如果一个节点从客观下线状态恢复，哨兵会将其标记为健康，并将其重新纳入集群中。从节点恢复后，它会重新同步主节点的数据。</p>
</li>
<li>
<p>配置更新： 如果集群的拓扑发生变化，例如添加或移除节点，哨兵会自动更新配置，以便客户端能够正确连接到集群。</p>
</li>
<li>
<p>事件通知： 哨兵通过发布订阅机制向订阅者（通常是客户端）发送有关集群状态变化的消息。这使得应用程序能够根据实时的集群状态做出相应的决策。</p>
</li>
<li>
<p>持续监控： 哨兵会持续地监控集群中的节点，定期执行心跳检测、状态更新和故障判断，以确保集群的稳定运行。</p>
</li>
</ol>
<h3 id="主观下线与客观下线">主观下线与客观下线</h3>
<p>在Redis的哨兵监控机制中，有两个关键概念：<code>主观下线（Subjective Down）</code>和<code>客观下线（Objective Down）</code>。这些概念帮助哨兵判断节点的可用性和故障状态。</p>
<ol>
<li>
<p>主观下线（Subjective Down）： 主观下线是指单个哨兵节点认为一个特定的Redis节点（主节点、从节点或其他哨兵）不可用。主观下线是一种主观的判断，是基于单个哨兵节点的观察结果得出的。当一个哨兵无法连接到某个Redis节点，它会将该节点标记为主观下线。多个哨兵节点可能会对同一个节点发出主观下线标记。</p>
</li>
<li>
<p>客观下线（Objective Down）： 客观下线是指在整个哨兵集合中达成一致，认为某个特定的Redis节点不可用。客观下线是一种更客观的判断，需要多个哨兵节点共同达成一致。当多个哨兵节点都主观下线同一个Redis节点时，这个节点会被认为是客观下线。</p>
</li>
</ol>
<p>举例说明：</p>
<ul>
<li>
<p>假设有三个哨兵节点：Sentinel A、Sentinel B 和 Sentinel C，以及一个主节点 Master 和一个从节点 Slave。如果 Sentinel A 无法连接到 Master 节点，它会将 Master 标记为主观下线。同样地，如果 Sentinel B 也无法连接到 Master 节点，它也会将 Master 标记为主观下线。但这还不足以让 Master 被认为是客观下线。</p>
</li>
<li>
<p>当 Sentinel A 和 Sentinel B 都主观下线了 Master 节点，并且他们相互通信时发现了这个情况，他们就会在达成一致意见后将 Master 节点标记为客观下线。这时，整个哨兵集合达成一致，认为 Master 节点已下线。</p>
</li>
</ul>
<p>客观下线是一个更严格的判断，需要多个哨兵节点一致认为某个节点不可用，才会触发后续的故障判断和自动故障切换等动作。这种机制确保了在一个哨兵节点认为某节点下线时，不会立即触发故障切换，以避免误判造成不必要的切换。只有多个哨兵节点一致认为节点下线，才会触发后续的故障处理流程。</p>
<h3 id="如何选定新主库">如何选定新主库</h3>
<p>在Redis Sentinel模式中，当主节点（Master）发生故障导致下线后，哨兵会通过选举过程选择一个新的主节点（Master）来取代原来的主节点。选定新主库的过程如下：</p>
<ol>
<li>
<p>主观下线和客观下线判断： 当哨兵节点主观下线（单个哨兵认为不可用）一个主节点时，如果多数哨兵都主观下线了同一个主节点，那么这个主节点会被标记为客观下线（多数派共识）。</p>
</li>
<li>
<p>选举新主节点： 当一个主节点被标记为客观下线后，哨兵节点会开始选举一个新的主节点。选举过程如下：<br>
哨兵会在所有没有下线的从节点（Slaves）中选择一个作为新主节点。哨兵会选择一个延迟最小、复制偏移量最大的从节点作为新主节点。这确保了新主节点是最接近原主节点的从节点。<br>
如果没有合适的从节点，哨兵会选择一个具备最高优先级的从节点，将其升级为主节点。如果优先级相同，那么哨兵会选择一个复制偏移量最大的从节点。</p>
</li>
<li>
<p>故障转移和切换： 一旦新主节点被选定，哨兵会发起故障转移操作。旧主节点会变成新主节点的一个从节点。其他从节点会重新配置，指向新的主节点。这个过程会保证尽量不丢失数据，并且保证整个集群的高可用性。</p>
</li>
</ol>
<p>选定新主库的过程是一个由哨兵节点协同工作的流程，确保了在主节点故障的情况下，尽可能地选择一个合适的从节点作为新的主节点，实现集群的高可用性和数据完整性。</p>
<h3 id="如何配置哨兵">如何配置哨兵</h3>
<ol>
<li>哨兵配置文件： 在Redis 6.x版本中，哨兵的配置文件名称默认为redis-sentinel.conf。</li>
<li>配置变化： Redis 6.x版本引入了一些新的哨兵配置选项，以适应新的功能和改进。以下是一些常见的配置选项：<br>
sentinel monitor mymaster 127.0.0.1 6379 2   # 监控名为 &quot;mymaster&quot; 的主节点，2表示至少需要2个哨兵同意主观下线才会执行故障转移<br>
sentinel down-after-milliseconds mymaster 5000   # 主观下线判定为5秒无响应<br>
sentinel parallel-syncs mymaster 1   # 执行故障转移时同时同步的从节点数量<br>
sentinel failover-timeout mymaster 10000   # 故障转移超时时间为10秒<br>
sentinel auth-pass mymaster mypassword   # 主节点的访问密码</li>
<li>启动哨兵节点： 在Redis 6.x版本中，启动哨兵节点的命令为：<br>
redis-server /path/to/redis-sentinel.conf --sentinel</li>
<li>查看哨兵状态： 使用以下命令查看Redis 6.x版本哨兵节点的状态：<br>
redis-cli -p 26379<br>
sentinel master mymaster   # 查看主节点的信息<br>
sentinel slaves mymaster   # 查看从节点的信息<br>
sentinel sentinels mymaster   # 查看其他哨兵节点的信息</li>
</ol>
<h3 id="哨兵是如何互相发现的">哨兵是如何互相发现的？</h3>
<p>我们查看配置可以看到，我们并没有配置从节点的哨兵，我们只配置了主节点地址。</p>
<p>那么哨兵之间是如何互相发现通信的呢？</p>
<p>在Redis Sentinel（哨兵）集群中，哨兵节点之间通过发布订阅机制来互相发现和通信。这种方式使得哨兵节点能够监控主节点和从节点的状态，并进行故障检测和故障转移。</p>
<p>以下是哨兵集群如何通过发布订阅机制互相发现的工作流程：</p>
<ol>
<li>
<p>初始连接： 在启动时，每个哨兵节点会尝试连接到指定的主节点。这些哨兵节点通过配置文件中的sentinel monitor命令指定要监控的主节点信息。</p>
</li>
<li>
<p>Sentinel命令发布： 当一个哨兵节点成功连接到主节点后，它会开始定期向主节点发送PING命令，以确保主节点处于活跃状态。如果哨兵节点检测到主节点不可用，它会将一个+switch-master命令发布到频道中，通知其他哨兵节点。</p>
</li>
<li>
<p>发布订阅机制： Redis的发布订阅机制允许一个节点（发布者）向一个或多个节点（订阅者）广播消息。在哨兵集群中，每个哨兵节点都订阅了一个名为__sentinel__:hello的频道，用于接收其他哨兵节点发送的信息。<br>
<img src="https://q456qq520.github.io/post-images/1746851281045.png" alt="" loading="lazy"></p>
</li>
<li>
<p>发现其他哨兵节点： 当一个哨兵节点成功连接到主节点后，它会向__sentinel__:hello频道发布一个&quot;Hello&quot;消息，其中包含它自己的信息（如IP地址和端口号）。其他哨兵节点通过订阅这个频道，可以获取所有其他哨兵节点的信息。</p>
</li>
<li>
<p>收集哨兵信息： 每个哨兵节点通过订阅__sentinel__:hello频道，收集到其他哨兵节点的信息。这使得每个哨兵节点都知道了集群中其他哨兵节点的存在。</p>
</li>
<li>
<p>故障检测和转移： 当一个哨兵节点检测到主节点不可用时，它会通过发布+switch-master命令来通知其他哨兵节点。这个命令包含了新的主节点信息，以及在执行故障转移时需要的其他信息。其他哨兵节点收到这个命令后，会进行判断并可能发起故障转移。</p>
</li>
</ol>
<p>通过以上机制，哨兵节点可以相互发现和通信，共同监控主节点和从节点的状态，并在主节点下线时协同执行故障转移操作。这种发布订阅机制确保了哨兵集群中节点之间的实时信息传递和协作。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1746852009500.png" alt="" loading="lazy"></figure>
<h2 id="由哪个哨兵执行主从切换">由哪个哨兵执行主从切换？</h2>
<h3 id="客观下线具体判断流程">客观下线具体判断流程</h3>
<ol>
<li>
<p>故障检测： 哨兵节点定期向集群中的所有主节点和从节点发送PING命令来检测节点的可用性。如果一个哨兵节点连续一定次数没有收到节点的回复，就会将该节点标记为可能进入客观下线状态。</p>
</li>
<li>
<p>Quorum判断： 在判断一个节点是否客观下线时，需要考虑Quorum的概念。Quorum是指一个最小的投票数，当达到或超过这个投票数时，哨兵认为节点可能进入客观下线状态。Quorum的值通常设置为哨兵节点数量的一半加一。</p>
</li>
<li>
<p>投票过程： 当哨兵节点开始怀疑某个节点可能客观下线时，它会向其他哨兵节点发送一个SENTINEL is-master-down-by-addr命令，询问其他哨兵节点是否也认为该节点客观下线。其他哨兵节点会对此做出回应，根据回应的数量来判断是否达到Quorum。</p>
</li>
<li>
<p>达到Quorum： 如果收到的回应数量达到或超过Quorum，那么哨兵节点就会认为该节点进入客观下线状态。这表示集群中有足够多的哨兵都认为该节点可能下线，进而触发后续的主从切换流程。</p>
</li>
<li>
<p>执行后续操作： 一旦一个节点被认为客观下线，哨兵节点将开始执行故障转移操作，选择新的主节点并开始同步数据。这将最终导致一个新的主节点被选出，从而实现高可用性。</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1746852276842.png" alt="" loading="lazy"></figure>
<h2 id="选举leader流程">选举Leader流程</h2>
<p>Redis Sentinel（哨兵）是用于监控和管理Redis主从复制以及自动故障切换的工具。当主节点失效时，哨兵会协调选择一个从节点作为新的主节点，这涉及到选举Leader的过程。详细流程如下：</p>
<ol>
<li>监控主节点： 哨兵持续监控Redis主节点的状态，包括主节点是否在线，主从复制是否正常，以及哨兵和其他节点的通信情况。</li>
<li>检测主节点失效： 当哨兵检测到主节点失效（例如，无法响应PING命令），它会将主节点标记为“主观下线”。</li>
<li>广播主观下线状态： 一旦主观下线状态被确认，哨兵会广播该信息给其他哨兵和节点，告知主节点已经“主观下线”。</li>
<li>投票： 当其他哨兵收到关于主观下线状态的广播时，它们会进行投票来决定是否需要进行领导者选举。</li>
<li>选举Leader： 如果多个哨兵都认为主节点失效，它们将进入领导者选举过程。选举过程使用了Raft算法的变体。</li>
<li>提议投票： 在选举过程中，哨兵会提议自己作为领导者，然后请求其他哨兵投票支持。</li>
<li>投票表决： 哨兵在收到提议后会表决是否支持该提议。通常，哨兵会投票给具有最高配置版本号的提议者。</li>
<li>Quorum判断： 在选举过程中，哨兵需要收集足够数量的投票，达到Quorum（大多数）的支持才能选举成功。</li>
<li>选出新领导者： 如果某个哨兵获得足够多的投票，超过了Quorum，那么它将被选为新的领导者。</li>
<li>通知其他节点： 新选出的Leader会向其他哨兵和节点广播其成为领导者的消息，确保集群中的所有节点都知道领导者的变更。</li>
<li>故障切换： 一旦新的Leader选举完成，哨兵会协调进行故障切换，将一个从节点提升为新的主节点，使整个集群继续正常运行。</li>
<li>恢复正常状态： 一旦故障切换完成，新的主节点将开始处理客户端请求，集群会恢复到正常运行状态。</li>
</ol>
<p>需要注意的是，Redis Sentinel的选举Leader过程受到Paxos算法和Raft算法等分布式一致性算法的影响，以保证在主节点失效时能够选择合适的节点作为新的主节点，从而保持数据的一致性和高可用性。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1746852708045.png" alt="" loading="lazy"></figure>
<p>⚠️<br>
如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得 2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置 3 个哨兵实例。</p>
<p>要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值 down-after-milliseconds。</p>
<h2 id="一个-master-节点挂掉后的选举过程">一个 Master 节点挂掉后的选举过程</h2>
<p>当 slave 发现自己的 master 变为 FAIL 状态时，便尝试进行 Failover，以期成为新的 master。由于挂掉的 master 可能会有多个 slave，从而存在多个 slave 竞争成为 master 节点的过程， 其过程如下：</p>
<ol>
<li>slave 发现自己的 master 变为 FAIL。</li>
<li>将自己记录的集群 currentEpoch 加 1，并广播 FAILOVER_AUTH_REQUEST 信息</li>
<li>其他节点收到该信息，只有 master 响应，判断请求者的合法性，并发送 FAILOVER_AUTH_ACK，对每一个 epoch 只发送一次ack</li>
<li>尝试 failover 的 slave 收集 master 返回的 FAILOVER_AUTH_ACK</li>
<li>slave 收到超过半数（N/2+1） master 的 ack 后变成新 Master(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)。</li>
<li>slave 广播 Pong 消息通知其他集群节点。</li>
</ol>
<p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待 FAIL 状态在集群中传播，slave 如果立即尝试选举，其它 masters 或许尚未意识到 FAIL 状态，可能会拒绝投票</p>
<h2 id="没有哨兵如何选举">没有哨兵如何选举</h2>
<p>PING/PONG 心跳机制：<br>
每个节点每秒向其他节点发送 PING 消息，若目标节点在 cluster-node-timeout（默认 15 秒）内未回复 PONG，则被标记为 疑似下线（PFAIL）。</p>
<p>故障确认（FAIL）：<br>
若集群中 大多数主节点 在 cluster-node-timeout * 2 时间内均标记某主节点为 PFAIL，则该节点被标记为 已下线（FAIL），触发故障转移。</p>
<p>当主节点被标记为 FAIL 后，其对应的从节点将发起选举，步骤如下：</p>
<ol>
<li>
<p>资格检查：<br>
从节点必须与主节点的数据同步状态正常（复制偏移量最新）。<br>
主节点下线时间需超过 cluster-node-timeout * cluster-slave-validity-factor（默认 10，即 150 秒）。</p>
</li>
<li>
<p>选举触发：<br>
从节点向集群广播 FAILOVER_AUTH_REQUEST 消息，请求其他主节点投票。</p>
</li>
<li>
<p>投票机制：<br>
每个主节点在 cluster-node-timeout * 2 时间内仅能投一票。<br>
从节点需获得 多数主节点（N/2 + 1） 的投票（三主集群需至少 2 票）。<br>
如果票数一致，选取复制量最大的或者启动id最大的</p>
</li>
<li>
<p>切换主节点：<br>
获得多数票的从节点升级为新主节点，接管原主节点的哈希槽。<br>
其他从节点重新指向新主节点进行复制。</p>
</li>
</ol>
]]></content>
    </entry>
</feed>