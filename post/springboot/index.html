
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> 
<meta HTTP-EQUIV="expires" CONTENT="0"> 
<title>SpringBoot启动流程 | LIKECAT</title>	

<link rel="stylesheet" href="https://q456qq520.github.io/styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

        if (thehour<07)

            display = "https://q456qq520.github.io/media/css/night.css";

       else if (thehour>18)

            display = "https://q456qq520.github.io/media/css/night.css";   

        else if (thehour>07)
           
            display = "https://q456qq520.github.io/media/css/day.css";

        else if (thehour<18)

            display = "https://q456qq520.github.io/media/css/day.css";
      

var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://fonts.googleapis.com/css?family=Dancing+Script|Noto+Sans+SC:300|Montserrat&display=swap" rel="stylesheet">
<link href="https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<script type='text/javascript' src='https://q456qq520.github.io/media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>


 	
</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">
        
			
		<header id="header" class="site-header" 
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://q456qq520.github.io" rel="home">LIKECAT</a></h1>
										
					<h2 class="site-description">一条小咸鱼</h2>
										
							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 
     			
<li>
	 
	<a  href="/"> 首页</a></li>
	
    
     			
<li>
	 
	<a  href="/archives"> 归档</a></li>
	
    
     			
<li>
	 
	<a  href="/tags"> 标签</a></li>
	
    
     			
<li>
	 
	<a  href="/post/about"> 关于</a></li>
	
    
     			
<li>
	 
	<a  href="https://q456qq520.github.io/tag/CH4G4OVER/"> 设计模式</a></li>
	
    
     			
<li>
	 
	<a  href="https://q456qq520.github.io/tag/fenbushi/"> 分布式</a></li>
	
    

</ul>
</li>		
		
</ul>				</div>
			</nav>
						<div class="jingge">


    

    

    

    

    

    

    

    

    

    

    

    
        </header>

		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">
				
<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">

	
	                      
		<div class="entry-content">
			<h1 class="wow swing entry-title">SpringBoot启动流程</h1>
<div class="entry-meta">
<div class="wow bounce">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2023-02-09 10:35:00" itemprop="datePublished" pubdate="">2023-02-09</time></i>
	          </div>
			
</span>
													 
		</div>
                  
			<div class="wow slideInLeft entry-summary song">
				<h2 id="1-springboot启动流程">1 Springboot启动流程</h2>
<!-- more -->
<h3 id="11-springapplication创建">1.1 SpringApplication创建</h3>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1675939261552.png" alt="" loading="lazy"></figure>
<h4 id="111-入口">1.1.1 入口</h4>
<pre><code class="language-java">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {
    this.sources = new LinkedHashSet();
    this.bannerMode = Mode.CONSOLE;
    this.logStartupInfo = true;
    this.addCommandLineProperties = true;
    this.headless = true;
    this.registerShutdownHook = true;
    this.additionalProfiles = new HashSet();
    this.isCustomEnvironment = false;
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
    // 将 Main Class 设置为自己的元素
    this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
    // 检查当先的 app 类型
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    // 先从 Spring.factories 文件中加载 ApplicationContextInitializer 类信息。
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    // 先从 Spring.factories 文件中加载 ApplicationListener 类信息。
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    // 获取 main class 信息，并设置到本地属性中
    this.mainApplicationClass = deduceMainApplicationClass();
}
</code></pre>
<h4 id="112-检查应用类型">1.1.2 检查应用类型</h4>
<p>在将Main class 设置primarySources 后，调用了 WebApplicationType.deduceFromClasspath() 方法，该方法是为了检查当前的应用类型，并设置给 webApplicationType。</p>
<pre><code class="language-java">static WebApplicationType deduceFromClasspath() {
        if (ClassUtils.isPresent(&quot;org.springframework.web.reactive.DispatcherHandler&quot;, (ClassLoader)null) &amp;&amp; !ClassUtils.isPresent(&quot;org.springframework.web.servlet.DispatcherServlet&quot;, (ClassLoader)null) &amp;&amp; !ClassUtils.isPresent(&quot;org.glassfish.jersey.servlet.ServletContainer&quot;, (ClassLoader)null)) {
            return REACTIVE;
        } else {
            String[] var0 = SERVLET_INDICATOR_CLASSES;
            int var1 = var0.length;

            for(int var2 = 0; var2 &lt; var1; ++var2) {
                String className = var0[var2];
                if (!ClassUtils.isPresent(className, (ClassLoader)null)) {
                    return NONE;
                }
            }
        }
    }
</code></pre>
<p>这里主要是通过类加载器判断是否存在 <code>REACTIVE</code>相关的类信息，假如有就代表是一个 REACTIVE 的应用，假如不是就检查是否存在<code>Servelt</code>和 <code>ConfigurableWebApplicationContext</code> ，假如都没有，就代表应用为非 WEB 类应用，返回 <code>NONE</code>，默认返回<code>SERVLET</code>类型</p>
<h4 id="113-设置初始化器-initializer">1.1.3 设置初始化器 Initializer</h4>
<p>我们设置完成应用类型后，就寻找所有的 Initializer 实现类，并设置到SpringApplication 的 Initializers 中。</p>
<p>容器刷新之前调用此类的initialize方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。</p>
<p>这里先说一下 getSpringFactoriesInstances 方法，我们知道在我们使用 SpringBoot 程序中，会经常在 META-INF/spring.factories 目录下看到一些EnableAutoConfiguration，来出发 config 类注入到容器中，我们知道一般一个 config 类要想被 SpringBoot 扫描到需要使用 @CompnentScan 来扫描具体的路径，对于 jar 包来说这无疑是非常不方便的，所以 SpringBoot 提供了另外一种方式来实现，就是使用 spring.factories。但是要实现，得先进行加载，过程如下：</p>
<pre><code class="language-java">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) {
    ClassLoader classLoader = getClassLoader();
    // Use names and ensure unique to protect against duplicates
    Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
    AnnotationAwareOrderComparator.sort(instances);
    return instances;
}
</code></pre>
<p>我们先来看一下传入参数，这里需要注意的是 args，这个是初始化对应 type 的时候传入的构造参数，我们先看一下 SpringFactoriesLoader#loadFactoryNames 方法：</p>
<pre><code class="language-java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {
    String factoryClassName = factoryClass.getName();
    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
}

private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {
    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);
    if (result != null) {
        return result;
    } else {
        try {
            //加载配置文件
            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);
            LinkedMultiValueMap result = new LinkedMultiValueMap();

            while(urls.hasMoreElements()) {
                URL url = (URL)urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                Iterator var6 = properties.entrySet().iterator();

                while(var6.hasNext()) {
                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();
                    List&lt;String&gt; factoryClassNames = Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue()));
                    result.addAll((String)entry.getKey(), factoryClassNames);
                }
            }

            cache.put(classLoader, result);
            return result;
        } catch (IOException var9) {
            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var9);
        }
    }
}
</code></pre>
<p>首先是会先检查缓存，假如缓存中存在就直接返回，假如没有就调用 classLoader#getResources 方法，传入META-INF/spring.factories，即获取所有 jar 包下的对应文件，并封装成 UrlResource ，然后使用 PropertiesLoaderUtils 将这些信息读取成一个对一对的 properties，我们观察一下 spring.factories 都是按 properties 格式排版的，假如有多个就用逗号隔开，所以这里还需要将逗号的多个类分隔开来，并加到 result 中，由于 result 是一个 LinkedMultiValueMap 类型，支持多个值插入，最后放回缓存中。最终完成加载 META-INF/spring.factories 中的配置。</p>
<p>在获取到所有的 Initializer 后接下来是调用 createSpringFactoriesInstances 方法进行初始化。</p>
<pre><code class="language-java">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) {
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    Set&lt;String&gt; names = new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    List&lt;T&gt; instances = this.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
    AnnotationAwareOrderComparator.sort(instances);
    return instances;
}
</code></pre>
<pre><code class="language-java">private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names) {
    List&lt;T&gt; instances = new ArrayList(names.size());
    Iterator var7 = names.iterator();
  // 这里包括很多初始化类信息，包括 apollo , shardingShepre 都是在这里初始化。
    while(var7.hasNext()) {
        String name = (String)var7.next();

        try {
            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);
            Assert.isAssignable(type, instanceClass);
            Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);
            T instance = BeanUtils.instantiateClass(constructor, args);
            instances.add(instance);
        } catch (Throwable var12) {
            throw new IllegalArgumentException(&quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, var12);
        }
    }
    return instances;
}
</code></pre>
<p>这里的 names 就是我们上面通过类加载器加载到的类名，到这里会先通过反射生成 class 对象，然后判断该类是否继承与 ApplicationContextInitializer ，最后通过反射的方式获取这个类的构造方法，并调用该构造方法，传入已经定义好的构造参数，对于 ApplicationContextInitializer 是无参的构造方法，然后初始化实例并返回，回到原来的方法，这里会先对所有的 ApplicationContextInitializer 进行排序，调用 <code>AnnotationAwareOrderComparator#sort(instances)</code>方法，这里就是根据 @Order 中的顺序进行排序。</p>
<h4 id="114-设置监听器">1.1.4 设置监听器</h4>
<p>接下来是设置 ApplicationListener，我们跟进去就会发现这里和上面获取 ApplicationContextInitializer 的方法如出一辙。这里不过多介绍。</p>
<h3 id="12-springapplication-run">1.2 SpringApplication run()</h3>
<p>在完成 SpringApplication 对象的初始化后，我们进入了他的 run 方法，这个方法几乎涵盖了 SpringBoot 生命周期的所有内容，主要分为九个步骤。</p>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
    // 启动计时器计算初始化完成耗时
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    ConfigurableApplicationContext context = null;
    configureHeadlessProperty();
    // 第一步：获取 SpringApplicationRunListener， 然后调用他的 staring 方法启动监听器。
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting();
    try {
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        // 第二步:根据 SpringApplicationRunListeners以及参数来准备环境
        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
        configureIgnoreBeanInfo(environment);
        // 准备打印 Banner
        Banner printedBanner = printBanner(environment);
        // 第三步：创建 Spring 容器
        context = createApplicationContext();
        // 第四步： Spring 容器的前置处理
        prepareContext(context, environment, listeners, applicationArguments, printedBanner);
        // 第五步：刷新 Spring 容器
        refreshContext(context);
        // 第六步： Spring 容器的后置处理器
        afterRefresh(context, applicationArguments);
        // 停止计时
        stopWatch.stop();
        if (this.logStartupInfo) {
            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
        }
        //第七步：通知所有 listener 结束启动
        listeners.started(context);
        //第八步：调用所有 runner 的 run 方法
        callRunners(context, applicationArguments);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, listeners);
        throw new IllegalStateException(ex);
    }
    //第九步：通知所有 listener running 事件
    try {
        listeners.running(context);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, null);
        throw new IllegalStateException(ex);
    }
    return context;
}
</code></pre>
<h4 id="121-获取-springapplicationrunlistener">1.2.1 获取 SpringApplicationRunListener</h4>
<pre><code class="language-java">private SpringApplicationRunListeners getRunListeners(String[] args) {
    Class&lt;?&gt;[] types = new Class[]{SpringApplication.class, String[].class};
    return new SpringApplicationRunListeners(logger, this.getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));
}
</code></pre>
<p>这里和上面获取 initializer 和 listener 的方式基本一致，都是通过 getSpringFactoriesInstances, 最终只找到一个类就是：org.springframework.boot.context.event.EventPublishingRunListener ，然后调用其构造方法并传入产生 args , 和 SpringApplication 本身:</p>
<pre><code class="language-java">public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered {

   private final SpringApplication application;

   private final String[] args;

   private final SimpleApplicationEventMulticaster initialMulticaster;

   public EventPublishingRunListener(SpringApplication application, String[] args) {
       this.application = application;
       this.args = args;
       this.initialMulticaster = new SimpleApplicationEventMulticaster();
       for (ApplicationListener&lt;?&gt; listener : application.getListeners()) {
           this.initialMulticaster.addApplicationListener(listener);
       }
   }
}
</code></pre>
<p>我们先看一下构造函数，首先将我们获取到的ApplicationListener 集合添加到<code>initialMulticaster</code>中， 最后都是通过操作<code>SimpleApplicationEventMulticaster</code> 来进行广播，我，他继承于 <code>AbstractApplicationEventMulticaster</code>。</p>
<h4 id="122-环境准备">1.2.2 环境准备</h4>
<pre><code class="language-java">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
        ApplicationArguments applicationArguments) {
    // 根据类型创建对应的 environment
    ConfigurableEnvironment environment = getOrCreateEnvironment();
    // 配置 environment 信息
    configureEnvironment(environment, applicationArguments.getSourceArgs());
    ConfigurationPropertySources.attach(environment);
    // 发送 prepareEnviroment 事件
    listeners.environmentPrepared(environment);
    bindToSpringApplication(environment);
    if (!this.isCustomEnvironment) {
        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
                deduceEnvironmentClass());
    }
    ConfigurationPropertySources.attach(environment);
    return environment;
}
</code></pre>
<p>首先是调用 <code>getOrCreateEnvironment</code>方法来创建<code>environment</code>，我们跟进去可以发现这里是根据我们上面设置的环境的类型来进行选择的。</p>
<pre><code class="language-java">private ConfigurableEnvironment getOrCreateEnvironment() {
    if (this.environment != null) {
        return this.environment;
    } else {
        switch(this.webApplicationType) {
        case SERVLET:
            return new StandardServletEnvironment();
        case REACTIVE:
            return new StandardReactiveWebEnvironment();
        default:
            return new StandardEnvironment();
        }
    }
}
</code></pre>
<p>在创建完成 Environment 后，接下来就到了调用 configureEnvironment 方法：</p>
<pre><code class="language-java">protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) {
    if (this.addConversionService) {
        ConversionService conversionService = ApplicationConversionService.getSharedInstance();
        environment.setConversionService((ConfigurableConversionService) conversionService);
    }
    // 配置PropertySources
    configurePropertySources(environment, args);
    // 配置Profiles
    configureProfiles(environment, args);
}
</code></pre>
<p>我们先看一下 <code>configurePropertySources</code> 方法，这里主要分两部分，首先是查询当前是否存在 <code>defaultProperties</code> ，假如不为空就会添加到 <code>environment</code>的<code>propertySources</code>中，接着是处理命令行参数，将命令行参数作为一个<code>CompositePropertySource</code>或者<code>SimpleCommandLinePropertySource</code>添加到 <code>environment</code>的<code>propertySources</code>里面，</p>
<pre><code class="language-java">protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) {
    MutablePropertySources sources = environment.getPropertySources();
    if (this.defaultProperties != null &amp;&amp; !this.defaultProperties.isEmpty()) {
        sources.addLast(new MapPropertySource(&quot;defaultProperties&quot;, this.defaultProperties));
    }
    if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) {
        String name = &quot;commandLineArgs&quot;;
        if (sources.contains(name)) {
            PropertySource&lt;?&gt; source = sources.get(name);
            CompositePropertySource composite = new CompositePropertySource(name);
            composite.addPropertySource(new SimpleCommandLinePropertySource(&quot;springApplicationCommandLineArgs&quot;, args));
            composite.addPropertySource(source);
            sources.replace(name, composite);
        } else {
            sources.addFirst(new SimpleCommandLinePropertySource(args));
        }
    }
}
</code></pre>
<p>接着调用 <code>ConfigurationPropertySources#attach</code>方法,他会先去 environment 中查找 configurationProperties , 假如寻找到了，先检查 configurationProperties 和当前 environment 是否匹配，假如不相等，就先去除，最后添加 configurationProperties 并将其 sources 属性设置进去。</p>
<pre><code class="language-java">public static void attach(Environment environment) {
    Assert.isInstanceOf(ConfigurableEnvironment.class, environment);
    MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();
    PropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);
    if (attached != null &amp;&amp; attached.getSource() != sources) {
        sources.remove(ATTACHED_PROPERTY_SOURCE_NAME);
        attached = null;
    }
    if (attached == null) {
        sources.addFirst(new ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME,
                new SpringConfigurationPropertySources(sources)));
    }
}
</code></pre>
<p>下一步是通知观察者，发送<code>ApplicationEnvironmentPreparedEvent</code>事件，调用的是 <code>SpringApplicationRunListeners#environmentPrepared</code>方法。会唤醒<code>ConfigFileApplicationListener</code>监听器执行相应逻辑。最主要的加载方法load中，首先会获取到配置文件的搜索路径。如果设置了<code>spring.config.location</code>则会去指定目录下搜索，否则就去默认的搜索目录下<code>classpath:/,classpath:/config/,file:./,file:./config/</code>。</p>
<p>拿到所有待搜索目录后，遍历每个目录获取需要加载的配置文件。如果指定了spring.config.name，则加载指定名称的配置文件。否则使用默认的application作为配置文件的前缀名。然后，会利用<code>PropertiesPropertySourceLoader</code>和<code>YamlPropertySourceLoader</code>加载后缀名为<code>properties</code>、<code>xml</code>、<code>yml</code>或者<code>yaml</code>的文件。</p>
<p>拿到文件目录和文件名后，就可以去对应的路径下加载配置文件了。核心的过程是利用输入流读取配置文件，并根据读到的分隔符进行判断来切分配置文件的key和value。并将内容以key-value键值对的形式封装成一个<code>OriginTrackedMapPropertySource</code>，最后再将一个个配置文件封装成<code>Document</code>。最后遍历这些<code>Documents</code>，调用consumer.accept(profile, document));供上层调用访问。</p>
<p>由于监听器的真正执行是通过调用<code>listener.onApplicationEvent(event)</code>方法来执行的，因此我们从该方法开始分析：</p>
<pre><code class="language-java">public void onApplicationEvent(ApplicationEvent event) {
    if (event instanceof ApplicationEnvironmentPreparedEvent) {
        this.onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent)event);
    }

    if (event instanceof ApplicationPreparedEvent) {
        this.onApplicationPreparedEvent(event);
    }

}

private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {
    List&lt;EnvironmentPostProcessor&gt; postProcessors = this.loadPostProcessors();
    postProcessors.add(this);
    AnnotationAwareOrderComparator.sort(postProcessors);
    Iterator var3 = postProcessors.iterator();

    while(var3.hasNext()) {
        EnvironmentPostProcessor postProcessor = (EnvironmentPostProcessor)var3.next();
        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());
    }

}
</code></pre>
<p>这里loadPostProcessors方法就是从spring.factories中加载EnvironmentPostProcessor接口对应的实现类，并把当前对象也添加进去(因为ConfigFileApplicationListener也实现了EnvironmentPostProcessor接口，所以可以添加)。因此在下方遍历时，会访问该类下的postProcessEnvironment方法，从该方法中进入：</p>
<pre><code class="language-java">public void load() {
    this.profiles = new LinkedList();
    this.processedProfiles = new LinkedList();
    this.activatedProfiles = false;
    this.loaded = new LinkedHashMap();
    this.initializeProfiles();

    while(!this.profiles.isEmpty()) {
        ConfigFileApplicationListener.Profile profile = (ConfigFileApplicationListener.Profile)this.profiles.poll();
        if (profile != null &amp;&amp; !profile.isDefaultProfile()) {
            this.addProfileToEnvironment(profile.getName());
        }

        this.load(profile, this::getPositiveProfileFilter, this.addToLoaded(MutablePropertySources::addLast, false));
        this.processedProfiles.add(profile);
    }

    this.resetEnvironmentProfiles(this.processedProfiles);
    this.load((ConfigFileApplicationListener.Profile)null, this::getNegativeProfileFilter, this.addToLoaded(MutablePropertySources::addFirst, true));
    this.addLoadedPropertySources();
}
</code></pre>
<p>其中 apply 方法主要是加载 defaultProperties ，假如已经存在，就进行替换，而替换的目标 PropertySource 就是 load这里最后的一个 consumer 函数加载出来的，这里列一下主要做的事情：<br>
1、加载系统中设置的所有的 Profile 。<br>
2、遍历所有的 Profile，假如是默认的 Profile， 就将这个 Profile 加到 environment 中。<br>
3、调用load 方法，加载配置，我们深入看一下这个方法：</p>
<pre><code class="language-java">private void load(ConfigFileApplicationListener.Profile profile, ConfigFileApplicationListener.DocumentFilterFactory filterFactory, ConfigFileApplicationListener.DocumentConsumer consumer) {
        this.getSearchLocations().forEach((location) -&gt; {
            boolean isFolder = location.endsWith(&quot;/&quot;);
            Set&lt;String&gt; names = isFolder ? this.getSearchNames() : ConfigFileApplicationListener.NO_SEARCH_NAMES;
            names.forEach((name) -&gt; {
                this.load(location, name, profile, filterFactory, consumer);
            });
        });
    }
</code></pre>
<p>首先调用了getSearchLocations方法</p>
<pre><code class="language-java">private Set&lt;String&gt; getSearchLocations() {
    if (this.environment.containsProperty(&quot;spring.config.location&quot;)) {
        return this.getSearchLocations(&quot;spring.config.location&quot;);
    } else {
        Set&lt;String&gt; locations = this.getSearchLocations(&quot;spring.config.additional-location&quot;);
        locations.addAll(this.asResolvedSet(ConfigFileApplicationListener.this.searchLocations, &quot;classpath:/,classpath:/config/,file:./,file:./config/&quot;));
        return locations;
    }
}
</code></pre>
<p>该方法用于获取配置文件的路径，如果利用spring.config.location指定了配置文件路径，则根据该路径进行加载。否则则根据默认路径加载，而默认路径就是我们最初提到的那四个路径。接下来，再深入asResolvedSet方法内部分析一下:</p>
<pre><code class="language-java">private Set&lt;String&gt; asResolvedSet(String value, String fallback) {
        List&lt;String&gt; list = Arrays.asList(StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(value != null ? this.environment.resolvePlaceholders(value) : fallback)));
        Collections.reverse(list);
        return new LinkedHashSet(list);
    }
</code></pre>
<p>这里的value表示ConfigFileApplicationListener初始化时设置的搜索路径，而fallback就是<code>DEFAULT_SEARCH_LOCATIONS</code>默认搜索路径<code>。StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray()）</code>方法就是以逗号作为分隔符对&quot;<code>classpath:/,classpath:/config/,file:./,file:./config/</code>&quot;进行切割，并返回一个字符数组。而这里的<code>Collections.reverse(list)</code>;之后，就是体现优先级的时候了，先被扫描到的配置文件会优先生效。</p>
<p>这里我们拿到搜索路径之后，load方法里对每个搜索路径进行遍历，首先调用了getSearchNames()方法</p>
<pre><code class="language-java">private Set&lt;String&gt; getSearchNames() {
    if (this.environment.containsProperty(&quot;spring.config.name&quot;)) {
        String property = this.environment.getProperty(&quot;spring.config.name&quot;);
        return this.asResolvedSet(property, (String)null);
    } else {
        return this.asResolvedSet(ConfigFileApplicationListener.this.names, &quot;application&quot;);
    }
}
</code></pre>
<p>该方法中如果我们通过spring.config.name设置了要检索的配置文件前缀，会按设置进行加载，否则加载默认的配置文件前缀即application。<br>
拿到所有需要加载的配置文件前缀后，则遍历每个需要加载的配置文件，进行搜索加载，加载过程如下：</p>
<pre><code class="language-java">private void load(String location, String name, ConfigFileApplicationListener.Profile profile, ConfigFileApplicationListener.DocumentFilterFactory filterFactory, ConfigFileApplicationListener.DocumentConsumer consumer) {
     //下面的if分支默认是不走的，除非我们设置spring.config.name为空或者null
    //或者是spring.config.location指定了配置文件的完整路径，也就是入参location的值
    if (!StringUtils.hasText(name)) {
        Iterator var6 = this.propertySourceLoaders.iterator();

        while(var6.hasNext()) {
            PropertySourceLoader loader = (PropertySourceLoader)var6.next();
            //检查配置文件名的后缀是否符合要求，
            //文件名后缀要求是properties、xml、yml或者yaml
            if (this.canLoadFileExtension(loader, location)) {
                this.load(loader, location, profile, filterFactory.getDocumentFilter(profile), consumer);
                return;
            }
        }
    }

    Set&lt;String&gt; processed = new HashSet();
    Iterator var14 = this.propertySourceLoaders.iterator();
    //propertySourceLoaders属性是在Load类的构造方法中设置的，可以加载文件后缀为properties、xml、yml或者yaml的文件
    while(var14.hasNext()) {
        PropertySourceLoader loaderx = (PropertySourceLoader)var14.next();
        String[] var9 = loaderx.getFileExtensions();
        int var10 = var9.length;

        for(int var11 = 0; var11 &lt; var10; ++var11) {
            String fileExtension = var9[var11];
            if (processed.add(fileExtension)) {
                this.loadForFileExtension(loaderx, location + name, &quot;.&quot; + fileExtension, profile, filterFactory, consumer);
            }
        }
    }

}
</code></pre>
<p><code>this.propertySourceLoaders</code>既包含了上面提到的两个<code>PropertiesPropertySourceLoader</code>和<code>YamlPropertySourceLoader</code>，PropertiesPropertySourceLoader可以加载文件扩展名为properties和xml的文件，YamlPropertySourceLoader可以加载文件扩展名为yml和yaml的文件。获取到搜索路径、文件名和扩展名后，就可以到对应的路径下去检索配置文件并加载了。</p>
<pre><code class="language-java">private void loadForFileExtension(PropertySourceLoader loader, String prefix, String fileExtension, ConfigFileApplicationListener.Profile profile, ConfigFileApplicationListener.DocumentFilterFactory filterFactory, ConfigFileApplicationListener.DocumentConsumer consumer) {
    ConfigFileApplicationListener.DocumentFilter defaultFilter = filterFactory.getDocumentFilter((ConfigFileApplicationListener.Profile)null);
    ConfigFileApplicationListener.DocumentFilter profileFilter = filterFactory.getDocumentFilter(profile);
    if (profile != null) {
         //在文件名上加上profile值，之后调用load方法加载配置文件，入参带有过滤器，可以防止重复加载
        String profileSpecificFile = prefix + &quot;-&quot; + profile + fileExtension;
        this.load(loader, profileSpecificFile, profile, defaultFilter, consumer);
        this.load(loader, profileSpecificFile, profile, profileFilter, consumer);
        Iterator var10 = this.processedProfiles.iterator();

        while(var10.hasNext()) {
            ConfigFileApplicationListener.Profile processedProfile = (ConfigFileApplicationListener.Profile)var10.next();
            if (processedProfile != null) {
                String previouslyLoaded = prefix + &quot;-&quot; + processedProfile + fileExtension;
                this.load(loader, previouslyLoaded, profile, profileFilter, consumer);
            }
        }
    }
    //加载不带profile的配置文件
    this.load(loader, prefix + fileExtension, profile, profileFilter, consumer);
}
</code></pre>
<pre><code class="language-java">// 加载配置文件
private void load(PropertySourceLoader loader, String location, Profile profile, DocumentFilter filter,
                DocumentConsumer consumer) {
    try {
               //调用Resource类到指定路径加载配置文件
               // location比如file:./config/application.properties
        Resource resource = this.resourceLoader.getResource(location);
        if (resource == null || !resource.exists()) {
            if (this.logger.isTraceEnabled()) {
                StringBuilder description = getDescription(&quot;Skipped missing config &quot;, location, resource,
                        profile);
                this.logger.trace(description);
            }
            return;
        }
        if (!StringUtils.hasText(StringUtils.getFilenameExtension(resource.getFilename()))) {
            if (this.logger.isTraceEnabled()) {
                StringBuilder description = getDescription(&quot;Skipped empty config extension &quot;, location,
                        resource, profile);
                this.logger.trace(description);
            }
            return;
        }
        String name = &quot;applicationConfig: [&quot; + location + &quot;]&quot;;
               //读取配置文件内容，将其封装到Document类中，解析文件内容主要是找到
        //配置spring.profiles.active和spring.profiles.include的值
        List&lt;Document&gt; documents = loadDocuments(loader, name, resource);
               //如果文件没有配置数据，则跳过
        if (CollectionUtils.isEmpty(documents)) {
            if (this.logger.isTraceEnabled()) {
                StringBuilder description = getDescription(&quot;Skipped unloaded config &quot;, location, resource,
                        profile);
                this.logger.trace(description);
            }
            return;
        }
        List&lt;Document&gt; loaded = new ArrayList&lt;&gt;();
               //遍历配置文件，处理里面配置的profile
        for (Document document : documents) {
            if (filter.match(document)) {
                       //将配置文件中配置的spring.profiles.active和
                   //spring.profiles.include的值写入集合profiles中，
                   //上层调用方法会读取profiles集合中的值，并读取对应的配置文件
                   //addActiveProfiles方法只在第一次调用时会起作用，里面有判断
                addActiveProfiles(document.getActiveProfiles());
                addIncludedProfiles(document.getIncludeProfiles());
                loaded.add(document);
            }
        }
        Collections.reverse(loaded);
        if (!loaded.isEmpty()) {
            loaded.forEach((document) -&gt; consumer.accept(profile, document));
            if (this.logger.isDebugEnabled()) {
                StringBuilder description = getDescription(&quot;Loaded config file &quot;, location, resource, profile);
                this.logger.debug(description);
            }
        }
    }
    catch (Exception ex) {
        throw new IllegalStateException(&quot;Failed to load property source from location '&quot; + location + &quot;'&quot;, ex);
    }
}
</code></pre>
<p>该方法首先调用<code>this.resourceLoader.getResource(location)</code>;用来判断<code>location路径</code>下的文件是否存在，如果存在，会调用loadDocuments方法对配置文件进行加载：</p>
<pre><code class="language-java">private List&lt;ConfigFileApplicationListener.Document&gt; loadDocuments(PropertySourceLoader loader, String name, Resource resource) throws IOException {
    ConfigFileApplicationListener.DocumentsCacheKey cacheKey = new ConfigFileApplicationListener.DocumentsCacheKey(loader, resource);
    List&lt;ConfigFileApplicationListener.Document&gt; documents = (List)this.loadDocumentsCache.get(cacheKey);
    if (documents == null) {
        List&lt;PropertySource&lt;?&gt;&gt; loaded = loader.load(name, resource);
        documents = this.asDocuments(loaded);
        this.loadDocumentsCache.put(cacheKey, documents);
    }

    return documents;
}
</code></pre>
<p>再内部根据不同的<code>PropertySourceLoader</code>调用相应的load方法和<code>loadProperties(resource)</code>方法</p>
<pre><code class="language-java">public List&lt;PropertySource&lt;?&gt;&gt; load(String name, Resource resource) throws IOException {
    Map&lt;String, ?&gt; properties = this.loadProperties(resource);
    return properties.isEmpty() ? Collections.emptyList() : Collections.singletonList(new OriginTrackedMapPropertySource(name, properties));
}

private Map&lt;String, ?&gt; loadProperties(Resource resource) throws IOException {
    String filename = resource.getFilename();
    return (Map)(filename != null &amp;&amp; filename.endsWith(&quot;.xml&quot;) ? PropertiesLoaderUtils.loadProperties(resource) : (new OriginTrackedPropertiesLoader(resource)).load());
}
</code></pre>
<p>由于我们目前的配置文件只有application.properties，也就是文件结尾不是以xml作为扩展名。因此loadProperties方法会进入到<code>new OriginTrackedPropertiesLoader</code>。因此再进入到<code>new OriginTrackedPropertiesLoader(resource).load()</code>;。</p>
<pre><code class="language-java">public Map&lt;String, OriginTrackedValue&gt; load(boolean expandLists) throws IOException {
    OriginTrackedPropertiesLoader.CharacterReader reader = new OriginTrackedPropertiesLoader.CharacterReader(this.resource);
    Throwable var3 = null;

    try {
        Map&lt;String, OriginTrackedValue&gt; result = new LinkedHashMap();
        StringBuilder buffer = new StringBuilder();

        while(reader.read()) {
            String key = this.loadKey(buffer, reader).trim();
            if (expandLists &amp;&amp; key.endsWith(&quot;[]&quot;)) {
                key = key.substring(0, key.length() - 2);
                int var19 = 0;

                while(true) {
                    OriginTrackedValue value = this.loadValue(buffer, reader, true);
                    this.put(result, key + &quot;[&quot; + var19++ + &quot;]&quot;, value);
                    if (!reader.isEndOfLine()) {
                        reader.read();
                    }

                    if (reader.isEndOfLine()) {
                        break;
                    }
                }
            } else {
                OriginTrackedValue value = this.loadValue(buffer, reader, false);
                this.put(result, key, value);
            }
        }

        LinkedHashMap var18 = result;
        return var18;
    } catch (Throwable var16) {
        var3 = var16;
        throw var16;
    } 
}
</code></pre>
<pre><code class="language-java">CharacterReader(Resource resource) throws IOException {
            this.reader = new LineNumberReader(new InputStreamReader(resource.getInputStream(), StandardCharsets.ISO_8859_1));
        }
</code></pre>
<pre><code class="language-java">private String loadKey(StringBuilder buffer, OriginTrackedPropertiesLoader.CharacterReader reader) throws IOException {
    buffer.setLength(0);
    boolean previousWhitespace = false;

    while(!reader.isEndOfLine()) {
        // 判断读取到的字节是否为'=' 或者为 ':'，如果是则直接返回读取都的buffer内容
        if (reader.isPropertyDelimiter()) {
            reader.read();
            return buffer.toString();
        }

        if (!reader.isWhiteSpace() &amp;&amp; previousWhitespace) {
            return buffer.toString();
        }

        previousWhitespace = reader.isWhiteSpace();
        buffer.append(reader.getCharacter());
        reader.read();
    }

    return buffer.toString();
}

private OriginTrackedValue loadValue(StringBuilder buffer, OriginTrackedPropertiesLoader.CharacterReader reader, boolean splitLists) throws IOException {
    buffer.setLength(0);

    while(reader.isWhiteSpace() &amp;&amp; !reader.isEndOfLine()) {
        reader.read();
    }

    Location location = reader.getLocation();

    while(!reader.isEndOfLine() &amp;&amp; (!splitLists || !reader.isListDelimiter())) {
        buffer.append(reader.getCharacter());
        reader.read();
    }

    Origin origin = new TextResourceOrigin(this.resource, location);
    return OriginTrackedValue.of(buffer.toString(), origin);
}
</code></pre>
<p>在这个方法里，首先<code>CharacterReader</code>方法将我们的resource也就是配置文件转为了<code>输入流</code>，然后利用<code>reader.read()</code>进行读取，在loadKey方法中我们看到，这里判断读取到的是否为<code>'='</code>或者为<code>':'</code>，也就是我们在配置文件中以'='或者':'分割的key-value。因此看到这里，我们可以直观的感受到这里应该是读取配置文件，并切分key和value的地方。<br>
最终，对配置文件读取完成后，会将其以key-value的形式封装到一个<code>Map集合</code>中进行返回，然后封装到<code>OriginTrackedMapPropertySource</code>中作为一个<code>MapPropertySource</code>对象。再层层往上回退发现会最终封装成一个<code>asDocuments(loaded)</code>;Document对象。最后回到最上层的load方法中，loadDocuments(loader, name, resource);方法即返回我们加载好的配置文件Document对象集合。并对集合中的每一个配置文件document对象进行遍历，调用loaded.forEach((document) -&gt; consumer.accept(profile, document));</p>
<h4 id="123-创建-applicationcontext">1.2.3 创建 ApplicationContext</h4>
<p>首先是检查 Application的类型，然后获取对应的<code>ApplicationContext</code>类，我们这里是获取到了 <code>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</code>接着调用 <code>BeanUtils.instantiateClass(contextClass)</code>; 方法进行对象的初始化。</p>
<pre><code class="language-java">protected ConfigurableApplicationContext createApplicationContext() {
    Class&lt;?&gt; contextClass = this.applicationContextClass;
    if (contextClass == null) {
        try {
            switch(this.webApplicationType) {
            case SERVLET:
                contextClass = Class.forName(&quot;org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;);
                break;
            case REACTIVE:
                contextClass = Class.forName(&quot;org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;);
                break;
            default:
                contextClass = Class.forName(&quot;org.springframework.context.annotation.AnnotationConfigApplicationContext&quot;);
            }
        } catch (ClassNotFoundException var3) {
            throw new IllegalStateException(&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, var3);
        }
    }

    return (ConfigurableApplicationContext)BeanUtils.instantiateClass(contextClass);
}
</code></pre>
<p>终其实是调用了 <code>AnnotationConfigServletWebServerApplicationContext</code>的默认构造方法。我们看一下这个方法做了什么事情。这里只是简单的设置了一个 <code>reader</code>和一个 <code>scanner</code>，作用于 bean 的扫描工作。</p>
<p>接下来是获取 ExceptionReporter，获取 ExceptionReporter 的方式主要还是和之前 Listener 的方式一致,通过 getSpringFactoriesInstances 来获取所有的 SpringBootExceptionReporter。</p>
<h4 id="124-准备容器">1.2.4 准备容器</h4>
<pre><code class="language-java">private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,
        SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {
    // 为 ApplicationContext 设置 environment
    context.setEnvironment(environment);
    // 执行容器后置处理器
    postProcessApplicationContext(context);
    // 执行容器中的ApplicationContextInitializer
    applyInitializers(context);
        // 发送 ContextPrepareEvent，通知各个监听器。
    listeners.contextPrepared(context);
    if (this.logStartupInfo) {
        // 打印启动新包括 pid 和 用户等。
        logStartupInfo(context.getParent() == null);
        // 打印 Profile 信息
        logStartupProfileInfo(context);
    }
    // Add boot specific singleton beans
    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
    // 将启动参数作为 bean 注入到容器中
    beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);
    if (printedBanner != null) {
        // 将banner 注入到容器中
        beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);
    }
    if (beanFactory instanceof DefaultListableBeanFactory) {
        // 设置不允许定义同名的BeanDefinition，重复注册时抛出异常
        ((DefaultListableBeanFactory) beanFactory)
                .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
    }
    if (this.lazyInitialization) {
        // 如果是懒加载，则添加懒加载后置处理器。
        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
    }
    // 获取启动类的参数
    Set&lt;Object&gt; sources = getAllSources();
    Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
    // 加载启动类，并将其注入到容器中
    load(context, sources.toArray(new Object[0]));
    // 发布 ApplicationPreparedEvent 事件
    listeners.contextLoaded(context);
}
</code></pre>
<p><strong>postProcessApplicationContext</strong><br>
其主要实现如下：<br>
1、首先是指定<code>beanNameGenerator</code>,默认情况下不会进入这里，在没有自定义 beanNameGenerator的情况下，<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefinitionScanner</code>的默认实现是AnnotationBeanNameGenerator，即看是否有 value 定义值，假如没有就将首字母变成小写做为bean的名称。<br>
2、查看是否存在<code>resourceLoader</code>有的话就添加到 beanFactory 中。</p>
<pre><code class="language-java">protected void postProcessApplicationContext(ConfigurableApplicationContext context) {
    if (this.beanNameGenerator != null) {
        context.getBeanFactory().registerSingleton(&quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;, this.beanNameGenerator);
    }

    if (this.resourceLoader != null) {
        if (context instanceof GenericApplicationContext) {
            ((GenericApplicationContext)context).setResourceLoader(this.resourceLoader);
        }

        if (context instanceof DefaultResourceLoader) {
            ((DefaultResourceLoader)context).setClassLoader(this.resourceLoader.getClassLoader());
        }
    }
}
</code></pre>
<p><strong>执行 initializer</strong><br>
我们上面提到在初始化 SpringApplication 的时候会加载所有的 ApplicationContextInitializer，到这里就使用到了这些 initializer ，调用每个initializer 的 initialize 方法，并将 Context 作为参数传递进去。</p>
<pre><code class="language-java">protected void applyInitializers(ConfigurableApplicationContext context) {
    Iterator var2 = this.getInitializers().iterator();

    while(var2.hasNext()) {
        ApplicationContextInitializer initializer = (ApplicationContextInitializer)var2.next();
        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(), ApplicationContextInitializer.class);
        Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);
        initializer.initialize(context);
    }
}
</code></pre>
<p>1、DelegatingApplicationContextInitializer: 从environment中获取context.initializer.classes属性，默认为 null，可以使用多个使用逗号隔开，然后将调用这些类的 initialize 方法。<br>
2、SharedMetadataReaderFactoryContextInitializer 主要是在 beanFactory 中添加一个CachingMetadataReaderFactoryPostProcessor 会在 refreshContext 中被执行。<br>
3、ContextIdApplicationContextInitializer 将 Spring.application.name 作为 ContextId 设置到容器中。<br>
4、ConfigurationWarningsApplicationContextInitializer 向beanFacotory 中注册一个 ConfigurationWarningsPostProcessor 作用是添加一下检查。默认有一个ComponentScanPackageCheck，作用是检查@ComponentScan扫描的包路径是否合法.<br>
5、ServerPortInfoApplicationContextInitializer 向 ApplicationContext 中注册一个 ApplicationListener 用于监听WebServerInitializedEvent事件，向Environment中添加端口号local.sever.port。<br>
ConditionEvaluationReportLoggingListener 向容器中注册一个 ConditionEvaluationReportListener 主要用于打印日志。</p>
<p><strong>执行 ApplicationPrepareContext 通知</strong></p>
<p><strong>load 加载</strong></p>
<pre><code class="language-java">protected void load(ApplicationContext context, Object[] sources) {
    // 打印日志
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Loading source &quot; + StringUtils.arrayToCommaDelimitedString(sources));
    }
    // 初始化 BeanDefinitionLoader
    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);
    // 假如 BeanDefinition 不为空，就将其设置到 loader 中。
    if (this.beanNameGenerator != null) {
        loader.setBeanNameGenerator(this.beanNameGenerator);
    }
    // 如果 resourceLoader  不为空，就将 resourceLoader 设置到 loader 中
    if (this.resourceLoader != null) {
        loader.setResourceLoader(this.resourceLoader);
    }
    // 如果 environment  不为空，就将 environment 设置到 loader 中
    if (this.environment != null) {
        loader.setEnvironment(this.environment);
    }
    // 调用 loader 的 load 方法
    loader.load();
}
</code></pre>
<p>我们先来看一下 createBeanDefinitionLoader 方法：</p>
<pre><code class="language-java">BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) {
    Assert.notNull(registry, &quot;Registry must not be null&quot;);
    Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
    this.sources = sources;
    this.annotatedReader = new AnnotatedBeanDefinitionReader(registry);
    this.xmlReader = new XmlBeanDefinitionReader(registry);
    if (this.isGroovyPresent()) {
        this.groovyReader = new GroovyBeanDefinitionReader(registry);
    }

    this.scanner = new ClassPathBeanDefinitionScanner(registry);
    this.scanner.addExcludeFilter(new BeanDefinitionLoader.ClassExcludeFilter(sources));
}
</code></pre>
<p>主要做了两件事情：<br>
1、设置 Reader ，包括 AnnotatedBeanDefinitionReader 和 XmlBeanDefinitionReader 假如是Groovy 环境就生成 GroovyBeanDefinitionReader 。<br>
2、设置 Scanner ，主要是 ClassPathBeanDefinitionScanner ,然后检查 Application 中是否存在 ExcludeFilter ，有的话加入到 scanner 中。</p>
<p>接着看load方法：</p>
<pre><code class="language-java">public int load() {
    int count = 0;
    Object[] var2 = this.sources;
    int var3 = var2.length;

    for(int var4 = 0; var4 &lt; var3; ++var4) {
        Object source = var2[var4];
        count += this.load(source);
    }

    return count;
}
</code></pre>
<p>这里的主要逻辑是遍历所有的 sources，这里的其实就是我们的 Main 类。最终调用了 load(Class&lt;?&gt; source) 方法，最终调用了 annotatedReader#register(source)方法。</p>
<h4 id="125-刷新容器">1.2.5 刷新容器</h4>
<pre><code class="language-java">private void refreshContext(ConfigurableApplicationContext context) {
    this.refresh(context);
    if (this.registerShutdownHook) {
        try {
            context.registerShutdownHook();
        } catch (AccessControlException var3) {
        }
    }
}
</code></pre>
<p>主要做两件事情：<br>
1、假如需要注册关闭钩子的话，向 Context 注册关闭钩子。<br>
2、调用 refresh 方法，刷新容器。<br>
我们直接来看一下 refresh 方法，其最终调用了 AbstractApplicationContext 的 refresh 方法。其主要内容如下：</p>
<pre><code class="language-java"> public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            //1、准备刷新容器。
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var9) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);
                }

                this.destroyBeans();
                this.cancelRefresh(var9);
                throw var9;
            } finally {
                this.resetCommonCaches();
            }
        }
    }
</code></pre>
<p>这个方法主要有如下步骤：<br>
1、准备刷新容器。<br>
2、初始化 BeanFactory。<br>
3、对 BeanFactory 进行各种功能的填充，如对 @Autowrite 和 @Qualify 的支持就是这步加入的。<br>
4、调用 postProcessBeanFactory 的扩展点。<br>
5、激活各种 beanFactory 处理器。<br>
6、注册拦截 bean 创建的 bean处理器，这里仅仅是创建而已，最后 getBean 的时候才会真正的调用。<br>
7、初始化 Context 的 MessageSource，为一些国际化的内容。<br>
8、初始化 ApplicationEventMulticaster 并放到 bean 工厂中。<br>
9、扩展点，为其他的 Context 子类来初始化其 bean。<br>
10、在所有的 bean 中找到 listener bean，并将其注册到广播器中。<br>
11、初始化剩下的单例 （no-lazy-init）<br>
12、完成刷新过程，并发出 ContextRefreshEvent 通知。<br>
13、清除缓存。</p>
<h5 id="1251-准备刷新容器">1.2.5.1 准备刷新容器</h5>
<pre><code class="language-java">protected void prepareRefresh() {
    this.startupDate = System.currentTimeMillis();
    this.closed.set(false);
    this.active.set(true);
    if (this.logger.isInfoEnabled()) {
        this.logger.info(&quot;Refreshing &quot; + this);
    }

    this.initPropertySources();
    this.getEnvironment().validateRequiredProperties();
    this.earlyApplicationEvents = new LinkedHashSet();
}
</code></pre>
<p>上面代码比较简单，主要做了如下事情：<br>
1、设置容器启动时间。<br>
2、设置启动状态。<br>
3、调用 initPropertySources 方法，调用到的是 GenericWebApplicationContext 的 initPropertySources 方法，最终调用如下方法：<br>
4、将当前的 ApplicationListeners 放置到 earlyApplicationListeners 中。</p>
<pre><code class="language-java">public static void initServletPropertySources(MutablePropertySources sources, @Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {
    Assert.notNull(sources, &quot;'propertySources' must not be null&quot;);
    String name = &quot;servletContextInitParams&quot;;
    if (servletContext != null &amp;&amp; sources.contains(name) &amp;&amp; sources.get(name) instanceof StubPropertySource) {
        sources.replace(name, new ServletContextPropertySource(name, servletContext));
    }

    name = &quot;servletConfigInitParams&quot;;
    if (servletConfig != null &amp;&amp; sources.contains(name) &amp;&amp; sources.get(name) instanceof StubPropertySource) {
        sources.replace(name, new ServletConfigPropertySource(name, servletConfig));
    }

    //1、如果 `servletContext` 不为空，且是 StubPropertySource 的子类，那么将其转为 `ServletContextPropertySource`.
    //2、如果 `servletConfig` 不为空，且是 StubPropertySource 的子类，那么将其转为 `ServletContextPropertySource`.
    //但是这里的  `servletContext`  和  `servletConfig`  都为空，所以不会进入。
}
</code></pre>
<h5 id="1252-初始化-beanfactory">1.2.5.2 初始化 BeanFactory</h5>
<pre><code class="language-java">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    this.refreshBeanFactory();
    ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();
    if (this.logger.isDebugEnabled()) {
        this.logger.debug(&quot;Bean factory for &quot; + this.getDisplayName() + &quot;: &quot; + beanFactory);
    }

    return beanFactory;
}
</code></pre>
<p>主要做两件事情， <code>refreshBeanFactory</code>，<code>初始化BeanFactory</code>，最终调用了 <code>GenericApplicationContext#refreshBeanFactory</code>，如下：</p>
<pre><code class="language-java">protected final void refreshBeanFactory() throws IllegalStateException {
    if (!this.refreshed.compareAndSet(false, true)) {
        throw new IllegalStateException(&quot;GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once&quot;);
    } else {
        this.beanFactory.setSerializationId(this.getId());
    }
}
</code></pre>
<p>1、设置 refresh 的状态为 <code>TRUE</code>。<br>
2、为 beanFactory 设置<code>setSerializationId</code> ，这个里是 <code>application</code>，其主要由三段式组成 <code>ApplicationName:profile:port</code>。</p>
<p>接下来分析一下 getBeanFactory 方法：</p>
<pre><code class="language-java">public final ConfigurableListableBeanFactory getBeanFactory() {
    return this.beanFactory;
}
</code></pre>
<p>最终还是调用了返回当前 context 的beanFactory，返回一个<code>DefaultListableBeanFactory</code>。</p>
<h5 id="1253-preparebeanfactory">1.2.5.3 prepareBeanFactory</h5>
<pre><code class="language-java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    beanFactory.setBeanClassLoader(this.getClassLoader());
    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, this.getEnvironment()));
    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
    beanFactory.registerResolvableDependency(ResourceLoader.class, this);
    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
    beanFactory.registerResolvableDependency(ApplicationContext.class, this);
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
    if (beanFactory.containsBean(&quot;loadTimeWeaver&quot;)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }

    if (!beanFactory.containsLocalBean(&quot;environment&quot;)) {
        beanFactory.registerSingleton(&quot;environment&quot;, this.getEnvironment());
    }

    if (!beanFactory.containsLocalBean(&quot;systemProperties&quot;)) {
        beanFactory.registerSingleton(&quot;systemProperties&quot;, this.getEnvironment().getSystemProperties());
    }

    if (!beanFactory.containsLocalBean(&quot;systemEnvironment&quot;)) {
        beanFactory.registerSingleton(&quot;systemEnvironment&quot;, this.getEnvironment().getSystemEnvironment());
    }
}
</code></pre>
<p>1、为 beanFactory 设置类加载器，为当前 context 的类加载器。<br>
2、设置 beanFactory 的 BeanExpressionResolver 为 StandardBeanExpressionResolver。<br>
3、beanFactory增加一个默认的 PropertyEditor,主要用于对 bean 的属性设置进行管理。<br>
4、为 beanFactory 增加一个 BeanPostProcessor 为 ApplicationContextAwareProcessor。<br>
5、将 EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、添加到忽略自动装配的接口中。,当spring将ApplicationContextAwareProcessor注册后,那么在invokeAwareInterfaces中直接,调用的Aware类已经不是普通的bean了,如ResourceLoaderAware,那么需要在spring做bean的依赖注入时忽略它们。<br>
6、将当前 Context 注册为解析如下依赖的注入对象，包括 BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext。比如说我们调用 @Autowrite 注入 ApplicationContext 就是注入当前的 Context。<br>
7、注册 BeanPostProcessor ， ApplicationListenerDetector 。<br>
8、添加默认的系统环境bean。</p>
<h5 id="1254-postprocessbeanfactory">1.2.5.4 postProcessBeanFactory</h5>
<p>该方法最终调用了子类的 <code>AnnotationConfigServletWebApplicationContext#postProcessBeanFactory</code> ,</p>
<pre><code class="language-java">protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    super.postProcessBeanFactory(beanFactory);
    if (this.basePackages != null &amp;&amp; this.basePackages.length &gt; 0) {
        this.scanner.scan(this.basePackages);
    }

    if (!this.annotatedClasses.isEmpty()) {
        this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));
    }
}
</code></pre>
<p>主要做了三件事情：<br>
1、为 BeanFactory 设置了一个为ServletContextAwareProcessor 类型的 BeanPostProcessor，并设置了忽略接口ServletContextAware.<br>
2、假如basePackage 大于 0 的话，就调用 scanner 的 scan 方法。<br>
3、如果 annotatedClasses 大于 0 的话，就调用 AnnotatedBeanDefinitionReader 的 register 方法。</p>
<h5 id="1255-激活各种-bean-处理器">1.2.5.5 激活各种 bean 处理器</h5>
<pre><code class="language-java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, this.getBeanFactoryPostProcessors());
    if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(&quot;loadTimeWeaver&quot;)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }
}
</code></pre>
<p>1、调用PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors.<br>
2、如果beanFactory.getTempClassLoader() 等于null并且 beanFactory含有loadTimeWeaver的定义的话,就向beanFactory添加一个LoadTimeWeaverAwareProcessor,然后设置TempClassLoader 为 ContextTypeMatchClassLoader.</p>
<p>其中最重要的就是调用 invokeBeanDefinitionRegistryPostProcessors 方法中，调用了 <code>ConfigurationClassPostProcessor</code>,主要负责加载大部分的 <code>BeanDefinition</code>注册到 registry 中。具体流程如下：</p>
<pre><code class="language-java">public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    int registryId = System.identityHashCode(registry);
    if (this.registriesPostProcessed.contains(registryId)) {
        throw new IllegalStateException(&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);
    } else if (this.factoriesPostProcessed.contains(registryId)) {
        throw new IllegalStateException(&quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);
    } else {
        this.registriesPostProcessed.add(registryId);
        this.processConfigBeanDefinitions(registry);
    }
}
</code></pre>
<p>主要做了两件事情：<br>
1、生成当前 registry 的 id，然后到 <code>registriesPostProcessed</code>和 <code>registriesPostProcessed</code>中查找，是否存在，主要作用是去重。<br>
2、假如没有重复调用 <code>processConfigBeanDefinitions</code>去加载。</p>
<p>我们进入<code>processConfigBeanDefinitions</code>中：</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
// 获取已经注册的 bean 名称，这里一般是我们的启动 Application 类。
    String[] candidateNames = registry.getBeanDefinitionNames();

    for (String beanName : candidateNames) {
        BeanDefinition beanDef = registry.getBeanDefinition(beanName);
// 假如 beanDefinition 中的 ConfigurationClass 属性为 full 或者 lite 那代表已经解析过了，跳过。
        if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
            }
        }
// 判断当前类是否是 config 类，假如是就加入到 configCandidates 中。
        else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
        }
    }
// 假如 configCandidates 为空就返回
    if (configCandidates.isEmpty()) {
        return;
    }
// 对 configCandidates 使用 @Order 注解进行排序
    configCandidates.sort((bd1, bd2) -&gt; {
        int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
        int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
        return Integer.compare(i1, i2);
    });

    // Detect any custom bean name generation strategy supplied through the enclosing application context
    SingletonBeanRegistry sbr = null;
    if (registry instanceof SingletonBeanRegistry) {
        sbr = (SingletonBeanRegistry) registry;
        if (!this.localBeanNameGeneratorSet) {
            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(
                    AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);
            if (generator != null) {
// 设置 beanNameGenerator
                this.componentScanBeanNameGenerator = generator;
                this.importBeanNameGenerator = generator;
            }
        }
    }
    if (this.environment == null) {
        this.environment = new StandardEnvironment();
    }
//实例化 ConfigurationClassParser 为后续解析准备。
    ConfigurationClassParser parser = new ConfigurationClassParser(
            this.metadataReaderFactory, this.problemReporter, this.environment,
            this.resourceLoader, this.componentScanBeanNameGenerator, registry);
// 初始话 candidates 和 alreadyParsed 两个集合
    Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
    Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
    do {
// 进行解析
        parser.parse(candidates);
        parser.validate();
// 获取解析到的 ConfigurationClass
        Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
        configClasses.removeAll(alreadyParsed);
        // Read the model and create bean definitions based on its content
        if (this.reader == null) {
            this.reader = new ConfigurationClassBeanDefinitionReader(
                    registry, this.sourceExtractor, this.resourceLoader, this.environment,
                    this.importBeanNameGenerator, parser.getImportRegistry());
        }
// 加载 ConfigurationClass 的 beanDefinition
        this.reader.loadBeanDefinitions(configClasses);
// 添加到 ConfigurationClass 中。
        alreadyParsed.addAll(configClasses);
        candidates.clear();
        if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
            String[] newCandidateNames = registry.getBeanDefinitionNames();
            Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
            Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
            for (ConfigurationClass configurationClass : alreadyParsed) {
                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
            }
            for (String candidateName : newCandidateNames) {
                if (!oldCandidateNames.contains(candidateName)) {
                    BeanDefinition bd = registry.getBeanDefinition(candidateName);
                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                            !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                        candidates.add(new BeanDefinitionHolder(bd, candidateName));
                    }
                }
            }
            candidateNames = newCandidateNames;
        }
    }
    while (!candidates.isEmpty());
    // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
    if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
    }

    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
        // Clear cache in externally provided MetadataReaderFactory; this is a no-op
        // for a shared cache since it'll be cleared by the ApplicationContext.
        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
    }
}
</code></pre>
<p>主要做了如下7件事情：<br>
1、获取已经注册的bean名称进行遍历：<br>
2、对configCandidates 进行 排序,按照@Order 配置的值进行排序。<br>
3、如果BeanDefinitionRegistry 是SingletonBeanRegistry 子类的话,将registry强转为SingletonBeanRegistry。<br>
4、实例化ConfigurationClassParser 为了解析各个配置类.实例化2个set,candidates 用于将之前加入的configCandidates 进行去重,alreadyParsed 用于判断是否处理过。<br>
5、进行解析。<br>
6、如果SingletonBeanRegistry 不包含org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry,则注册一个,bean 为 ImportRegistry. 一般都会进行注册的。<br>
7、清除缓存。</p>
<p>我们先来看一下判断该 bean 是否为<code>configClass</code>的方法。</p>
<pre><code class="language-java">public static boolean checkConfigurationClassCandidate(
        BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
// 获取类名，假如不存在则返回。
    String className = beanDef.getBeanClassName();
    if (className == null || beanDef.getFactoryMethodName() != null) {
        return false;
    }
// 获取 AnnotationMetadata
    AnnotationMetadata metadata;
    if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;
            className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
// 检查是否可以是 AnnotatedBeanDefinition ，是就直接从 BeanDefinition 中获取
        metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
    }
    else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
// 如果BeanDefinition 是 AnnotatedBeanDefinition的实例,并且beanDef 有 beanClass 属性存在没有则实例化StandardAnnotationMetadata
        Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
        if (BeanFactoryPostProcessor.class.isAssignableFrom(beanClass) ||
                BeanPostProcessor.class.isAssignableFrom(beanClass) ||
                AopInfrastructureBean.class.isAssignableFrom(beanClass) ||
                EventListenerFactory.class.isAssignableFrom(beanClass)) {
            return false;
        }
        metadata = AnnotationMetadata.introspect(beanClass);
    }
    else {
        try {
// 否则 通过MetadataReaderFactory 中的MetadataReader 进行读取
            MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
            metadata = metadataReader.getAnnotationMetadata();
        }
        catch (IOException ex) {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; +
                        className, ex);
            }
            return false;
        }
    }
// 如果存在Configuration 注解,则为BeanDefinition 设置configurationClass属性为full
    Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());
    if (config != null &amp;&amp; !Boolean.FALSE.equals(config.get(&quot;proxyBeanMethods&quot;))) {
        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
    }
// 如果AnnotationMetadata 中有Component,ComponentScan,Import,ImportResource 注解中的任意一个,或者存在 被@bean 注解的方法,则返回true
    else if (config != null || isConfigurationCandidate(metadata)) {
        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
    }
    else {
        return false;
    }
    Integer order = getOrder(metadata);
    if (order != null) {
        beanDef.setAttribute(ORDER_ATTRIBUTE, order);
    }
    return true;
}
</code></pre>
<p>接着来看<code>ConfigurationClassParser</code>的<code>parser()</code>:</p>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            if (bd instanceof AnnotatedBeanDefinition) {
                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
            }
            else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
            }
            else {
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                    &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
        }
    }
    this.deferredImportSelectorHandler.process();
}
</code></pre>
<p>其主要做了两件事情：<br>
1、遍历configCandidates ,进行处理.根据BeanDefinition 的类型 做不同的处理,一般都会调用ConfigurationClassParser#parse 进行解析。<br>
2、处理ImportSelect。<br>
我们先来看一下第一步：</p>
<pre><code class="language-java">protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException {
    if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
        return;
    }
    ConfigurationClass existingClass = this.configurationClasses.get(configClass);
    if (existingClass != null) {
        if (configClass.isImported()) {
            if (existingClass.isImported()) {
                existingClass.mergeImportedBy(configClass);
            }
            // Otherwise ignore new imported config class; existing non-imported class overrides it.
            return;
        }
        else {
            // Explicit bean definition found, probably replacing an import.
            // Let's remove the old one and go with the new one.
            this.configurationClasses.remove(configClass);
            this.knownSuperclasses.values().removeIf(configClass::equals);
        }
    }

    // Recursively process the configuration class and its superclass hierarchy.
    SourceClass sourceClass = asSourceClass(configClass, filter);
    do {
        sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
    }
    while (sourceClass != null);

    this.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>主要做如下4件事情：<br>
1、调用 shouldSkip 方法来判断该 configClass 是否需要 跳过。<br>
2、处理Imported 的情况。<br>
3、递归调用进行解析。<br>
4、添加到configurationClasses中。<br>
我们先来看一下真正解析的步骤 <code>doProcessConfigurationClass</code> 方法：</p>
<pre><code class="language-java">protected final SourceClass doProcessConfigurationClass(
        ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)
        throws IOException {

    if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
        // Recursively process any member (nested) classes first
        processMemberClasses(configClass, sourceClass, filter);
    }

    // Process any @PropertySource annotations
    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), PropertySources.class,
            org.springframework.context.annotation.PropertySource.class)) {
        if (this.environment instanceof ConfigurableEnvironment) {
            processPropertySource(propertySource);
        }
        else {
            logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
                    &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
        }
    }

    // Process any @ComponentScan annotations
    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    if (!componentScans.isEmpty() &amp;&amp;
            !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        for (AnnotationAttributes componentScan : componentScans) {
            // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
                    this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            // Check the set of scanned definitions for any further config classes and parse recursively if needed
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }
    // Process any @Import annotations
    processImports(configClass, sourceClass, getImports(sourceClass), filter, true);
    // Process any @ImportResource annotations
    AnnotationAttributes importResource =
            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
    if (importResource != null) {
        String[] resources = importResource.getStringArray(&quot;locations&quot;);
        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
        for (String resource : resources) {
            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
            configClass.addImportedResource(resolvedResource, readerClass);
        }
    }
    // Process individual @Bean methods
    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
    for (MethodMetadata methodMetadata : beanMethods) {
        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
    }

    // Process default methods on interfaces
    processInterfaces(configClass, sourceClass);

    // Process superclass, if any
    if (sourceClass.getMetadata().hasSuperClass()) {
        String superclass = sourceClass.getMetadata().getSuperClassName();
        if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
                !this.knownSuperclasses.containsKey(superclass)) {
            this.knownSuperclasses.put(superclass, configClass);
            // Superclass found, return its annotation metadata and recurse
            return sourceClass.getSuperClass();
        }
    }
    // No superclass -&gt; processing is complete
    return null;
}
</code></pre>
<p>主要做了如下8件事情：<br>
1、如果该类使用 @Component 注解，调用 processMemberClasses 方法，其主要作用是将类放到 importStack 中，并且判断是否有循环依赖度问题。<br>
2、处理@PropertySource.通过遍历该类中的@PropertySource的注解,如果该类中的environment是ConfigurableEnvironment 子类的话,则调用processPropertySource进行处理。<br>
3、处理@ComponentScan,通过遍历该类上的@ComponentScan 注解，并使用 conditionEvaluator.shouldSkip 进行判断是否需要跳过。没有就通过ComponentScanAnnotationParser#parse方法进行扫描：<br>
4、处理@Import 注解<br>
5、处理 @ImportResource 注解，先重 config 类中查找是否存在该注解，假如存在，就获取其 location 属性，然后遍历 location 位置中的 bean，加入到 configClass 中的 ImportedResource。<br>
6、处理 @Bean 的方法，遍历 @Bean 的方法，并放到 configClass 的 BeanMethod 中。<br>
7、遍历 configClass 的所有接口的 @Bean 的方法，并放到 configClass 的 BeanMethod 中。<br>
8、如果存在父类的话，就将父类放到 knownSuperclasses 中，并返回，返回就类似于递归调用。否则返回 null。</p>
<p>我们回到ConfigurationClassPostProcessor的processConfigBeanDefinitions方法中，接下来是调用 ConfigurationClassBeanDefinitionReader#loadBeanDefinitions 方法。</p>
<pre><code class="language-java">public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) {
    TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
    for (ConfigurationClass configClass : configurationModel) {
        loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
    }
}
</code></pre>
<p>主要做两件事情：<br>
1、实例化 TrackedConditionEvaluator；<br>
2、遍历configurationModel ，使用loadBeanDefinitionsForConfigurationClass 方法加载 BeanDefinition。</p>
<pre><code class="language-java">private void loadBeanDefinitionsForConfigurationClass(
        ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {

    if (trackedConditionEvaluator.shouldSkip(configClass)) {
        String beanName = configClass.getBeanName();
        if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) {
            this.registry.removeBeanDefinition(beanName);
        }
        this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
        return;
    }

    if (configClass.isImported()) {
        registerBeanDefinitionForImportedConfigurationClass(configClass);
    }
    for (BeanMethod beanMethod : configClass.getBeanMethods()) {
        loadBeanDefinitionsForBeanMethod(beanMethod);
    }

    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
</code></pre>
<p>主要做了如下几件事情：<br>
1、调用 trackedConditionEvaluator 来判断条件注解，是否需要跳过这个 config 类。如果需要，就将这个类从容器中移除，并且从 importRegistry 中移除。<br>
2、如果当前类中存在@Import 注解，调用 registerBeanDefinitionForImportedConfigurationClass 方法进行注册<br>
3、遍历BeanMethods,依次对其调用loadBeanDefinitionsForBeanMethod进行注册。<br>
4、处理 @ImportResource 注解,具体如下：</p>
<pre><code class="language-java">private void loadBeanDefinitionsFromImportedResources(
        Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources) {
    Map&lt;Class&lt;?&gt;, BeanDefinitionReader&gt; readerInstanceCache = new HashMap&lt;&gt;();
// 遍历所有的 importedResources
    importedResources.forEach((resource, readerClass) -&gt; {
// 如果是 BeanDefinitionReader，就查看是否是 groovy 类，假如不是就使用 XmlBeanDefinitionReader 类
        if (BeanDefinitionReader.class == readerClass) {
            if (StringUtils.endsWithIgnoreCase(resource, &quot;.groovy&quot;)) {
                readerClass = GroovyBeanDefinitionReader.class;
            }
            else {
                readerClass = XmlBeanDefinitionReader.class;
            }
        }
// 尝试重 readerInstanceCache 读取 BeanDefinitionReader 假如没有就实例化。
        BeanDefinitionReader reader = readerInstanceCache.get(readerClass);
        if (reader == null) {
            try {
                reader = readerClass.getConstructor(BeanDefinitionRegistry.class).newInstance(this.registry);
                if (reader instanceof AbstractBeanDefinitionReader) {
                    AbstractBeanDefinitionReader abdr = ((AbstractBeanDefinitionReader) reader);
                    abdr.setResourceLoader(this.resourceLoader);
                    abdr.setEnvironment(this.environment);
                }
                readerInstanceCache.put(readerClass, reader);
            }
            catch (Throwable ex) {
                throw new IllegalStateException(
                        &quot;Could not instantiate BeanDefinitionReader class [&quot; + readerClass.getName() + &quot;]&quot;);
            }
        }
// 加载 bean
        reader.loadBeanDefinitions(resource);
    });
}
</code></pre>
<p>主要做了四件事情：<br>
1、遍历所有的 importedResources 。<br>
2、选择 BeanDefinitionReader，假如是 groovy 类，就使用 GroovyBeanDefinitionReader 不是就使用 XmlBeanDefinitionReader<br>
3、尝试从readerInstanceCache中获取对应的BeanDefinitionReader,如果不存在,则实例化一个,然后放入到readerInstanceCache缓存中。<br>
4、调用 BeanDefinitionReader#loadBeanDefinitions 进行加载 bean。<br>
5、注册@Import注解中的ImportBeanDefinitionRegistrar接口的registerBeanDefinitions。</p>
<p>接下来，我们继续看容器刷新流程</p>
<h5 id="1256-registerbeanpostprocessors-方法">1.2.5.6 registerBeanPostProcessors 方法</h5>
<p>这个方法最终调用了 PostProcessorRegistrationDelegate#registerBeanPostProcessors，如下：</p>
<pre><code class="language-java">public static void registerBeanPostProcessors(
        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

    // Register BeanPostProcessorChecker that logs an info message when
    // a bean is created during BeanPostProcessor instantiation, i.e. when
    // a bean is not eligible for getting processed by all BeanPostProcessors.
    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

    // Separate between BeanPostProcessors that implement PriorityOrdered,
    // Ordered, and the rest.
    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
    List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
    for (String ppName : postProcessorNames) {
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            priorityOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
            orderedPostProcessorNames.add(ppName);
        }
        else {
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    // First, register the BeanPostProcessors that implement PriorityOrdered.
    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

    // Next, register the BeanPostProcessors that implement Ordered.
    List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());
    for (String ppName : orderedPostProcessorNames) {
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        orderedPostProcessors.add(pp);
        if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    sortPostProcessors(orderedPostProcessors, beanFactory);
    registerBeanPostProcessors(beanFactory, orderedPostProcessors);

    // Now, register all regular BeanPostProcessors.
    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());
    for (String ppName : nonOrderedPostProcessorNames) {
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        nonOrderedPostProcessors.add(pp);
        if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

    // Finally, re-register all internal BeanPostProcessors.
    sortPostProcessors(internalPostProcessors, beanFactory);
    registerBeanPostProcessors(beanFactory, internalPostProcessors);

    // Re-register post-processor for detecting inner beans as ApplicationListeners,
    // moving it to the end of the processor chain (for picking up proxies etc).
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
}
</code></pre>
<p>1、先从 beanFactory 中获取 BeanPostProcessor 类型的 bean。<br>
2、添加一个BeanPostProcessor ， BeanPostProcessorChecker ，主要用于日志打印。<br>
3、遍历所有的 postProcessorNames ：<br>
（1）将所有实现了 PriorityOrdered 接口的 bean 放到 priorityOrderedPostProcessors 中。<br>
（2）如果bean 即实现了 PriorityOrdered 接口，也实现了 MergedBeanDefinitionPostProcessor 接口的话，将其放到 internalPostProcessors 中。<br>
（3）假如 bean 实现了 Ordered 接口放到 orderedPostProcessorNames 中。<br>
（4）假如都没有，就放到 nonOrderedPostProcessorNames 中。<br>
4、注册 priorityOrderedPostProcessors 的 BPP<br>
5、注册 orderedPostProcessors 的 BPP<br>
6、注册所有 nonOrderedPostProcessors 的 BPP<br>
7、 注册所有MergedBeanDefinitionPostProcessor类型的BeanPostProcessor,并非是重复注册.如下:<br>
8、在最后新增一个BPP 是 ApplicationListenerDetector。</p>
<h5 id="1257-initmessagesource-方法">1.2.5.7 initMessageSource 方法</h5>
<p>1、从 beanFactory 中读取 messageSource ，看是否存在，假如存在，获取之，然后判断是是HierarchicalMessageSource 类型假如是，就将其 ParentMessageSource 设置为 nternalParentMessageSource。<br>
2、如果不存在，就实例化 DelegatingMessageSource 作为 getInternalParentMessageSource 调用的结果。</p>
<h5 id="1258-初始化-applicationeventmulticaster">1.2.5.8 初始化 ApplicationEventMulticaster</h5>
<p>这里的逻辑主要是 如果存在用户自定义的广播器，那么就将其设置为默认广播器。假如不存在就初始化 SimpleApplicationEventMulticaster 作为默认的广播器。</p>
<h5 id="1259-onrefresh">1.2.5.9 Onrefresh</h5>
<p>这个接口是留给子类的扩展点 ServletWebServerApplicationContext 的代码如下：</p>
<pre><code class="language-java">@Override
protected void onRefresh() {
    super.onRefresh();
    try {
        createWebServer();
    }
    catch (Throwable ex) {
        throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);
    }
}
</code></pre>
<p>1 、先调用父类的 onRefresh 方法<br>
2、调用完父类的 Onfresh 后，创建一个嵌入的Servlet容器.</p>
<pre><code class="language-java">public static ThemeSource initThemeSource(ApplicationContext context) {
    if (context.containsLocalBean(THEME_SOURCE_BEAN_NAME)) {
        ThemeSource themeSource = context.getBean(THEME_SOURCE_BEAN_NAME, ThemeSource.class);
        // Make ThemeSource aware of parent ThemeSource.
        if (context.getParent() instanceof ThemeSource &amp;&amp; themeSource instanceof HierarchicalThemeSource) {
            HierarchicalThemeSource hts = (HierarchicalThemeSource) themeSource;
            if (hts.getParentThemeSource() == null) {
                // Only set parent context as parent ThemeSource if no parent ThemeSource
                // registered already.
                hts.setParentThemeSource((ThemeSource) context.getParent());
            }
        }
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Using ThemeSource [&quot; + themeSource + &quot;]&quot;);
        }
        return themeSource;
    }
    else {
        // Use default ThemeSource to be able to accept getTheme calls, either
        // delegating to parent context's default or to local ResourceBundleThemeSource.
        HierarchicalThemeSource themeSource = null;
        if (context.getParent() instanceof ThemeSource) {
            themeSource = new DelegatingThemeSource();
            themeSource.setParentThemeSource((ThemeSource) context.getParent());
        }
        else {
            themeSource = new ResourceBundleThemeSource();
        }
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Unable to locate ThemeSource with name '&quot; + THEME_SOURCE_BEAN_NAME +
                    &quot;': using default [&quot; + themeSource + &quot;]&quot;);
        }
        return themeSource;
    }
}
</code></pre>
<p>1、如果context中有themeSource的定义<br>
（1）从context 获取,id 为themeSource type为ThemeSource 的 bean<br>
（2）如果父容器实现了ThemeSource,并且ThemeSource 是HierarchicalThemeSource 的子类,并且HierarchicalThemeSource 的ParentThemeSource 没有进行设置.则将父容器赋值给HierarchicalThemeSource的ParentThemeSource<br>
2、如果context中没有themeSource的定义<br>
（1）如果父容器为ThemeSource的子类,则实例化DelegatingThemeSource,并将父容器赋值给DelegatingThemeSource的ParentThemeSource<br>
（2）否则实例化为DelegatingThemeSource</p>
<h5 id="12510-registerlisteners-注册监听器">1.2.5.10 registerListeners 注册监听器</h5>
<p>这个方法的主要作用是初始化所有的 listener</p>
<pre><code class="language-java">protected void registerListeners() {
    // Register statically specified listeners first.
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {
        getApplicationEventMulticaster().addApplicationListener(listener);
    }

    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String listenerBeanName : listenerBeanNames) {
        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    }

    // Publish early application events now that we finally have a multicaster...
    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;
    this.earlyApplicationEvents = null;
    if (!CollectionUtils.isEmpty(earlyEventsToProcess)) {
        for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
            getApplicationEventMulticaster().multicastEvent(earlyEvent);
        }
    }
}
</code></pre>
<p>1、硬编码方式注册的监听器添加到SimpleApplicationEventMulticaster中的defaultRetriever的applicationListeners<br>
2、将注册到配置文件中的 ApplicationListener 找出来，并添加到SimpleApplicationEventMulticaster中的defaultRetriever。<br>
3、 将之前发生的 earlyApplicationEvents 重复发送一遍。</p>
<h5 id="12511-finishbeanfactoryinitialization">1.2.5.11 finishBeanFactoryInitialization</h5>
<p>该方法主要作用是 初始化剩余的单例（non-lazy-init)）</p>
<pre><code class="language-java">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // Initialize conversion service for this context.
    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
        beanFactory.setConversionService(
                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    }

    // Register a default embedded value resolver if no bean post-processor
    // (such as a PropertyPlaceholderConfigurer bean) registered any before:
    // at this point, primarily for resolution in annotation attribute values.
    if (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
    }

    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    for (String weaverAwareName : weaverAwareNames) {
        getBean(weaverAwareName);
    }

    // Stop using the temporary ClassLoader for type matching.
    beanFactory.setTempClassLoader(null);

    // Allow for caching all bean definition metadata, not expecting further changes.
    beanFactory.freezeConfiguration();

    // Instantiate all remaining (non-lazy-init) singletons.
    beanFactory.preInstantiateSingletons();
}
</code></pre>
<p>1、如果 beaFactory 中存在 CONVERSION_SERVICE_BEAN_NAME name 的 bean，并且类型为 ConversionService.class ，将其设置到 beanFactory 中。<br>
2、如果 beanFactory 中没有 EmbeddedValueResolver，添加一个。<br>
3、设置 type 为 LoadTimeWeaverAware 的bean。<br>
4、设置TempClassLoader 为null<br>
5、冻结所有 bean 的定义，也就是从这里开始，所有的 bean 后面都不允许被修改了。<br>
6、初始化剩下的单实例.</p>
<h5 id="12512-finishrefresh">1.2.5.12 finishRefresh</h5>
<pre><code class="language-java">protected void finishRefresh() {
    // Clear context-level resource caches (such as ASM metadata from scanning).
    clearResourceCaches();

    // Initialize lifecycle processor for this context.
    initLifecycleProcessor();

    // Propagate refresh to lifecycle processor first.
    getLifecycleProcessor().onRefresh();

    // Publish the final event.
    publishEvent(new ContextRefreshedEvent(this));

    // Participate in LiveBeansView MBean, if active.
    LiveBeansView.registerApplicationContext(this);
}
</code></pre>
<p>1、清理 resource caches。<br>
2、初始化LifecycleProcessor.<br>
3、调用 LifecycleProcessor 的 onrefresh 方法。<br>
4、发布ContextRefreshedEvent 事件.</p>
<h5 id="12513-resetcommoncaches">1.2.5.13 resetCommonCaches</h5>
<p>1、清除 ReflectionUtils 缓存。<br>
2、清除 AnnotationUtils 缓存。<br>
3、清除 ResolvableType 缓存。</p>
<h4 id="126-afterrefresh-spring-容器的后置处理器">1.2.6 afterRefresh Spring 容器的后置处理器</h4>
<h4 id="127-通知所有-listener-结束启动">1.2.7 通知所有 listener 结束启动</h4>
<p>这里最终调用了 EventPublishingRunListener#started 方法：</p>
<pre><code class="language-java">public void started(ConfigurableApplicationContext context) {
    context.publishEvent(new ApplicationStartedEvent(this.application, this.args, context));
    AvailabilityChangeEvent.publish(context, LivenessState.CORRECT);
}
</code></pre>
<p>1、首先是调用 context.publishEvent 来发布启动完成事件。<br>
2、调用 AvailabilityChangeEvent 发布 CORRECT 事件，代表启动成功。</p>
<h4 id="128-调用所有-runner-的-run-方法">1.2.8 调用所有 runner 的 run 方法</h4>
<pre><code class="language-java">private void callRunners(ApplicationContext context, ApplicationArguments args) {
    List&lt;Object&gt; runners = new ArrayList&lt;&gt;();
    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
    AnnotationAwareOrderComparator.sort(runners);
    for (Object runner : new LinkedHashSet&lt;&gt;(runners)) {
        if (runner instanceof ApplicationRunner) {
            callRunner((ApplicationRunner) runner, args);
        }
        if (runner instanceof CommandLineRunner) {
            callRunner((CommandLineRunner) runner, args);
        }
    }
}
</code></pre>
<p>首先查找所有的 ApplicationRunner 和 CommandLineRunner ，然后遍历调用他们的 run 方法。</p>
<h4 id="129-通知所有-listener-running-事件">1.2.9 通知所有 listener running 事件。</h4>
<blockquote>
<p>⚠️大家可以参考这个图，因为没钱买，只能放链接了 <a href="https://www.processon.com/view/60605358f346fb6d9ef1bd9c?fromnew=1" title="springboot启动流程">springboot启动流程</a></p>
</blockquote>
<h2 id="2-springboot-扩展点">2 springboot 扩展点</h2>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1676171242267.png" alt="" loading="lazy"></figure>
<h3 id="21-applicationcontextinitializer">2.1 ApplicationContextInitializer</h3>
<blockquote>
<p>org.springframework.context.ApplicationContextInitializer<br>
这是整个spring容器在刷新之前初始化<code>ConfigurableApplicationContext</code>的回调接口，简单来说，就是在容器刷新之前调用此类的<code>initialize</code>方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。</p>
</blockquote>
<p>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。</p>
<pre><code class="language-java">public class TestApplicationContextInitializer implements ApplicationContextInitializer {
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        System.out.println(&quot;[ApplicationContextInitializer]&quot;);
    }
}
</code></pre>
<p>因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：</p>
<ol>
<li>在启动类中用<code>springApplication.addInitializers(new TestApplicationContextInitializer())</code>语句加入</li>
<li>配置文件配置<br>
<code>context.initializer.classes=com.example.demo.TestApplicationContextInitializer</code></li>
<li>Spring SPI扩展，在<code>spring.factories</code>中加入<code>org.springframework.context.ApplicationContextInitializer=com.example.demo.TestApplicationContextInitializer</code></li>
</ol>
<h3 id="22-beandefinitionregistrypostprocessor">2.2 BeanDefinitionRegistryPostProcessor</h3>
<blockquote>
<p>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor<br>
这个接口在读取项目中的<code>beanDefinition</code>之后执行，提供一个补充的扩展点</p>
</blockquote>
<p>使用场景：你可以在这里动态注册自己的beanDefinition，可以加载classpath之外的bean</p>
<pre><code class="language-java">public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry&quot;);
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory&quot;);
    }
}
</code></pre>
<h3 id="23-beanfactorypostprocessor">2.3 BeanFactoryPostProcessor</h3>
<blockquote>
<p>org.springframework.beans.factory.config.BeanFactoryPostProcessor<br>
这个接口是<code>beanFactory</code>的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。</p>
</blockquote>
<p>在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。</p>
<pre><code class="language-java">public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
@Override
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
    System.out.println(&quot;[BeanFactoryPostProcessor]&quot;);
}
}
</code></pre>
<h3 id="24-instantiationawarebeanpostprocessor">2.4 InstantiationAwareBeanPostProcessor</h3>
<blockquote>
<p>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor<br>
该接口继承了BeanPostProcess接口，区别如下：</p>
</blockquote>
<p><font color="red">BeanPostProcess接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而InstantiationAwareBeanPostProcessor接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。</font></p>
<p>该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：<font color=red>实例化阶段</font>和<font color=red>初始化阶段</font>，下面一起进行说明，按调用顺序为：</p>
<ol>
<li>postProcessBeforeInstantiation：实例化bean之前，相当于new这个bean之前</li>
<li>postProcessAfterInstantiation：实例化bean之后，相当于new这个bean之后</li>
<li>postProcessPropertyValues：bean已经实例化完成，在属性注入时阶段触发，@Autowired,@Resource等注解原理基于此方法实现</li>
<li>postProcessBeforeInitialization：初始化bean之前，相当于把bean注入spring上下文之前</li>
<li>postProcessAfterInitialization：初始化bean之后，相当于把bean注入spring上下文之后</li>
</ol>
<p>使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。</p>
<pre><code class="language-java">public class TestInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {

@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before initialization &quot; + beanName);
    return bean;
}

@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after initialization &quot; + beanName);
    return bean;
}

@Override
public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException {
    System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before instantiation &quot; + beanName);
    return null;
}

@Override
public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
    System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after instantiation &quot; + beanName);
    return true;
}

@Override
public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {
    System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues &quot; + beanName);
    return pvs;
}
</code></pre>
<h3 id="25-smartinstantiationawarebeanpostprocessor">2.5 SmartInstantiationAwareBeanPostProcessor</h3>
<blockquote>
<p>org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor</p>
</blockquote>
<p>该扩展接口有3个触发点方法：</p>
<ol>
<li><code>predictBeanType</code>：该触发点发生在postProcessBeforeInstantiation之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</li>
<li><code>determineCandidateConstructors</code>：该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</li>
<li><code>getEarlyBeanReference</code>：该触发点发生在postProcessAfterInstantiation之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。</li>
</ol>
<pre><code class="language-java">public class TestSmartInstantiationAwareBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor {

    @Override
    public Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) throws BeansException {
        System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType &quot; + beanName);
        return beanClass;
    }

    @Override
    public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) throws BeansException {
        System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors &quot; + beanName);
        return null;
    }

    @Override
    public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference &quot; + beanName);
        return bean;
    }
}
</code></pre>
<h3 id="26-beanfactoryaware">2.6 BeanFactoryAware</h3>
<blockquote>
<p>org.springframework.beans.factory.BeanFactoryAware<br>
这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为setBeanFactory，可以拿到BeanFactory这个属性。</p>
</blockquote>
<p>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。也或者可以把BeanFactory拿到进行缓存，日后使用。</p>
<p>扩展方式为：</p>
<pre><code class="language-java">public class TestBeanFactoryAware implements BeanFactoryAware {
    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println(&quot;[TestBeanFactoryAware] &quot; + beanFactory.getBean(TestBeanFactoryAware.class).getClass().getSimpleName());
    }
}
</code></pre>
<h3 id="27-applicationcontextawareprocessor">2.7 ApplicationContextAwareProcessor</h3>
<blockquote>
<p>org.springframework.context.support.ApplicationContextAwareProcessor<br>
该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前</p>
</blockquote>
<p>该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行扩展接口，来获取对应容器的变量。</p>
<ol>
<li><code>EnvironmentAware</code>：用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。</li>
<li><code>EmbeddedValueResolverAware</code>：用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取，如果实现了这个Aware接口，把StringValueResolver缓存起来，通过这个类去获取String类型的变量，效果是一样的。</li>
<li><code>ResourceLoaderAware</code>：用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。</li>
<li><code>ApplicationEventPublisherAware</code>：用于获取ApplicationEventPublisher的一个扩展类，ApplicationEventPublisher可以用来发布事件，结合ApplicationListener来共同使用，下文在介绍ApplicationListener时会详细提到。这个对象也可以通过spring注入的方式来获得。</li>
<li><code>MessageSourceAware</code>：用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。</li>
<li><code>ApplicationContextAware</code>：用来获取ApplicationContext的一个扩展类，ApplicationContext应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时ApplicationContext也实现了BeanFactory，MessageSource，ApplicationEventPublisher等接口，也可以用来做相关接口的事情。</li>
</ol>
<h3 id="28-beannameaware">2.8 BeanNameAware</h3>
<blockquote>
<p>org.springframework.beans.factory.BeanNameAware<br>
可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是<code>postProcessBeforeInitialization</code>之前，这个类的触发点方法只有一个：<code>setBeanName</code></p>
</blockquote>
<p>使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p>
<p>扩展方式为：</p>
<pre><code class="language-java">public class NormalBeanA implements BeanNameAware{
    public NormalBeanA() {
        System.out.println(&quot;NormalBean constructor&quot;);
    }

    @Override
    public void setBeanName(String name) {
        System.out.println(&quot;[BeanNameAware] &quot; + name);
    }
}
</code></pre>
<h3 id="29-postconstruct">2.9 @PostConstruct</h3>
<blockquote>
<p>javax.annotation.PostConstruct<br>
这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了@PostConstruct，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在<code>postProcessBeforeInitialization</code>之后，<code>InitializingBean.afterPropertiesSet</code>之前。</p>
</blockquote>
<p>使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性</p>
<p>扩展方式为：</p>
<pre><code class="language-java">public class NormalBeanA {
    public NormalBeanA() {
        System.out.println(&quot;NormalBean constructor&quot;);
    }

    @PostConstruct
    public void init(){
        System.out.println(&quot;[PostConstruct] NormalBeanA&quot;);
    }
}
</code></pre>
<h3 id="210-initializingbean">2.10 InitializingBean</h3>
<blockquote>
<p>org.springframework.beans.factory.InitializingBean<br>
这个类，顾名思义，也是用来初始化bean的。InitializingBean接口为bean提供了初始化方法的方式，它只包括<code>afterPropertiesSet</code>方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在<code>postProcessAfterInitialization</code>之前。</p>
</blockquote>
<p>使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。</p>
<p>扩展方式为：</p>
<pre><code class="language-java">public class NormalBeanA implements InitializingBean{
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;[InitializingBean] NormalBeanA&quot;);
    }
}
</code></pre>
<h3 id="211-factorybean">2.11 FactoryBean</h3>
<blockquote>
<p>org.springframework.beans.factory.FactoryBean<br>
一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个<code>org.springframework.bean.factory.FactoryBean</code>的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。</p>
</blockquote>
<p>它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为<code>FactoryBean&lt;T&gt;</code>的形式</p>
<p>使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿ProxyFactoryBean的功能。</p>
<pre><code class="language-java">public class TestFactoryBean implements FactoryBean&lt;TestFactoryBean.TestFactoryInnerBean&gt; {

    @Override
    public TestFactoryBean.TestFactoryInnerBean getObject() throws Exception {
        System.out.println(&quot;[FactoryBean] getObject&quot;);
        return new TestFactoryBean.TestFactoryInnerBean();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return TestFactoryBean.TestFactoryInnerBean.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }

    public static class TestFactoryInnerBean{

    }
}
</code></pre>
<h3 id="212-smartinitializingsingleton">2.12 SmartInitializingSingleton</h3>
<blockquote>
<p>org.springframework.beans.factory.SmartInitializingSingleton<br>
这个接口中只有一个方法<code>afterSingletonsInstantiated</code>，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为<code>postProcessAfterInitialization</code>之后。</p>
</blockquote>
<p>使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。</p>
<pre><code class="language-java">public class TestSmartInitializingSingleton implements SmartInitializingSingleton {
    @Override
    public void afterSingletonsInstantiated() {
        System.out.println(&quot;[TestSmartInitializingSingleton]&quot;);
    }
}
</code></pre>
<h3 id="213-commandlinerunner">2.13 CommandLineRunner</h3>
<blockquote>
<p>org.springframework.boot.CommandLineRunner<br>
这个接口也只有一个方法：<code>run(String... args)</code>，触发时机为整个项目启动完毕后，自动执行。如果有多个<code>CommandLineRunner</code>，可以利用<code>@Order</code>来进行排序。</p>
</blockquote>
<p>使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。</p>
<pre><code class="language-java">public class TestCommandLineRunner implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;[TestCommandLineRunner]&quot;);
    }
}
</code></pre>
<h3 id="214-disposablebean">2.14 DisposableBean</h3>
<blockquote>
<p>org.springframework.beans.factory.DisposableBean<br>
这个扩展点也只有一个方法：<code>destroy()</code>，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行<code>applicationContext.registerShutdownHook</code>时，就会触发这个方法。</p>
</blockquote>
<pre><code class="language-java">public class NormalBeanA implements DisposableBean {
    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;[DisposableBean] NormalBeanA&quot;);
    }
}
</code></pre>
<h3 id="215-applicationlistener">2.15 ApplicationListener</h3>
<blockquote>
<p>org.springframework.context.ApplicationListener<br>
准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，ApplicationListener可以监听某个事件的<code>event</code>，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。</p>
</blockquote>
<p>接下来罗列下spring主要的内置事件：</p>
<ol>
<li>
<p>ContextRefreshedEvent<br>
ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext接口中使用 refresh() 方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用。</p>
</li>
<li>
<p>ContextStartedEvent<br>
当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</p>
</li>
<li>
<p>ContextStoppedEvent<br>
当使用 ConfigurableApplicationContext 接口中的 stop() 停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</p>
</li>
<li>
<p>ContextClosedEvent<br>
当使用 ConfigurableApplicationContext接口中的 close()方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</p>
</li>
<li>
<p>RequestHandledEvent<br>
这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</p>
</li>
</ol>

							</div>
	<div class="wow bounceInDown vt-post-tags">
 
				<a href="https://q456qq520.github.io/tag/F2G_SSJak/" rel="tag">spring</a>	
				 
					</div>						
<nav class="navigation3 post-navigation3" role="navigation">
		
		<div class="nav-links3">
      
		<div class="wow bounceInLeft nav-previous3"><a href="https://q456qq520.github.io/post/mian-shi-ti-er/" rel="prev"> 面试题（二）</a></div>
		 
		 
		<div class="wow bounceInRight nav-next3"><a href="https://q456qq520.github.io/post/semaphore-shi-xian-yuan-li/" rel="next"> Semaphore实现原理</a></div>
		
		</div>
	</nav>
	<div class="wow rollIn author-info" style="visibility: visible; animation-name: rollIn;">
	<div class="author-avatar pull-left"><img src="https://q456qq520.github.io/images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">LIKECAT</div></div>


	<p class="author-bio">一条小咸鱼</p></div></div>
	
		</div>
		
 
		
</article>

<div id="marlin_lite_about_widget-2" class="wow bounceInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">
		
        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1e61bc4630cf7e3c0b8e',
    clientSecret: 'd1728142222f511a472443c6e499356387ab3b96',
    repo: 'q456qq520.github.io',
    owner: 'q456qq520',
    admin: ['q456qq520'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          
          
        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://q456qq520.github.io/media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            // AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)
            av: AV, 
            el: '.comment',
            lang: 'zh-cn',
            
            
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     	
      	
          
        });
    </script> 


   
  
 

		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">
	
        <div class="toc-widget">
			
            <div class="toc-title"></div>
			
            <div id="toc-content">
			
			
			</div>
        </div>
    </div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.5.0/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>										 

 
       


			</div>
		</div>

		
		 	<footer id="colophon" class="site-footer">

			<div class="container">
	
				<div class="copyright">Powered by <a href="https://blog.csdn.net/weixin_42652031" target="_blank">一条小咸鱼</a><br>Theme:   <a href="https://github.com/alterfang/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>. Powered by <a href="https://gridea.dev/" target="_blank" title="Gridea"><span>Gridea</span></a></div>		
			</div>
		
		</footer>

</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://q456qq520.github.io/media/scripts/marlin-scripts.js'></script>
 <script src="//tokinx.github.io/lately/lately.min.js"></script>
  <script>jQuery(document).ready(function(){$.lately({'target':'.lately-a,.lately-b,.lately-c'})});</script>
  <style type="text/css">a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
}

a.back_to_top span {
    color: #888;
}

a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
}

a.back_to_top:hover span {
    color: #555;
}

@media print, screen and (max-width: 580px) {
    .back_to_top {
        display: none !important;
    }
}



</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>


<script>$(document).ready((function(_this) {
  return function() {
    var bt;
    bt = $('#back_to_top');
    if ($(document).width() > 480) {
      $(window).scroll(function() {
        var st;
        st = $(window).scrollTop();
        if (st > 30) {
          return bt.css('display', 'block');
        } else {
          return bt.css('display', 'none');
        }
      });
      return bt.click(function() {
        $('body,html').animate({
          scrollTop: 0
        }, 800);
        return false;
      });
    }
  };
})(this));
</script>

		<script data-no-instant>
    (function ($) {
        $.extend({
            adamsOverload: function () {
                $('.navigation:eq(0)').remove();
                $("").attr("rel" , "external");
                $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
                $("a.vi").attr("rel" , "");
                $.viewImage({
                    'target'  : 'img',
                    'exclude' : '.vsmile-icons img,.gallery img',
                    'delay'   : 300
                });
                $.lately({
                    'target' : '.commentmetadata a,.infos time,.post-list time'
                });
                prettyPrint();
                
                $('ul.links li a').each(function(){
                    if($(this).parent().find('.bg').length==0){
                        $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
                    }
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
