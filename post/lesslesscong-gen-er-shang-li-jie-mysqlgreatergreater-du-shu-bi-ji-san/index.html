
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> 
<meta HTTP-EQUIV="expires" CONTENT="0"> 
<title>《从根儿上理解MySQL》读书笔记(三) | LIKECAT</title>	

<link rel="stylesheet" href="https://q456qq520.github.io/styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

        if (thehour<07)

            display = "https://q456qq520.github.io/media/css/night.css";

       else if (thehour>18)

            display = "https://q456qq520.github.io/media/css/night.css";   

        else if (thehour>07)
           
            display = "https://q456qq520.github.io/media/css/day.css";

        else if (thehour<18)

            display = "https://q456qq520.github.io/media/css/day.css";
      

var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://fonts.googleapis.com/css?family=Dancing+Script|Noto+Sans+SC:300|Montserrat&display=swap" rel="stylesheet">
<link href="https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<script type='text/javascript' src='https://q456qq520.github.io/media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>


 	
</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">
        
			
		<header id="header" class="site-header" 
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://q456qq520.github.io" rel="home">LIKECAT</a></h1>
										
					<h2 class="site-description">一条小咸鱼</h2>
										
							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 
     			
<li>
	 
	<a  href="/"> 首页</a></li>
	
    
     			
<li>
	 
	<a  href="/archives"> 归档</a></li>
	
    
     			
<li>
	 
	<a  href="/tags"> 标签</a></li>
	
    
     			
<li>
	 
	<a  href="/post/about"> 关于</a></li>
	
    
     			
<li>
	 
	<a  href="https://q456qq520.github.io/tag/CH4G4OVER/"> 设计模式</a></li>
	
    
     			
<li>
	 
	<a  href="https://q456qq520.github.io/tag/fenbushi/"> 分布式</a></li>
	
    

</ul>
</li>		
		
</ul>				</div>
			</nav>
						<div class="jingge">


    

    

    

    

    

    

    

    

    

    

    

    
        </header>

		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">
				
<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">

	
	                      
		<div class="entry-content">
			<h1 class="wow swing entry-title">《从根儿上理解MySQL》读书笔记(三)</h1>
<div class="entry-meta">
<div class="wow bounce">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2023-01-13 18:14:23" itemprop="datePublished" pubdate="">2023-01-13</time></i>
	          </div>
			
</span>
													 
		</div>
                  
			<div class="wow slideInLeft entry-summary song">
				<h2 id="第10章-条条大路通罗马-单表访问方法">第10章 条条大路通罗马-单表访问方法</h2>
<p>MySQL Server有一个称为查询优化器的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。不过查询优化这个主题有点儿大，在学会跑之前还得先学会走，所以本章先来看看MySQL怎么执行单表查询（就是FROM子句后边只有一个表，最简单的那种查询～）。</p>
<!-- more -->
<pre><code class="language-mysql">CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
</code></pre>
<p>我们为这个single_table表建立了1个聚簇索引和4个二级索引。然后我们需要为这个表插入10000行记录。</p>
<h3 id="101-访问方法access-method的概念">10.1 访问方法（access method）的概念</h3>
<p>MySQL把查询的执行方式大致分为下面两种：</p>
<ol>
<li>
<p>使用全表扫描进行查询<br>
  这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。不管是什么查询都可以使用这种方式执行，当然，这种也是最笨的执行方式。</p>
</li>
<li>
<p>使用索引进行查询<br>
  因为直接使用全表扫描的方式执行查询要遍历好多记录，所以代价可能太大了。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类：</p>
<ul>
<li>针对主键或唯一二级索引的等值查询</li>
<li>针对普通二级索引的等值查询</li>
<li>针对索引列的范围查询</li>
<li>直接扫描整个索引</li>
</ul>
</li>
</ol>
<p>把MySQL执行查询语句的方式称之为<code>访问方法</code>或者<code>访问类型</code>。同一个查询语句可能可以使用多种不同的访问方法来执行，虽然最后的查询结果都是一样的，但是执行的时间可能差老远了，下面细细道来各种访问方法的具体内容。</p>
<ol>
<li>const<br>
  有的时候我们可以通过主键列来定位一条记录，比方说这个查询：</li>
</ol>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE id = 1438;
</code></pre>
<p>MySQL会直接利用主键值在聚簇索引中定位对应的用户记录，就像这样：<br>
<img src="https://q456qq520.github.io/post-images/1673839553874.png" alt="" loading="lazy"></p>
<p>我们忽略掉了页的结构，直接把所有的叶子节点的记录都放在一起展示，而且记录中只展示我们关心的索引列，对于single_table表的聚簇索引来说，展示的就是id列。我们想突出的重点就是：B+树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的B+树叶子节点中的记录就是按照id列排序的。所以这样根据主键值定位一条记录的速度贼快。类似的，我们根据唯一二级索引列来定位一条记录的速度也是贼快的，比如下面这个查询：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key2 = 3841;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1673839657085.png" alt="" loading="lazy"></figure>
<p>可以看到这个查询的执行分两步，第一步先从idx_key2对应的B+树索引中根据key2列与常数的等值比较条件定位到一条二级索引记录，然后再根据该记录的id值到聚簇索引中获取到完整的用户记录。</p>
<p>把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：const，意思是常数级别的，代价是可以忽略不计的。不过这种const访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个const访问方法才有效。</p>
<p>对于唯一二级索引来说，查询该列为NULL值的情况比较特殊，比如这样：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key2 IS NULL;
</code></pre>
<p>因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上面这个语句不可以使用const访问方法来执行。</p>
<ol start="2">
<li>ref<br>
 有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：</li>
</ol>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 = 'abc';
</code></pre>
<p>对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的id值，然后再回表到聚簇索引中查找完整的用户记录。由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，所以MySQL可能选择使用索引而不是全表扫描的方式来执行查询。设计MySQL的大佬就把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：<code>ref</code>。我们看一下采用ref访问方法执行查询的图示：</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1673841047507.png" alt="" loading="lazy"></figure>
<p>从图示中可以看出，对于普通的二级索引来说，通过索引列进行等值比较后可能匹配到多条连续的记录，而不是像主键或者唯一二级索引那样最多只能匹配1条记录，所以这种ref访问方法比const差了那么一丢丢，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的（如果匹配的二级索引记录太多那么回表的成本就太大了），不过需要注意下面两种情况：</p>
<pre><code>-  二级索引列值为NULL的情况
</code></pre>
<p>不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含NULL值的数量并不限制，所以我们采用key IS NULL这种形式的搜索条件最多只能使用ref的访问方法，而不是const的访问方法。<br>
- 对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用ref的访问方法，比方说下面这几个查询：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key_part1 = 'god like';

SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary';

SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary' AND key_part3 = 'penta kill';
</code></pre>
<p>但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为ref了，比方说这样：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 &gt; 'legendary';
</code></pre>
<ol start="3">
<li>ref_or_null<br>
有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为NULL的记录也找出来，就像下面这个查询：</li>
</ol>
<pre><code class="language-mysql">SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;
</code></pre>
<p>当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为ref_or_null，这个ref_or_null访问方法的执行过程同上面基本类似。相当于先分别从idx_key1索引对应的B+树中找出key1 IS NULL和key1 = 'abc'的两个连续的记录范围，然后根据这些二级索引记录中的id值再回表查找完整的用户记录。</p>
<ol start="4">
<li>range</li>
</ol>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;= 38 AND key2 &lt;= 79);
</code></pre>
<p>我们当然还可以使用全表扫描的方式来执行这个查询，不过也可以使用二级索引 + 回表的方式执行，如果采用二级索引 + 回表的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值，在本查询中key2列的值只要匹配下列3个范围中的任何一个就算是匹配成功了：<br>
- key2的值是1438<br>
- key2的值是6328<br>
- key2的值在38和79之间。<br>
把这种利用索引进行范围匹配的访问方法称之为：<code>range</code>。</p>
<ol start="5">
<li>index</li>
</ol>
<pre><code class="language-mysql">SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
</code></pre>
<p>由于key_part2并不是联合索引idx_key_part最左索引列，所以我们无法使用ref或者range访问方法来执行这个语句。但是这个查询符合下面这两个条件：</p>
<pre><code>- 它的查询列表只有3个列：key_part1, key_part2, key_part3，而索引idx_key_part又包含这三个列。
- 搜索条件中只有key_part2列。这个列也包含在索引idx_key_part中。
</code></pre>
<p>也就是说我们可以直接通过遍历idx_key_part索引的叶子节点的记录来比较key_part2 = 'abc'这个条件是否成立，把匹配成功的二级索引记录的key_part1, key_part2, key_part3列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，MySQL就把这种采用遍历二级索引记录的执行方式称之为：<code>index</code>。</p>
<ol start="6">
<li>all<br>
最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于InnoDB表来说也就是直接扫描聚簇索引，MySQL把这种使用全表扫描执行查询的方式称之为：<code>all</code>。</li>
</ol>
<h3 id="102-注意事项">10.2 注意事项</h3>
<h4 id="1021-重温-二级索引-回表">10.2.1 重温 二级索引 + 回表</h4>
<p>一般情况下只能利用单个二级索引执行查询，比方说下面的这个查询：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 = 'abc' AND key2 &gt; 1000;
</code></pre>
<p>查询优化器会识别到这个查询中的两个搜索条件：<br>
- key1 = 'abc'<br>
- key2 &gt; 1000</p>
<p>优化器一般会根据single_table表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的WHERE条件过滤记录。</p>
<p>一般来说，等值查找比范围查找需要扫描的行数更少（也就是ref的访问方法一般比range好，但这也不总是一定的，也可能采用ref访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用idx_key1索引进行查询，那么整个查询过程可以分为两个步骤：</p>
<pre><code>- 步骤1：使用二级索引定位记录的阶段，也就是根据条件key1 = 'abc'从idx_key1索引代表的B+树中找到对应的二级索引记录。
- 步骤2：回表阶段，也就是根据上一步骤中找到的记录的主键值进行回表操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件key2 &gt; 1000到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。
</code></pre>
<p>这里需要特别提醒大家的一点是，因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用idx_key1索引进行查询时只会用到与key1列有关的搜索条件，其余条件，比如key2 &gt; 1000这个条件在步骤1中是用不到的，只有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤。</p>
<h4 id="1022-明确range访问方法使用的范围区间">10.2.2 明确range访问方法使用的范围区间</h4>
<p>其实对于B+树索引来说，只要索引列和常数使用<code>=、&lt;=&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;=、&lt;=、BETWEEN、!=（不等于也可以写成&lt;&gt;）</code>或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的区间。</p>
<p>当我们想使用range访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。下面分两种情况看一下怎么从由AND或OR组成的复杂搜索条件中提取出正确的范围区间。</p>
<h5 id="所有搜索条件都可以使用某个索引的情况">所有搜索条件都可以使用某个索引的情况</h5>
<p>有时候每个搜索条件都可以使用到某个索引，比如下面这个查询语句：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key2 &gt; 100 AND key2 &gt; 200;
</code></pre>
<p>这个查询中的搜索条件都可以使用到key2，也就是说每个搜索条件都对应着一个idx_key2的范围区间。这两个小的搜索条件使用AND连接起来，也就是要取两个范围区间的交集，在我们使用range访问方法执行查询时，使用的idx_key2索引的范围区间的确定过程就如下图所示：<br>
<img src="https://q456qq520.github.io/post-images/1673857794078.png" alt="" loading="lazy"></p>
<p>key2 &gt; 100和key2 &gt; 200交集当然就是key2 &gt; 200了，也就是说上面这个查询使用idx_key2的范围区间就是(200, +∞)。</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key2 &gt; 100 OR key2 &gt; 200;
</code></pre>
<p>上面这个查询使用idx_key2的范围区间就是(100， +∞)。</p>
<h5 id="有的搜索条件无法使用索引的情况">有的搜索条件无法使用索引的情况</h5>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key2 &gt; 100 AND common_field = 'abc';
</code></pre>
<p>这个查询语句中能利用的索引只有idx_key2一个，而idx_key2这个二级索引的记录中又不包含common_field这个字段，所以在使用二级索引idx_key2定位记录的阶段用不到common_field = 'abc'这个条件，这个条件是在回表获取了完整的用户记录后才使用的，而范围区间是为了到索引中取记录中提出的概念，所以在确定范围区间的时候不需要考虑common_field = 'abc'这个条件，我们在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为TRUE就好了。</p>
<p>也就是说上面那个查询使用idx_key2的范围区间就是：(100, +∞)。</p>
<p>再来看一下使用OR的情况：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key2 &gt; 100 OR common_field = 'abc';
</code></pre>
<p>化简后：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key2 &gt; 100 OR TRUE;
SELECT * FROM single_table WHERE TRUE;
</code></pre>
<p>这也就说说明如果我们强制使用idx_key2执行查询的话，对应的范围区间就是(-∞, +∞)，也就是需要将全部二级索引的记录进行回表，这个代价肯定比直接全表扫描都大了。也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用OR连接起来后是无法使用该索引的。</p>
<blockquote>
<p>小贴士：之所以把用不到索引的搜索条件替换为TRUE，是因为我们不打算使用这些条件进行在该索引上进行过滤，所以不管索引的记录满不满足这些条件，我们都把它们选取出来，待到之后回表的时候再使用它们过滤。</p>
</blockquote>
<h5 id="复杂搜索条件下找出范围匹配的区间">复杂搜索条件下找出范围匹配的区间</h5>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE 
        (key1 &gt; 'xyz' AND key2 = 748 ) OR
        (key1 &lt; 'abc' AND key1 &gt; 'lmn') OR
        (key1 LIKE '%suf' AND key1 &gt; 'zzz' AND (key2 &lt; 8000 OR common_field = 'abc')) ;
</code></pre>
<ol>
<li>
<p>首先查看WHERE子句中的搜索条件都涉及到了哪些列，哪些列可能使用到索引。<br>
  这个查询的搜索条件涉及到了key1、key2、common_field这3个列，然后key1列有普通的二级索引idx_key1，key2列有唯一二级索引idx_key2。</p>
</li>
<li>
<p>对于那些可能用到的索引，分析它们的范围区间。<br>
假设我们使用idx_key1执行查询，我们需要把那些用不到该索引的搜索条件暂时移除掉，移除方法也简单，直接把它们替换为TRUE就好了。上面的查询中除了有关key2和common_field列不能使用到idx_key1索引外，key1 LIKE '%suf'也使用不到索引，所以把这些搜索条件替换为TRUE之后的样子就是这样：</p>
</li>
</ol>
<pre><code class="language-mysql">(key1 &gt; 'xyz' AND TRUE ) OR
(key1 &lt; 'abc' AND key1 &gt; 'lmn') OR
(TRUE AND key1 &gt; 'zzz' AND (TRUE OR TRUE))

(key1 &gt; 'xyz') OR
(key1 &lt; 'abc' AND key1 &gt; 'lmn') OR
(key1 &gt; 'zzz')

# 替换掉永远为TRUE或FALSE的条件,因为符合key1 &lt; 'abc' AND key1 &gt; 'lmn'永远为FALSE
(key1 &gt; 'xyz') OR (key1 &gt; 'zzz')
</code></pre>
<p>key1 &gt; 'xyz'和key1 &gt; 'zzz'之间使用OR操作符连接起来的，意味着要取并集，所以最终的结果化简的到的区间就是：key1 &gt; xyz。也就是说：上面那个有一坨搜索条件的查询语句如果使用 idx_key1 索引执行查询的话，需要把满足key1 &gt; xyz的二级索引记录都取出来，然后拿着这些记录的id再进行回表，得到完整的用户记录之后再使用其他的搜索条件进行过滤。</p>
<p>假设我们使用idx_key2执行查询同理，我们需要把那些用不到该索引的搜索条件暂时使用TRUE条件替换掉，其中有关key1和common_field的搜索条件都需要被替换掉。</p>
<h3 id="103-索引合并">10.3 索引合并</h3>
<p>MySQL在一般情况下执行一个查询时最多只会用到单个二级索引，但不是还有特殊情况么，在这些特殊情况下也可能在一个查询中使用到多个二级索引，设计MySQL的大佬把这种使用到多个索引来完成一次查询的执行方法称之为：<code>index merge</code>，具体的索引合并算法有下面三种。</p>
<h4 id="1031-intersection合并">10.3.1 Intersection合并</h4>
<p>Intersection翻译过来的意思是交集。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下面这个查询：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
</code></pre>
<p>假设这个查询使用Intersection合并的方式执行的话，那这个过程就是这样的：</p>
<ol>
<li>从idx_key1二级索引对应的B+树中取出key1 = 'a'的相关记录。</li>
<li>从idx_key3二级索引对应的B+树中取出key3 = 'b'的相关记录。</li>
<li>二级索引的记录都是由索引列 + 主键构成的，所以我们可以计算出这两个结果集中id值的交集。</li>
<li>按照上一步生成的id值列表进行回表操作，也就是从聚簇索引中把指定id值的完整用户记录取出来，返回给用户</li>
</ol>
<blockquote>
<p>虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是顺序I/O，而回表操作是随机I/O，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为回表而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。</p>
</blockquote>
<p>MySQL在某些特定的情况下才可能会使用到Intersection索引合并：<br>
- 情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。<br>
- 情况二：主键列可以是范围匹配</p>
<p>对于InnoDB的二级索引来说，记录先是按照索引列进行排序，如果该二级索引是一个联合索引，那么会按照联合索引中的各个列依次排序。而二级索引的用户记录是由索引列 + 主键构成的，二级索引列的值相同的记录可能会有好多条，这些索引列的值相同的记录又是按照主键的值进行排序的。所以重点来了，之所以在二级索引列都是等值匹配的情况下才可能使用Intersection索引合并，是因为<mark>只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。</mark></p>
<p>另外，不仅是多个二级索引之间可以采用Intersection索引合并，索引合并也可以有聚簇索引参加，也就是我们上面写的情况二：在搜索条件中有主键的范围匹配的情况下也可以使用Intersection索引合并索引合并。为什么主键这就可以范围匹配了？还是得回到应用场景里，比如看下面这个查询：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 = 'a' AND id &gt; 100;
</code></pre>
<p>假设这个查询可以采用Intersection索引合并，我们理所当然的以为这个查询会分别按照id &gt; 100这个条件从聚簇索引中获取一些记录，在通过key1 = 'a'这个条件从idx_key1二级索引中获取一些记录，然后再求交集，其实这样就把问题复杂化了，没必要从聚簇索引中获取一次记录。别忘了二级索引的记录中都带有主键值的，所以可以在从idx_key1中获取到的主键值上直接运用条件id &gt; 100过滤就行了，这样多简单。所以涉及主键的搜索条件只不过是为了从别的二级索引得到的结果集中过滤记录罢了，是不是等值匹配不重要。</p>
<p>当然，上面说的情况一和情况二只是发生Intersection索引合并的必要条件，不是充分条件。也就是说即使情况一、情况二成立，也不一定发生Intersection索引合并，这得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过Intersection索引合并后需要回表的记录数大大减少时才会使用Intersection索引合并。</p>
<h4 id="1032-union合并">10.3.2 Union合并</h4>
<p>我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是OR关系。有时候OR关系的不同搜索条件会使用到不同的索引，比方说这样：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'
</code></pre>
<p>Intersection是交集的意思，这适用于使用不同索引的搜索条件之间使用AND连接起来的情况；Union是并集的意思，适用于使用不同索引的搜索条件之间使用OR连接起来的情况。与Intersection索引合并类似，MySQL在某些特定的情况下才可能会使用到Union索引合并：</p>
<ol>
<li>情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。<br>
  比方说下面这个查询可能用到idx_key1和idx_key_part这两个二级索引进行Union索引合并的操作：</li>
</ol>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 = 'a' OR ( key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c');
</code></pre>
<p>而下面这两个查询就不能进行Union索引合并：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 &gt; 'a' OR (key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c');

SELECT * FROM single_table WHERE key1 = 'a' OR key_part1 = 'a';
</code></pre>
<p>第一个查询是因为对key1进行了范围匹配，第二个查询是因为联合索引idx_key_part中的key_part2列并没有出现在搜索条件中，所以这两个查询不能进行Union索引合并。</p>
<ol start="2">
<li>
<p>情况二：主键列可以是范围匹配</p>
</li>
<li>
<p>情况三：使用Intersection索引合并的搜索条件<br>
  这种情况其实也挺好理解，就是搜索条件的某些部分使用Intersection索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：</p>
</li>
</ol>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');
</code></pre>
<p>优化器可能采用这样的方式来执行这个查询：</p>
<ol>
<li>先按照搜索条件key1 = 'a' AND key3 = 'b'从索引idx_key1和idx_key3中使用Intersection索引合并的方式得到一个主键集合。</li>
<li>再按照搜索条件key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'从联合索引idx_key_part中得到另一个主键集合。</li>
<li>采用Union索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</li>
</ol>
<p>当然，查询条件符合了这些情况也不一定就会采用Union索引合并，也得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过Union索引合并后进行访问的代价比全表扫描更小时才会使用Union索引合并。</p>
<h4 id="1033-sort-union合并">10.3.3 Sort-Union合并</h4>
<p>Union索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下面这个查询就无法使用到Union索引合并：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 &lt; 'a' OR key3 &gt; 'z'
</code></pre>
<p>这是因为根据key1 &lt; 'a'从idx_key1索引中获取的二级索引记录的主键值不是排好序的，根据key3 &gt; 'z'从idx_key3索引中获取的二级索引记录的主键值也不是排好序的，但是key1 &lt; 'a'和key3 &gt; 'z'这两个条件又特别让我们动心，所以我们可以这样：</p>
<ol>
<li>先根据key1 &lt; 'a'条件从idx_key1二级索引总获取记录，并按照记录的主键值进行排序</li>
<li>再根据key3 &gt; 'z'条件从idx_key3二级索引总获取记录，并按照记录的主键值进行排序</li>
<li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和Union索引合并方式就一样了。</li>
</ol>
<p>我们把上述这种先按照二级索引记录的主键值进行排序，之后按照Union索引合并方式执行的方式称之为<code>Sort-Union索引合并</code>，很显然，这种Sort-Union索引合并比单纯的Union索引合并多了一步对二级索引记录的主键值排序的过程。</p>
<blockquote>
<p>小贴士：为什么有Sort-Union索引合并，就没有Sort-Intersection索引合并么？是的，的确没有Sort-Intersection索引合并这么一说，Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高，而Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了，所以也就没有引入Sort-Intersection这个玩意儿。</p>
</blockquote>
<h4 id="1034-索引合并注意事项">10.3.4 索引合并注意事项</h4>
<h5 id="联合索引替代intersection索引合并">联合索引替代Intersection索引合并</h5>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
</code></pre>
<p>这个查询之所以可能使用Intersection索引合并的方式执行，还不是因为idx_key1和idx_key3是两个单独的B+树索引，你要是把这两个列搞一个联合索引，那直接使用这个联合索引就把事情搞定了，何必用什么索引合并呢。</p>
<h2 id="第十一章-两个表的亲密接触-连接的原理">第十一章 两个表的亲密接触-连接的原理</h2>
<h3 id="111-连接简介">11.1 连接简介</h3>
<h4 id="1111-连接的本质">11.1.1 连接的本质</h4>
<pre><code class="language-mysql">mysql&gt; CREATE TABLE t1 (m1 int, n1 char(1));
Query OK, 0 rows affected (0.02 sec)

mysql&gt; CREATE TABLE t2 (m2 int, n2 char(1));
Query OK, 0 rows affected (0.02 sec)

mysql&gt; INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0
</code></pre>
<p>我们成功建立了t1、t2两个表，这两个表都有两个列，一个是INT类型的，一个是CHAR(1)类型的，填充好数据的两个表长这样：</p>
<pre><code class="language-mysql">mysql&gt; SELECT * FROM t1;
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.00 sec)

mysql&gt; SELECT * FROM t2;
+------+------+
| m2   | n2   |
+------+------+
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
3 rows in set (0.00 sec)
</code></pre>
<p>连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把t1和t2两个表连接起来的过程如下图所示：<br>
<img src="https://q456qq520.github.io/post-images/1673920033388.png" alt="" loading="lazy"><br>
这个过程看起来就是把t1表的记录和t2的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为<code>笛卡尔积</code>。因为表t1中有3条记录，表t2中也有3条记录，所以这两个表连接之后的笛卡尔积就有3×3=9行记录。</p>
<h4 id="1112-连接过程简介">11.1.2 连接过程简介</h4>
<p>我们可以连接任意数量张表，但是如果没有任何限制条件的话，这些表连接起来产生的笛卡尔积可能是非常巨大的。比方说3个100行记录的表连接起来产生的笛卡尔积就有100×100×100=1000000行数据！所以在连接的时候过滤掉特定记录组合是有必要的，在连接查询中的过滤条件可以分成两种：</p>
<ol>
<li>涉及单表的条件<br>
  这种只设计单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为搜索条件，比如t1.m1 &gt; 1是只针对t1表的过滤条件，t2.n2 &lt; 'd'是只针对t2表的过滤条件。</li>
<li>涉及两表的条件<br>
  这种过滤条件我们之前没见过，比如t1.m1 = t2.m2、t1.n1 &gt; t2.n2等，这些条件中涉及到了两个表。</li>
</ol>
<p>下面我们就要看一下携带过滤条件的连接查询的大致执行过程了，比方说下面这个查询语句：</p>
<pre><code class="language-mysql">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; 'd';
</code></pre>
<p>那么这个连接查询的大致执行过程如下：</p>
<ol>
<li>首先确定第一个需要查询的表，这个表称之为<code>驱动表</code>。只需要选取代价最小的那种访问方法去执行单表查询语句就好了（就是说从const、ref、ref_or_null、range、index、all这些执行方法中选取代价最小的去执行查询）。<br>
  此处假设使用t1作为驱动表，那么就需要到t1表中找满足t1.m1  &gt; 1的记录，因为表中的数据太少，我们也没在表上建立二级索引，所以此处查询t1表的访问方法就设定为all吧，也就是采用全表扫描的方式执行单表查询。</li>
<li>针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到t2表中查找匹配的记录，所谓匹配的记录，指的是符合过滤条件的记录。因为是根据t1表中的记录去找t2表中的记录，所以t2表也可以被称之为被驱动表。上一步骤从驱动表中得到了2条记录，所以需要查询2次t2表。此时涉及两个表的列的过滤条件t1.m1 = t2.m2就派上用场了：<br>
  - 当t1.m1 = 2时，过滤条件t1.m1 = t2.m2就相当于t2.m2 = 2，所以此时t2表相当于有了t2.m2 = 2、t2.n2 &lt; 'd'这两个过滤条件，然后到t2表中执行单表查询。<br>
  - 当t1.m1 = 3时，过滤条件t1.m1 = t2.m2就相当于t2.m2 = 3，所以此时t2表相当于有了t2.m2 = 3、t2.n2 &lt; 'd'这两个过滤条件，然后到t2表中执行单表查询。</li>
</ol>
<p>所以整个连接查询的执行过程就如下图所示：<br>
<img src="https://q456qq520.github.io/post-images/1673920484438.png" alt="" loading="lazy"></p>
<blockquote>
<p>从上面两个步骤可以看出来，我们上面介绍的这个两表连接查询共需要查询1次<code>t1</code>表，2次<code>t2</code>表。当然这是在特定的过滤条件下的结果，如果我们把<code>t1.m1 &gt; 1</code>这个条件去掉，那么从<code>t1</code>表中查出的记录就有3条，就需要查询3次<code>t2</code>表了。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p>
</blockquote>
<h3 id="112-内连接和外连接">11.2 内连接和外连接</h3>
<pre><code class="language-mysql">CREATE TABLE student (
    number INT NOT NULL AUTO_INCREMENT COMMENT '学号',
    name VARCHAR(5) COMMENT '姓名',
    major VARCHAR(30) COMMENT '专业',
    PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8 COMMENT '学生信息表';

CREATE TABLE score (
    number INT COMMENT '学号',
    subject VARCHAR(30) COMMENT '科目',
    score TINYINT COMMENT '成绩',
    PRIMARY KEY (number, score)
) Engine=InnoDB CHARSET=utf8 COMMENT '学生成绩表';
</code></pre>
<p>我们新建了一个学生信息表，一个学生成绩表，然后我们向上述两个表中插入一些数据:</p>
<pre><code class="language-mysql">mysql&gt; SELECT * FROM student;
+----------+-----------+--------------------------+
| number   | name      | major                    |
+----------+-----------+--------------------------+
| 20180101 | 杜子腾    | 软件学院                 |
| 20180102 | 范统      | 计算机科学与工程         |
| 20180103 | 史珍香    | 计算机科学与工程         |
+----------+-----------+--------------------------+
3 rows in set (0.00 sec)

mysql&gt; SELECT * FROM score;
+----------+-----------------------------+-------+
| number   | subject                     | score |
+----------+-----------------------------+-------+
| 20180101 | 母猪的产后护理              |    78 |
| 20180101 | 论萨达姆的战争准备          |    88 |
| 20180102 | 论萨达姆的战争准备          |    98 |
| 20180102 | 母猪的产后护理              |   100 |
+----------+-----------------------------+-------+
4 rows in set (0.00 sec)
</code></pre>
<p>现在我们想把每个学生的考试成绩都查询出来就需要进行两表连接了（因为score中没有姓名信息，所以不能单纯只查询score表）。连接过程就是从student表中取出记录，在score表中查找number相同的成绩记录，所以过滤条件就是student.number = socre.number，整个查询语句就是这样：</p>
<pre><code class="language-mysql">mysql&gt; SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1, score AS s2 WHERE s1.number = s2.number;
+----------+-----------+-----------------------------+-------+
| number   | name      | subject                     | score |
+----------+-----------+-----------------------------+-------+
| 20180101 | 杜子腾    | 母猪的产后护理              |    78 |
| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    88 |
| 20180102 | 范统      | 论萨达姆的战争准备          |    98 |
| 20180102 | 范统      | 母猪的产后护理              |   100 |
+----------+-----------+-----------------------------+-------+
4 rows in set (0.00 sec)
</code></pre>
<p>从上述查询结果中我们可以看到，各个同学对应的各科成绩就都被查出来了，可是有个问题，史珍香同学，也就是学号为20180103的同学因为某些原因没有参加考试，所以在score表中没有对应的成绩记录。那如果老师想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的连接查询是无法完成这样的需求的。</p>
<p>我们稍微思考一下这个需求，其本质是想：<mark>驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集</mark>。为了解决这个问题，就有了<code>内连接</code>和<code>外连接</code>的概念：</p>
<ol>
<li>对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上面提到的连接都是所谓的内连接。</li>
<li>对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。在MySQL中，根据选取驱动表的不同，外连接仍然可以细分为2种：
<ol>
<li>左外连接：选取左侧的表为驱动表。</li>
<li>右外连接：选取右侧的表为驱动表。</li>
</ol>
</li>
</ol>
<p>放在不同地方的过滤条件是有不同语义的：</p>
<ol>
<li>WHERE子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合WHERE子句中的过滤条件的记录都不会被加入最后的结果集。</li>
<li>ON子句中的过滤条件
<ul>
<li>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充。</li>
<li>需要注意的是，这个ON子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把ON子句放到内连接中，MySQL会把它和WHERE子句一样对待，也就是说：<mark>内连接中的WHERE子句和ON子句是等价的</mark>。</li>
<li>一般情况下，我们都把只涉及单表的过滤条件放到WHERE子句中，把涉及两表的过滤条件都放到ON子句中，我们也一般把放到ON子句中的过滤条件也称之为<code>连接条件</code>。</li>
</ul>
</li>
</ol>
<h4 id="1121-左外连接的语法">11.2.1 左（外）连接的语法</h4>
<pre><code class="language-mysql">SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
</code></pre>
<p>其中，中括号里的OUTER单词是可以省略的。对于LEFT JOIN类型的连接来说，我们把放在左边的表称之为外表或者驱动表，右边的表称之为内表或者被驱动表。</p>
<p>需要注意的是，对于左（外）连接和右（外）连接来说，必须使用ON子句来指出连接条件。</p>
<p>再次回到我们上面那个现实问题中来，看看怎样写查询语句才能把所有的学生的成绩信息都查询出来，即使是缺考的考生也应该被放到结果集中：</p>
<pre><code class="language-mysql">mysql&gt; SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1 LEFT JOIN score AS s2 ON s1.number = s2.number;
+----------+-----------+-----------------------------+-------+
| number   | name      | subject                     | score |
+----------+-----------+-----------------------------+-------+
| 20180101 | 杜子腾    | 母猪的产后护理              |    78 |
| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    88 |
| 20180102 | 范统      | 论萨达姆的战争准备          |    98 |
| 20180102 | 范统      | 母猪的产后护理              |   100 |
| 20180103 | 史珍香    | NULL                        |  NULL |
+----------+-----------+-----------------------------+-------+
5 rows in set (0.04 sec)
</code></pre>
<h4 id="1122-右外连接的语法">11.2.2 右（外）连接的语法</h4>
<p>右（外）连接和左（外）连接的原理是一样一样的，语法也只是把LEFT换成RIGHT而已：</p>
<pre><code class="language-mysql">SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
</code></pre>
<h4 id="1123-内连接的语法">11.2.3 内连接的语法</h4>
<p><mark>内连接和外连接的根本区别就是在驱动表中的记录不符合ON子句中的连接条件时不会把该记录加入到最后的结果集</mark>，我们最开始介绍的那些连接查询的类型都是内连接。不过之前仅仅提到了一种最简单的内连接语法，就是直接把需要连接的多个表都放到FROM子句后边。其实针对内连接，MySQL提供了好多不同的语法，我们以t1和t2表为例看看：</p>
<pre><code class="language-mysql">SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];
</code></pre>
<p>也就是说在MySQL中，下面这几种内连接的写法都是等价的：</p>
<pre><code class="language-mysql">SELECT * FROM t1 JOIN t2;
SELECT * FROM t1 INNER JOIN t2;
SELECT * FROM t1 CROSS JOIN t2;
SELECT * FROM t1, t2;
</code></pre>
<p><mark>由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句。</mark></p>
<p>我们前面说过，连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。不论哪个表作为驱动表，两表连接产生的笛卡尔积肯定是一样的。</p>
<p>而对于内连接来说，由于凡是不符合ON子句或WHERE子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的笛卡尔积中把不符合过滤条件的记录给踢出去，所以<mark>对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果</mark>。但是对于外连接来说，由于驱动表中的记录即使在被驱动表中找不到符合ON子句连接条件的记录，所以此时驱动表和被驱动表的关系就很重要了，也就是说<mark>左外连接和右外连接的驱动表和被驱动表不能轻易互换。</mark></p>
<h4 id="1124-小结">11.2.4 小结</h4>
<pre><code class="language-mysql">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)

mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
|    1 | a    | NULL | NULL |
+------+------+------+------+
3 rows in set (0.00 sec)

mysql&gt; SELECT * FROM t1 RIGHT JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
| NULL | NULL |    4 | d    |
+------+------+------+------+
3 rows in set (0.00 sec)
</code></pre>
<h3 id="113-连接的原理">11.3 连接的原理</h3>
<h4 id="1131-嵌套循环连接nested-loop-join">11.3.1 嵌套循环连接（Nested-Loop Join）</h4>
<p>我们上面已经大致介绍过t1表和t2表执行内连接查询的大致过程，我们温习一下：</p>
<ol>
<li>步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。</li>
<li>步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1673923077168.png" alt="" loading="lazy"></figure>
<p>如果有3个表进行连接的话，那么步骤2中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上面过程，也就是步骤2中得到的结果集中的每一条记录都需要到t3表中找一找有没有匹配的记录，用伪代码表示一下这个过程就是这样：</p>
<pre><code class="language-mysql">for each row in t1 {   #此处表示遍历满足对t1单表查询结果集中的每一条记录
    
    for each row in t2 {   #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录
    
        for each row in t3 {   #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询
            if row satisfies join conditions, send to client
        }
    }
}
</code></pre>
<p>这个过程就像是一个嵌套的循环，所以这种<mark>驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数</mark>的连接执行方式称之为<code>嵌套循环连接（Nested-Loop Join）</code>，这是最简单，也是最笨拙的一种连接查询算法。</p>
<h4 id="1132-使用索引加快连接速度">11.3.2 使用索引加快连接速度</h4>
<p>我们知道在嵌套循环连接的步骤2中可能需要访问多次被驱动表，如果访问被驱动表的方式都是全表扫描的话，那得要扫描好多次。但是别忘了，查询t2表其实就相当于一次单表扫描，我们可以利用索引来加快查询速度。</p>
<pre><code class="language-mysql">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; 'd';
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1673920484438.png" alt="" loading="lazy"></figure>
<p>查询驱动表t1后的结果集中有两条记录，嵌套循环连接算法需要对被驱动表查询2次：</p>
<ol>
<li>当t1.m1 = 2时，去查询一遍t2表，对t2表的查询语句相当于：</li>
</ol>
<pre><code class="language-mysql">SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 &lt; 'd';
</code></pre>
<ol start="2">
<li>当t1.m1 = 3时，再去查询一遍t2表，此时对t2表的查询语句相当于：</li>
</ol>
<pre><code class="language-mysql">SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 &lt; 'd';
</code></pre>
<p>可以看到，原来的t1.m1 = t2.m2这个涉及两个表的过滤条件在针对t2表做查询时关于t1表的条件就已经确定了，所以我们只需要单单优化对t2表的查询了，上述两个对t2表的查询语句中利用到的列是m2和n2列，我们可以：</p>
<ol>
<li>在m2列上建立索引，因为对m2列的条件是等值查找，比如t2.m2 = 2、t2.m2 = 3等，所以可能使用到ref的访问方法，假设使用ref的访问方法去执行对t2表的查询的话，需要回表之后再判断t2.n2 &lt; d这个条件是否成立。<br>
这里有一个比较特殊的情况，就是假设m2列是t2表的主键或者唯一二级索引列，那么使用t2.m2 = 常数值这样的条件从t2表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为const，而MySQL把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：<code>eq_ref</code>。</li>
<li>在n2列上建立索引，涉及到的条件是t2.n2 &lt; 'd'，可能用到range的访问方法，假设使用range的访问方法对t2表的查询的话，需要回表之后再判断在m2列上的条件是否成立。</li>
</ol>
<p>假设m2和n2列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对t2表的查询。当然，建立了索引不一定使用索引，只有在二级索引 + 回表的代价比全表扫描的代价更低时才会使用索引。</p>
<p>另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>或者<code>range</code>这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是<code>index</code>的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使用*作为查询列表，最好把真实用到的列作为查询列表。</p>
<h4 id="1133-基于块的嵌套循环连接block-nested-loop-join">11.3.3 基于块的嵌套循环连接（Block Nested-Loop Join）</h4>
<p>现实生活中的表可不像t1、t2这种只有3条记录，成千上万条记录都是少的，几百万、几千万甚至几亿条记录的表到处都是。内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前面记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前面的记录从内存中释放掉。我们前面又说过，采用<code>嵌套循环连接</code>算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个I/O代价就非常大了，所以我们得想办法：<mark>尽量减少访问被驱动表的次数</mark>。</p>
<p>当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。</p>
<p>所以我们可不可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。所以MySQL提出了一个<code>join buffer</code>的概念，join buffer就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O代价。使用join buffer的过程如下图所示：</p>
<figure data-type="image" tabindex="5"><img src="https://q456qq520.github.io/post-images/1673923811333.png" alt="" loading="lazy"></figure>
<p>最好的情况是join buffer足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。设计MySQL的大佬把这种加入了join buffer的嵌套循环连接算法称之为<code>基于块的嵌套连接（Block Nested-Loop Join）算法</code>。</p>
<p>这个join buffer的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为262144字节（也就是256KB），最小可以设置为128字节。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大join_buffer_size的值来对连接查询进行优化。</p>
<p>另外需要注意的是，驱动表的记录并不是所有列都会被放到join buffer中，只有查询列表中的列和过滤条件中的列才会被放到join buffer中，所以再次提醒我们，最好不要把*作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在join buffer中放置更多的记录呢。</p>
<h2 id="第十二章-谁最便宜就选谁-mysql基于成本的优化">第十二章 谁最便宜就选谁-MySQL基于成本的优化</h2>
<h3 id="121-什么是成本">12.1 什么是成本</h3>
<p>MySQL中一条查询语句的执行成本是由下面这两个方面组成的：</p>
<ol>
<li>I/O成本<br>
  我们的表经常使用的MyISAM、InnoDB存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为I/O成本。</li>
<li>CPU成本<br>
  读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为CPU成本。</li>
</ol>
<p>对于InnoDB存储引擎来说，页是磁盘和内存之间交互的基本单位，设计MySQL的大佬规定读取一个页面花费的成本默认是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。1.0、0.2这些数字称之为<code>成本常数</code>。</p>
<h3 id="122-单表查询的成本">12.2 单表查询的成本</h3>
<pre><code class="language-mysql">CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
</code></pre>
<p>假设这个表里边儿有10000条记录，除id列外其余的列都插入随机值。</p>
<h4 id="1221-基于成本的优化步骤">12.2.1 基于成本的优化步骤</h4>
<p>在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<code>执行计划</code>，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
<p>下面我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE 
    key1 IN ('a', 'b', 'c') AND 
    key2 &gt; 10 AND key2 &lt; 1000 AND 
    key3 &gt; key2 AND 
    key_part1 LIKE '%hello%' AND
    common_field = '123';
</code></pre>
<h5 id="根据搜索条件找出所有可能使用的索引">根据搜索条件，找出所有可能使用的索引</h5>
<p>对于B+树索引来说，只要索引列和常数使用=、&lt;=&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;=、&lt;=、BETWEEN、!=（不等于也可以写成&lt;&gt;）或者LIKE操作符连接起来，就可以产生一个所谓的范围区间（LIKE匹配字符串前缀也行），也就是说这些搜索条件都可能使用到索引，设计MySQL的大佬把一个查询中可能使用到的索引称之为<code>possible keys</code>。</p>
<p>我们分析一下上面查询中涉及到的几个搜索条件：</p>
<ul>
<li>key1 IN ('a', 'b', 'c')，这个搜索条件可以使用二级索引idx_key1。</li>
<li>key2 &gt; 10 AND key2 &lt; 1000，这个搜索条件可以使用二级索引idx_key2。</li>
<li>key3 &gt; key2，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</li>
<li>key_part1 LIKE '%hello%'，key_part1通过LIKE操作符和以通配符开头的字符串做比较，不可以适用索引。</li>
<li>common_field = '123'，由于该列上压根儿没有索引，所以不会用到索引。<br>
综上所述，上面的查询语句可能用到的索引，也就是possible keys只有idx_key1和idx_key2。</li>
</ul>
<h5 id="计算全表扫描的代价">计算全表扫描的代价</h5>
<p>对于InnoDB存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本=I/O成本+CPU成本，所以计算全表扫描的代价需要两个信息：</p>
<ul>
<li>聚簇索引占用的页面数</li>
<li>该表中的记录数</li>
</ul>
<p>这两个信息从哪来呢？MySQL为每个表维护了一系列的统计信息，MySQL给我们提供了SHOW TABLE STATUS语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的LIKE语句就好了，比方说我们要查看single_table这个表的统计信息可以这么写：</p>
<pre><code class="language-mysql">mysql&gt; SHOW TABLE STATUS LIKE 'single_table'\G
*************************** 1. row ***************************
           Name: single_table
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 9693
 Avg_row_length: 163
    Data_length: 1589248
Max_data_length: 0
   Index_length: 2752512
      Data_free: 4194304
 Auto_increment: 10001
    Create_time: 2018-12-10 13:37:23
    Update_time: 2018-12-10 13:38:03
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options:
        Comment:
1 row in set (0.01 sec)
</code></pre>
<ol>
<li>Rows<br>
本选项表示表中的记录条数。对于使用MyISAM存储引擎的表来说，该值是准确的，对于使用InnoDB存储引擎的表来说，该值是一个估计值。从查询结果我们也可以看出来，由于我们的single_table表是使用InnoDB存储引擎的，所以虽然实际上表中有10000条记录，但是SHOW TABLE STATUS显示的Rows值只有9693条记录。</li>
<li>Data_length<br>
本选项表示表占用的存储空间字节数。使用MyISAM存储引擎的表来说，该值就是数据文件的大小，对于使用InnoDB存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：<mark>Data_length = 聚簇索引的页面数量 x 每个页面的大小</mark><br>
我们的single_table使用默认16KB的页面大小，而上面查询结果显示Data_length的值是1589248，所以我们可以反向来推导出聚簇索引的页面数量：<mark>聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97</mark></li>
</ol>
<p>我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了，但是MySQL在真实计算成本时会进行一些微调，这些微调的值是直接硬编码到代码里的，，但是由于这些微调的值十分的小，并不影响我们分析，所以我们也没有必要在这些微调值上纠结了。现在可以看一下全表扫描成本的计算过程：</p>
<ol>
<li>I/O成本<br>
97 x 1.0 + 1.1 = 98.1<br>
97指的是聚簇索引占用的页面数，1.0指的是加载一个页面的成本常数，后边的1.1是一个微调值，我们不用在意。</li>
<li>CPU成本：<br>
9693 x 0.2 + 1.0 = 1939.6<br>
9693指的是统计数据中表的记录数，对于InnoDB存储引擎来说是一个估计值，0.2指的是访问一条记录所需的成本常数，后边的1.0是一个微调值，我们不用在意。</li>
<li>总成本<br>
98.1 + 1939.6 = 2037.7</li>
</ol>
<h5 id="计算使用不同索引执行查询的代价">计算使用不同索引执行查询的代价</h5>
<p>从第1步分析我们得到，上述查询可能使用到idx_key1和idx_key2这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。这里需要提一点的是，MySQL查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，所以我们也先分析idx_key2的成本，然后再看使用idx_key1的成本。</p>
<p><strong>使用idx_key2执行查询的成本分析</strong><br>
idx_key2对应的搜索条件是：key2 &gt; 10 AND key2 &lt; 1000，也就是说对应的范围区间就是：(10, 1000)。</p>
<p>对于使用二级索引 + 回表方式的查询，MySQL计算这种查询的成本依赖两个方面的数据：</p>
<ol>
<li>范围区间数量<br>
不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的I/O成本和读取一个页面是相同的。</li>
<li>需要回表的记录数<br>
优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算idx_key2在(10, 1000)这个范围区间中包含多少二级索引记录，计算过程是这样的：</li>
</ol>
<ul>
<li>步骤1：先根据key2 &gt; 10这个条件访问一下idx_key2对应的B+树索引，找到满足key2 &gt; 10这个条件的第一条记录，我们把这条记录称之为区间最左记录。我们前头说过在B+数树中定位一条记录的过程是贼快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的。</li>
<li>步骤2：然后再根据key2 &lt; 1000这个条件继续从idx_key2对应的B+树索引中找出第一条满足这个条件的记录，我们把这条记录称之为区间最右记录，这个过程的性能消耗也可以忽略不计的。</li>
<li>步骤3：如果区间最左记录和区间最右记录相隔不太远（在MySQL 5.7.21这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出满足key2 &gt; 10 AND key2 &lt; 1000条件的二级索引记录条数。否则只沿着区间最左记录向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量就可以了。</li>
</ul>
<p>根据上述算法测得idx_key2在区间(10, 1000)之间大约有95条记录。读取这95条二级索引记录需要付出的CPU成本就是：95 x 0.2 + 0.01 = 19.01，其中95是需要读取的二级索引记录条数，0.2是读取一条记录成本常数，0.01是微调。</p>
<p>在通过二级索引获取到记录之后，还需要干两件事儿：</p>
<ol>
<li>根据这些记录里的主键值到聚簇索引中做回表操作</li>
<li>回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立</li>
</ol>
<p><strong>使用idx_key1执行查询的成本分析</strong></p>
<h5 id="对比各种执行方案的代价找出成本最低的那一个">对比各种执行方案的代价，找出成本最低的那一个</h5>
<h3 id="123-基于索引统计数据的成本计算">12.3 基于索引统计数据的成本计算</h3>
<h3 id="基于索引统计数据的成本计算">基于索引统计数据的成本计算</h3>
<p>有时候使用索引执行查询时会有许多单点区间，比如使用<code>IN</code>语句就很容易产生非常多的单点区间，比如下面这个查询（下面查询语句中的<code>...</code>表示还有很多参数）：</p>
<pre><code class="language-mysql">SELECT * FROM single_table WHERE key1 IN ('aa1', 'aa2', 'aa3', ... , 'zzz');
</code></pre>
<p>很显然，这个查询可能使用到的索引就是<code>idx_key1</code>，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式我们上面已经介绍过了，就是先获取索引对应的<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。设计<code>MySQL</code>的大佬把这种通过直接访问索引对应的<code>B+</code>树来计算某个范围区间对应的索引记录条数的方式称之为<code>index dive</code>。</p>
<p>有零星几个单点区间的话，使用<code>index dive</code>的方式去计算这些单点区间对应的记录数也不是什么问题，可是你架不住憋足了劲往<code>IN</code>语句里塞东西呀，我就见过有的同学写的<code>IN</code>语句里有20000个参数的，这就意味着<code>MySQL</code>的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次<code>index dive</code>操作，这性能损耗可就大了，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。设计<code>MySQL</code>的大佬们多聪明啊，他们当然考虑到了这种情况，所以提供了一个系统变量<code>eq_range_index_dive_limit</code>，我们看一下在<code>MySQL 5.7.21</code>中这个系统变量的默认值：</p>
<pre><code class="language-mysql">mysql&gt; SHOW VARIABLES LIKE '%dive%'; 
+---------------------------+-------+ | Variable_name | Value | +---------------------------+-------+ | eq_range_index_dive_limit | 200 | +---------------------------+-------+ 
1 row in set (0.08 sec)
</code></pre>
<p>也就是说如果我们的<code>IN</code>语句中的参数个数小于200个的话，将使用<code>index dive</code>的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用<code>index dive</code>了，要使用所谓的索引统计数据来进行估算。</p>
<p>像会为每个表维护一份统计数据一样，<code>MySQL</code>也会为表中的每一个索引维护一份统计数据，查看某个表中索引的统计数据可以使用<code>SHOW INDEX FROM 表名</code>的语法，比如我们查看一下<code>single_table</code>的各个索引的统计数据可以这么写：</p>
<pre><code class="language-mysql">SHOW INDEX FROM single_table; 
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Table</code></td>
<td>索引所属表的名称。</td>
</tr>
<tr>
<td style="text-align:center"><code>Non_unique</code></td>
<td>索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为<code>0</code>，普通二级索引该列值为<code>1</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>Key_name</code></td>
<td>索引的名称。</td>
</tr>
<tr>
<td style="text-align:center"><code>Seq_in_index</code></td>
<td>索引列在索引中的位置，从1开始计数。比如对于联合索引<code>idx_key_part</code>，来说，<code>key_part1</code>、<code>key_part2</code>和<code>key_part3</code>对应的位置分别是1、2、3。</td>
</tr>
<tr>
<td style="text-align:center"><code>Column_name</code></td>
<td>索引列的名称。</td>
</tr>
<tr>
<td style="text-align:center"><code>Collation</code></td>
<td>索引列中的值是按照何种排序方式存放的，值为<code>A</code>时代表升序存放，为<code>NULL</code>时代表降序存放。</td>
</tr>
<tr>
<td style="text-align:center"><code>Cardinality</code></td>
<td>索引列中不重复值的数量。后边我们会重点看这个属性的。</td>
</tr>
<tr>
<td style="text-align:center"><code>Sub_part</code></td>
<td>对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前<code>n</code>个字符或字节建立索引，这个属性表示的就是那个<code>n</code>值。如果对完整的列建立索引的话，该属性的值就是<code>NULL</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>Packed</code></td>
<td>索引列如何被压缩，<code>NULL</code>值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。</td>
</tr>
<tr>
<td style="text-align:center"><code>Null</code></td>
<td>该索引列是否允许存储<code>NULL</code>值。</td>
</tr>
<tr>
<td style="text-align:center"><code>Index_type</code></td>
<td>使用索引的类型，我们最常见的就是<code>BTREE</code>，其实也就是<code>B+</code>树索引。</td>
</tr>
<tr>
<td style="text-align:center"><code>Comment</code></td>
<td>索引列注释信息。</td>
</tr>
<tr>
<td style="text-align:center"><code>Index_comment</code></td>
<td>索引注释信息。</td>
</tr>
</tbody>
</table>
<h3 id="124-连接查询的成本">12.4 连接查询的成本</h3>
<h4 id="1241-准备工作">12.4.1 准备工作</h4>
<p>连接查询至少是要有两个表的，只有一个<code>single_table</code>表是不够的，所以为了故事的顺利发展，我们直接构造一个和<code>single_table</code>表一模一样的<code>single_table2</code>表。为了简便起见，我们把<code>single_table</code>表称为<code>s1</code>表，把<code>single_table2</code>表称为<code>s2</code>表。</p>
<h4 id="1242-condition-filtering介绍">12.4.2 Condition filtering介绍</h4>
<p>我们前面说过，<code>MySQL</code>中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下面两个部分构成：</p>
<ul>
<li>单次查询驱动表的成本</li>
<li>多次查询被驱动表的成本（<span style="color:red">具体查询多少次取决于对驱动表查询的结果集中有多少条记录</span>）</li>
</ul>
<p>  我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code>（英文名：<code>fanout</code>）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候扇出值的计算是很容易的，比如下面这两个查询：</p>
<ul>
<li>查询一：<pre><code>SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2;
</code></pre>
假设使用<code>s1</code>表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。我们前面说过，统计数据中<code>s1</code>表的记录行数是<code>9693</code>，也就是说优化器就直接会把<code>9693</code>当作在<code>s1</code>表的扇出值。</li>
<li>查询二：<pre><code>SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 
WHERE s1.key2 &gt;10 AND s1.key2 &lt; 1000;
</code></pre>
仍然假设<code>s1</code>表是驱动表的话，很显然对驱动表的单表查询可以使用<code>idx_key2</code>索引执行查询。此时<code>idx_key2</code>的范围区间<code>(10, 1000)</code>中有多少条记录，那么扇出值就是多少。我们前面计算过，满足<code>idx_key2</code>的范围区间<code>(10, 1000)</code>的记录数是95条，也就是说本查询中优化器会把<code>95</code>当作驱动表<code>s1</code>的扇出值。</li>
</ul>
<p>这两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p>
<ul>
<li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。</li>
<li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li>
</ul>
<p>设计<code>MySQL</code>的大佬把这个<code>猜</code>的过程称之为<code>condition filtering</code>。</p>
<h3 id="125-两表连接的成本分析">12.5 两表连接的成本分析</h3>
<p>连接查询的成本计算公式是这样的：连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</p>
<p>对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：</p>
<ul>
<li>分别为驱动表和被驱动表选择成本最低的访问方法。<br>
可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</li>
<li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li>
<li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>最后优化器会比较最优访问成本，选取那个成本更低的连接顺序去真正的执行查询，连接查询成本占大头的其实是<code>驱动表扇出数 x 单次访问被驱动表的成本</code>，所以我们的优化重点其实是下面这两个部分：</p>
<ul>
<li>尽量减少驱动表的扇出</li>
<li>对被驱动表的访问成本尽量低</li>
</ul>
<p>这一点对于我们实际书写连接查询语句时十分有用，我们需要<span style="color:red">尽量在被驱动表的连接列上建立索引</span>，这样就可以使用<code>ref</code>访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。</p>
<h3 id="126-多表连接的成本分析">12.6 多表连接的成本分析</h3>
<p>首先要考虑一下多表连接时可能产生出多少种连接顺序：</p>
<ul>
<li>
<p>对于两表连接，比如表A和表B连接<br>
  只有 AB、BA这两种连接顺序。其实相当于<code>2 × 1 = 2</code>种连接顺序。</p>
</li>
<li>
<p>对于三表连接，比如表A、表B、表C进行连接<br>
  有ABC、ACB、BAC、BCA、CAB、CBA这么6种连接顺序。其实相当于<code>3 × 2 × 1 = 6</code>种连接顺序。</p>
</li>
<li>
<p>对于四表连接的话，则会有<code>4 × 3 × 2 × 1 = 24</code>种连接顺序。</p>
</li>
<li>
<p>对于<code>n</code>表连接的话，则有 <code>n × (n-1) × (n-2) × ··· × 1</code>种连接顺序，就是n的阶乘种连接顺序，也就是<code>n!</code>。<br>
  有<code>n</code>个表进行连接，<code>MySQL</code>查询优化器要每一种连接顺序的成本都计算一遍么？那可是<code>n!</code>种连接顺序呀。其实真的是要都算一遍，不过设计<code>MySQL</code>的大佬们想了很多办法减少计算非常多种连接顺序的成本的方法：</p>
</li>
<li>
<p>提前结束某种顺序的成本评估<br>
  <code>MySQL</code>在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就压根儿不对该连接顺序继续往下分析了。比方说A、B、C三个表进行连接，已经得到连接顺序<code>ABC</code>是当前的最小连接成本，比方说<code>10.0</code>，在计算连接顺序<code>BCA</code>时，发现<code>B</code>和<code>C</code>的连接成本就已经大于<code>10.0</code>时，就不再继续往后分析<code>BCA</code>这个连接顺序的成本了。</p>
</li>
<li>
<p>系统变量<code>optimizer_search_depth</code><br>
  为了防止无穷无尽的分析各种连接顺序的成本，MySQL提出了<code>optimizer_search_depth</code>系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与<code>optimizer_search_depth</code>值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。</p>
</li>
<li>
<p>根据某些规则压根儿就不考虑某些连接顺序<br>
  即使是有上面两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以设计<code>MySQL</code>的大佬干脆提出了一些所谓的<code>启发式规则</code>（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量<code>optimizer_prune_level</code>来控制到底是不是用这些启发式规则。</p>
</li>
</ul>
<h4 id="1261-调节成本常数">12.6.1 调节成本常数</h4>
<p>我们前面之介绍了两个<code>成本常数</code>：</p>
<ul>
<li>读取一个页面花费的成本默认是<code>1.0</code></li>
<li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li>
</ul>
<p>其实除了这两个成本常数，<code>MySQL</code>还支持好多呢，它们被存储到了<code>mysql</code>数据库的两个表中：<code>engine_cost | | server_cost</code></p>
<p>一条语句的执行其实是分为两层的：在<code>server</code>层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在<code>server</code>层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的<code>成本常数</code>就存储在了<code>server_cost</code>表中，而依赖于存储引擎的一些操作对应的<code>成本常数</code>就存储在了<code>engine_cost</code>表中。</p>
<h5 id="mysqlserver_cost表">mysql.server_cost表</h5>
<table>
<thead>
<tr>
<th style="text-align:center">成本常数名称</th>
<th style="text-align:center">默认值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>disk_temptable_create_cost</code></td>
<td style="text-align:center"><code>40.0</code></td>
<td style="text-align:left">创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td>
</tr>
<tr>
<td style="text-align:center"><code>disk_temptable_row_cost</code></td>
<td style="text-align:center"><code>1.0</code></td>
<td style="text-align:left">向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td>
</tr>
<tr>
<td style="text-align:center"><code>key_compare_cost</code></td>
<td style="text-align:center"><code>0.1</code></td>
<td style="text-align:left">两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升<code>filesort</code>的成本，让优化器可能更倾向于使用索引完成排序而不是<code>filesort</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>memory_temptable_create_cost</code></td>
<td style="text-align:center"><code>2.0</code></td>
<td style="text-align:left">创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td>
</tr>
<tr>
<td style="text-align:center"><code>memory_temptable_row_cost</code></td>
<td style="text-align:center"><code>0.2</code></td>
<td style="text-align:left">向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td>
</tr>
<tr>
<td style="text-align:center"><code>row_evaluate_cost</code></td>
<td style="text-align:center"><code>0.2</code></td>
<td style="text-align:left">这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。</td>
</tr>
</tbody>
</table>
<h5 id="mysqlengine_cost表">mysql.engine_cost表</h5>
<p>与<code>server_cost</code>相比，<code>engine_cost</code>多了两个列：</p>
<ul>
<li><code>engine_name</code>列：指成本常数适用的存储引擎名称。如果该值为<code>default</code>，意味着对应的成本常数适用于所有的存储引擎。</li>
<li><code>device_type</code>列：指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在<code>MySQL 5.7.21</code>这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是<code>0</code>。</li>
</ul>
<h2 id="第十三章-兵马未动粮草先行-innodb统计数据是如何收集的">第十三章 兵马未动，粮草先行-InnoDB统计数据是如何收集的</h2>
<p>我们前面介绍查询成本的时候经常用到一些统计数据，比如通过SHOW TABLE STATUS可以看到关于表的统计数据，通过SHOW INDEX可以看到关于索引的统计数据，那么这些统计数据是怎么来的呢？它们是以什么方式收集的呢？</p>
<h3 id="131-两种不同的统计数据存储方式">13.1 两种不同的统计数据存储方式</h3>
<p>InnoDB提供了两种存储统计数据的方式：</p>
<ol>
<li>永久性的统计数据<br>
  这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。</li>
<li>非永久性的统计数据<br>
  这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。</li>
</ol>
<p>MySQL给我们提供了系统变量innodb_stats_persistent来控制到底采用哪种方式去存储统计数据。在MySQL 5.6.6之前，innodb_stats_persistent的值默认是OFF，也就是说InnoDB的统计数据默认是存储到内存的，之后的版本中innodb_stats_persistent的值默认是ON，也就是统计数据默认被存储到磁盘中。</p>
<p>不过InnoDB默认是<mark>以表为单位来收集和存储统计数据的</mark>，也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。怎么做到的呢？我们可以在创建和修改表的时候通过指定STATS_PERSISTENT属性来指明该表的统计数据存储方式：</p>
<pre><code class="language-mysql">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);
ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0);
</code></pre>
<p>当 STATS_PERSISTENT=1 时，表明我们想把该表的统计数据永久的存储到磁盘上，当 STATS_PERSISTENT=0 时，表 明我们想把该表的统计数据临时的存储到内存中。如果我们在创建表时未指定 STATS_PERSISTENT 属性，那默认 采用系统变量 innodb_stats_persistent 的值作为该属性的值。</p>
<h3 id="132-基于磁盘的永久性统计数据">13.2 基于磁盘的永久性统计数据</h3>
<p>当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里:</p>
<pre><code class="language-mysql">mysql&gt; SHOW TABLES FROM mysql LIKE 'innodb%';
    +---------------------------+
    | Tables_in_mysql (innodb%) |
    +---------------------------+
    | innodb_index_stats        |
    | innodb_table_stats        |
    +---------------------------+
    2 rows in set (0.01 sec)
</code></pre>
<p>可以看到，这两个表都位于 mysql 系统数据库下边，其中:</p>
<ul>
<li>innodb_table_stats 存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li>
<li>innodb_index_stats 存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li>
</ul>
<h4 id="1321-innodb_table_stats">13.2.1 innodb_table_stats</h4>
<table>
<thead>
<tr>
<th style="text-align:center">字段名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>database_name</code></td>
<td style="text-align:left">数据库名</td>
</tr>
<tr>
<td style="text-align:center"><code>table_name</code></td>
<td style="text-align:left">表名</td>
</tr>
<tr>
<td style="text-align:center"><code>last_update</code></td>
<td style="text-align:left">本条记录最后更新时间</td>
</tr>
<tr>
<td style="text-align:center"><code>n_rows</code></td>
<td style="text-align:left">表中记录的条数</td>
</tr>
<tr>
<td style="text-align:center"><code>clustered_index_size</code></td>
<td style="text-align:left">表的聚簇索引占用的页面数量</td>
</tr>
<tr>
<td style="text-align:center"><code>sum_of_other_index_sizes</code></td>
<td style="text-align:left">表的其他索引占用的页面数量</td>
</tr>
</tbody>
</table>
<p>注意这个表的主键是 (database_name,table_name) ，也就是innodb_table_stats表的每条记录代表着一个表的统计信息。</p>
<h5 id="n_rows统计项的收集">n_rows统计项的收集</h5>
<p>InnoDB 统计一个表中有多少行记录的套路是这样的:</p>
<ul>
<li>按照一定算法(并不是纯粹随机的)选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平<br>
均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的 n_rows 值。</li>
</ul>
<p>可以看出来这个<code>n_rows</code>值精确与否取决于统计时采样的页面数量，设计MySQL很贴心的为我们准备了一个名为<code>innodb_stats_persistent_sample_pages</code>的系统变量来控制<span style="color:red">使用永久性的统计数据时，计算统计数据时采样的页面数量</span>。该值设置的越大，统计出的<code>n_rows</code>值越精确，但是统计耗时也就最久；该值设置的越小，统计出的<code>n_rows</code>值越不精确，但是统计耗时特别少。所以在实际使用是需要我们去权衡利弊，该系统变量的默认值是<code>20</code>。</p>
<p>我们前面说过，不过<code>InnoDB</code>默认是<span style="color:red">以表为单位来收集和存储统计数据的</span>，我们也可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过指定<code>STATS_SAMPLE_PAGES</code>属性来指明该表的统计数据存储方式：</p>
<pre><code class="language-mysql">    CREATE TABLE 表名 (...) Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;   
    ALTER TABLE 表名 Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;
</code></pre>
<h5 id="clustered_index_size和sum_of_other_index_sizes统计项的收集">clustered_index_size和sum_of_other_index_sizes统计项的收集</h5>
<p>这两个统计项的收集过程如下：</p>
<ol>
<li>从数据字典里找到表的各个索引对应的根页面位置。<br>
系统表<code>SYS_INDEXES</code>里存储了各个索引对应的根页面信息。</li>
<li>从根页面的<code>Page Header</code>里找到叶子节点段和非叶子节点段对应的<code>Segment Header</code>。<br>
在每个索引的根页面的<code>Page Header</code>部分都有两个字段：
<ul>
<li><code>PAGE_BTR_SEG_LEAF</code>：表示B+树叶子段的<code>Segment Header</code>信息。</li>
<li><code>PAGE_BTR_SEG_TOP</code>：表示B+树非叶子段的<code>Segment Header</code>信息。</li>
</ul>
</li>
<li>从叶子节点段和非叶子节点段的<code>Segment Header</code>中找到这两个段对应的<code>INODE Entry</code>结构。</li>
</ol>
<h4 id="1322-innodb_index_stats">13.2.2 innodb_index_stats</h4>
<table>
<thead>
<tr>
<th style="text-align:center">字段名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>database_name</code></td>
<td style="text-align:left">数据库名</td>
</tr>
<tr>
<td style="text-align:center"><code>table_name</code></td>
<td style="text-align:left">表名</td>
</tr>
<tr>
<td style="text-align:center"><code>index_name</code></td>
<td style="text-align:left">索引名</td>
</tr>
<tr>
<td style="text-align:center"><code>last_update</code></td>
<td style="text-align:left">本条记录最后更新时间</td>
</tr>
<tr>
<td style="text-align:center"><code>stat_name</code></td>
<td style="text-align:left">统计项的名称</td>
</tr>
<tr>
<td style="text-align:center"><code>stat_value</code></td>
<td style="text-align:left">对应的统计项的值</td>
</tr>
<tr>
<td style="text-align:center"><code>sample_size</code></td>
<td style="text-align:left">为生成统计数据而采样的页面数量</td>
</tr>
<tr>
<td style="text-align:center"><code>stat_description</code></td>
<td style="text-align:left">对应的统计项的描述</td>
</tr>
</tbody>
</table>
<p>注意这个表的主键是<code>(database_name,table_name,index_name,stat_name)</code>，其中的<code>stat_name</code>是指统计项的名称，也就是说<span style="color:red">innodb_index_stats表的每条记录代表着一个索引的一个统计项</span>。</p>
<h4 id="1323-定期更新统计数据">13.2.3 定期更新统计数据</h4>
<p>随着我们不断的对表进行增删改操作，表中的数据也一直在变化，<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表里的统计数据是不是也应该跟着变一变了？当然要变了，不变的话<code>MySQL</code>查询优化器计算的成本可就差老鼻子远了。<code>MySQL</code>提供了如下两种更新统计数据的方式：</p>
<ul>
<li>开启<code>innodb_stats_auto_recalc</code>。<br>
系统变量<code>innodb_stats_auto_recalc</code>决定着服务器是否自动重新计算统计数据，它的默认值是<code>ON</code>，也就是该功能默认是开启的。每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的<code>10%</code>，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表。不过<span style="color:red">自动重新计算统计数据的过程是异步发生的</span>，也就是即使表中变动的记录数超过了<code>10%</code>，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。</li>
</ul>
<p>再一次强调，<code>InnoDB</code>默认是<span style="color:red">以表为单位来收集和存储统计数据的</span>，我们也可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定<code>STATS_AUTO_RECALC</code>属性来指明该表的统计数据存储方式：</p>
<pre><code class="language-mysql">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_AUTO_RECALC = (1|0);
ALTER TABLE 表名 Engine=InnoDB, STATS_AUTO_RECALC = (1|0);
</code></pre>
<p>当<code>STATS_AUTO_RECALC=1</code>时，表明我们想让该表自动重新计算统计数据，当<code>STATS_PERSISTENT=0</code>时，表明不想让该表自动重新计算统计数据。如果我们在创建表时未指定<code>STATS_AUTO_RECALC</code>属性，那默认采用系统变量<code>innodb_stats_auto_recalc</code>的值作为该属性的值。</p>
<ul>
<li>手动调用<code>ANALYZE TABLE</code>语句来更新统计信息<br>
如果<code>innodb_stats_auto_recalc</code>系统变量的值为<code>OFF</code>的话，我们也可以手动调用<code>ANALYZE TABLE</code>语句来重新计算统计数据，比如我们可以这样更新关于<code>single_table</code>表的统计数据：</li>
</ul>
<pre><code class="language-mysql">mysql&gt; ANALYZE TABLE single_table;
</code></pre>
<p>需要注意的是，<span style="color:red">ANALYZE TABLE语句会立即重新计算统计数据，也就是这个过程是同步的</span>，在表中索引多或者采样页面特别多时这个过程可能会特别慢，请不要没事儿就运行一下<code>ANALYZE TABLE</code>语句，最好在业务不是很繁忙的时候再运行。</p>
<h4 id="1324-手动更新innodb_table_stats和innodb_index_stats表">13.2.4 手动更新<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表</h4>
<p>其实<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表就相当于一个普通的表一样，我们能对它们做增删改查操作。这也就意味着我们可以<span style="color:red">手动更新某个表或者索引的统计数据</span>。</p>
<p>更新完<code>innodb_table_stats</code>只是单纯的修改了一个表的数据，需要让<code>MySQL</code>查询优化器重新加载我们更改过的数据，运行下面的命令就可以了：</p>
<pre><code class="language-mysql">FLUSH TABLE single_table;
</code></pre>
<h3 id="133-基于内存的非永久性统计数据">13.3 基于内存的非永久性统计数据</h3>
<p>当我们把系统变量<code>innodb_stats_persistent</code>的值设置为<code>OFF</code>时，之后创建的表的统计数据默认就都是非永久性的了，或者我们直接在创建表或修改表时设置<code>STATS_PERSISTENT</code>属性的值为<code>0</code>，那么该表的统计数据就是非永久性的了。</p>
<p>与永久性的统计数据不同，非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p>
<p>另外，由于非永久性的统计数据经常更新，所以导致<code>MySQL</code>查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会<span style="color:red">生成经常变化的执行计划</span>。</p>
<h3 id="134-innodb_stats_method的使用">13.4 innodb_stats_method的使用</h3>
<p>我们知道<code>索引列不重复的值的数量</code>这个统计数据对于MySQL查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行，它的应用场景主要有两个：</p>
<ul>
<li>单表查询中单点区间太多，当<code>IN</code>里的参数数量过多时，采用<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量就太耗费性能了，所以直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。</li>
<li>连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用<code>ref</code>访问方法来对被驱动表进行查询。</li>
</ul>
<h3 id="135-总结">13.5 总结</h3>
<ul>
<li><code>InnoDB</code>以表为单位来收集统计数据，这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据。</li>
<li><code>innodb_stats_persistent</code>控制着使用永久性统计数据还是非永久性统计数据；<code>innodb_stats_persistent_sample_pages</code>控制着永久性统计数据的采样页面数量；<code>innodb_stats_transient_sample_pages</code>控制着非永久性统计数据的采样页面数量；<code>innodb_stats_auto_recalc</code>控制着是否自动重新计算统计数据。</li>
<li>我们可以针对某个具体的表，在创建和修改表时通过指定<code>STATS_PERSISTENT</code>、<code>STATS_AUTO_RECALC</code>、<code>STATS_SAMPLE_PAGES</code>的值来控制相关统计数据属性。</li>
<li><code>innodb_stats_method</code>决定着在统计某个索引列不重复值的数量时如何对待<code>NULL</code>值。</li>
</ul>
<h2 id="第十四章-不好看就要多整容-mysql基于规则的优化内含关于子查询优化二三事儿">第十四章 不好看就要多整容-MySQL基于规则的优化（内含关于子查询优化二三事儿）</h2>
<h3 id="141-条件化简">14.1 条件化简</h3>
<h4 id="1411-移除不必要的括号">14.1.1 移除不必要的括号</h4>
<p>有时候表达式里有许多无用的括号，优化器会把那些用不到的括号给干掉。</p>
<pre><code class="language-mysql">((a = 5 AND b = c) OR ((a &gt; c) AND (c &lt; 5)))
(a = 5 and b = c) OR (a &gt; c AND c &lt; 5)
</code></pre>
<h4 id="1412-常量传递constant_propagation">14.1.2 常量传递（constant_propagation）</h4>
<p>有时候某个表达式是某个列和某个常量做等值匹配，比如这样：</p>
<pre><code class="language-mysql">a = 5 AND b &gt; a
a = 5 AND b &gt; 5
</code></pre>
<p>当这个表达式和其他涉及列a的表达式使用AND连接起来时，可以将其他表达式中的a的值替换为5。</p>
<h4 id="1413-等值传递equality_propagation">14.1.3 等值传递（equality_propagation）</h4>
<p>有时候多个列之间存在等值匹配的关系，比如这样：</p>
<pre><code class="language-mysql">a = b and b = c and c = 5
a = 5 and b = 5 and c = 5
</code></pre>
<h4 id="1414-移除没用的条件trivial_condition_removal">14.1.4 移除没用的条件（trivial_condition_removal）</h4>
<p>对于一些明显永远为TRUE或者FALSE的表达式，优化器会移除掉它们，比如这个表达式：</p>
<pre><code class="language-mysql">(a &lt; 1 and b = b) OR (a = 6 OR 5 != 5)
(a &lt; 1 and TRUE) OR (a = 6 OR FALSE)
a &lt; 1 OR a = 6
</code></pre>
<h4 id="1415-表达式计算">14.1.5 表达式计算</h4>
<p>在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：a = 5 + 1,所以就会被化简成：a = 6,但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：ABS(a) &gt; 5 或者-a &lt; -8。</p>
<p>优化器是不会尝试对这些表达式进行化简的。我们前面说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中。</p>
<h4 id="1416-having子句和where子句的合并">14.1.6 HAVING子句和WHERE子句的合并</h4>
<p>如果查询语句中没有出现诸如SUM、MAX等等的聚集函数以及GROUP BY子句，优化器就把HAVING子句和WHERE子句合并起来。</p>
<h4 id="1417-常量表检测">14.1.7 常量表检测</h4>
<p>下面这两种查询运行的特别快：</p>
<ol>
<li>查询的表中一条记录没有，或者只有一条记录。</li>
<li>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。</li>
</ol>
<p>这两种查询花费的时间特别少，少到可以忽略，所以也把通过这两种方式查询的表称之为常量表（英文名：constant tables）。优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。</p>
<h3 id="142-外连接消除">14.2 外连接消除</h3>
<p>我们前面说过，内连接的驱动表和被驱动表的位置可以相互转换，而左（外）连接和右（外）连接的驱动表和被驱动表是固定的。这就导致内连接可能通过优化表的连接顺序来降低整体的查询成本，而外连接却无法优化表的连接顺序。</p>
<p>我们把这种在外连接查询中，指定的WHERE子句中包含被驱动表中的列不为NULL值的条件称之为空值拒绝（英文名：reject-NULL）。在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。</p>
<h3 id="143-子查询优化">14.3 子查询优化</h3>
<h4 id="1431-子查询语法">14.3.1 子查询语法</h4>
<p>在一个查询语句里的某个位置也可以有另一个查询语句，这个出现在某个查询语句的某个位置中的查询就被称为子查询。子查询可以在一个外层查询的各种位置出现，比如：</p>
<ol>
<li>SELECT子句中</li>
<li>FROM子句中</li>
<li>WHERE或ON子句中</li>
<li>ORDER BY子句中</li>
<li>GROUP BY子句中</li>
</ol>
<h5 id="按返回的结果集区分子查询">按返回的结果集区分子查询</h5>
<p>因为子查询本身也算是一个查询，所以可以按照它们返回的不同结果集类型而把这些子查询分为不同的类型：</p>
<ol>
<li>标量子查询<br>
那些只返回一个单一值的子查询称之为标量子查询</li>
<li>行子查询<br>
就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）</li>
<li>列子查询<br>
列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询了）</li>
<li>表子查询<br>
就是子查询的结果既包含很多条记录，又包含很多个列</li>
</ol>
<h5 id="按与外层查询关系来区分子查询">按与外层查询关系来区分子查询</h5>
<ol>
<li>不相关子查询<br>
  如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为不相关子查询。</li>
<li>相关子查询<br>
  如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为相关子查询。</li>
</ol>
<h5 id="子查询在布尔表达式中的使用">子查询在布尔表达式中的使用</h5>
<ol>
<li>
<p>使用=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt;作为布尔表达式的操作符<br>
我们就把这些操作符称为comparison_operator吧，所以子查询组成的布尔表达式就长这样：<mark>操作数 comparison_operator (子查询)</mark><br>
这里的操作数可以是某个列名，或者是一个常量，或者是一个更复杂的表达式，甚至可以是另一个子查询。但是需要注意的是，这里的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能返回一个单一的值或者只能是一条记录。</p>
</li>
<li>
<p>[NOT] IN/ANY/SOME/ALL子查询<br>
对于列子查询和表子查询来说，它们的结果集中包含很多条记录，这些记录相当于是一个集合，所以就不能单纯的和另外一个操作数使用comparison_operator来组成布尔表达式了，MySQL通过下面的语法来支持某个操作数和一个集合组成一个布尔表达式：</p>
<ul>
<li>IN或者NOT IN</li>
<li>ANY/SOME（ANY和SOME是同义词）</li>
<li>ALL</li>
</ul>
</li>
<li>
<p>EXISTS子查询</p>
</li>
</ol>
<h5 id="子查询语法注意事项">子查询语法注意事项</h5>
<ol>
<li>子查询必须用小括号扩起来。</li>
<li>在SELECT子句中的子查询必须是标量子查询</li>
<li>在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用LIMIT 1语句来限制记录数量。</li>
<li>对于[NOT] IN/ANY/SOME/ALL子查询来说，子查询中不允许有LIMIT语句。<br>
正因为[NOT] IN/ANY/SOME/ALL子查询不支持LIMIT语句，所以子查询中的这些语句也就是多余的了：
<ul>
<li>ORDER BY子句</li>
<li>DISTINCT语句</li>
<li>没有聚集函数以及HAVING子句的GROUP BY子句。</li>
</ul>
</li>
<li>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</li>
</ol>
<h4 id="1432-子查询在mysql中是怎么执行的">14.3.2 子查询在MySQL中是怎么执行的</h4>
<pre><code class="language-mysql">CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
</code></pre>
<h5 id="标量子查询-行子查询的执行方式">标量子查询、行子查询的执行方式</h5>
<p>我们经常在下面两个场景中使用到标量子查询或者行子查询：</p>
<ol>
<li>SELECT子句中，在查询列表中的子查询必须是标量子查询。</li>
<li>子查询使用=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt;等操作符和某个操作数组成一个布尔表达式，这样的子查询必须是标量子查询或者行子查询。</li>
</ol>
<p>对于上述两种场景中的不相关标量子查询或者行子查询来说，它们的执行方式是简单的，比方说下面这个查询语句：</p>
<pre><code class="language-mysql">SELECT * FROM s1 
    WHERE key1 = (SELECT common_field FROM s2 WHERE key3 = 'a' LIMIT 1);
</code></pre>
<ul>
<li>先单独执行(SELECT common_field FROM s2 WHERE key3 = 'a' LIMIT 1)这个子查询。</li>
<li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询SELECT * FROM s1 WHERE key1 = ...。</li>
</ul>
<p><code>对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。</code></p>
<p>对于相关的标量子查询或者行子查询来说，比如下面这个查询：</p>
<pre><code class="language-mysql">SELECT * FROM s1 WHERE 
    key1 = (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3 LIMIT 1);
</code></pre>
<ul>
<li>先从外层查询中获取一条记录</li>
<li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，然后执行子查询。</li>
<li>最后根据子查询的查询结果来检测外层查询WHERE子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li>
<li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li>
</ul>
<h5 id="in子查询优化">IN子查询优化</h5>
<p>对于不相关的IN子查询，比如这样：</p>
<pre><code class="language-mysql">SELECT * FROM s1 
    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
</code></pre>
<p>如果in中的结果参数比较多时，用表中的每条记录判断一下它的column列是否符合in中的参数，这样效率是十分低下的，MySQL给出的解决办法是<code>不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里</code>。写入临时表的过程是这样的：</p>
<ul>
<li>该临时表的列就是子查询结果集中的列。</li>
<li>写入临时表的记录会被去重。</li>
<li>一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用Memory存储引擎的临时表，而且会为该表建立希索引。</li>
</ul>
<blockquote>
<p>如果子查询的结果集非常大，超过了系统变量tmp_table_size或者max_heap_table_size，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为B+树索引。</p>
</blockquote>
<p>MySQL把这个将子查询结果集中的记录保存到临时表的过程称之为<code>物化</code>（英文名：Materialize）。为了方便起见，我们就把那个存储子查询结果集的临时表称之为<code>物化表</code>。正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行IN语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。</p>
<p>当我们把子查询进行物化之后，假设子查询物化表的名称为materialized_table，该物化表存储的子查询结果集的列为m_val，那么这个查询其实可以从下面两种角度来看待：</p>
<ol>
<li>从表s1的角度来看待，整个查询的意思其实是：对于s1表中的每条记录来说，如果该记录的key1列的值在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://q456qq520.github.io/post-images/1676885693905.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>从子查询物化表的角度来看待，整个查询的意思其实是：对于子查询物化表的每个值来说，如果能在s1表中找到对应的key1列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就是这样：</li>
</ol>
<figure data-type="image" tabindex="7"><img src="https://q456qq520.github.io/post-images/1676885722023.png" alt="" loading="lazy"></figure>
<p>也就是说其实上面的查询就相当于表s1和子查询物化表materialized_table进行内连接：</p>
<pre><code class="language-mysql">SELECT s1.* FROM s1 INNER JOIN materialized_table ON key1 = m_val;
</code></pre>
<p>转化成内连接之后，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。我们分析一下上述查询中使用外层查询的表s1和物化表materialized_table进行内连接的成本都是由哪几部分组成的：<br>
如果使用s1表作为驱动表的话，总查询成本由下面几个部分组成：</p>
<ul>
<li>物化子查询时需要的成本</li>
<li>扫描s1表时的成本</li>
<li>s1表中的记录数量 × 通过m_val = xxx对materialized_table表进行单表访问的成本</li>
</ul>
<p>如果使用materialized_table表作为驱动表的话，总查询成本由下面几个部分组成：</p>
<ul>
<li>物化子查询时需要的成本</li>
<li>扫描物化表时的成本</li>
<li>物化表中的记录数量 × 通过key1 = xxx对s1表进行单表访问的成本</li>
</ul>
<p>MySQL查询优化器会通过运算来选择上述成本更低的方案来执行查询。</p>
<h5 id="将子查询转换为semi-join">将子查询转换为semi-join</h5>
<p>虽然将子查询进行物化之后再执行查询都会有建立临时表的成本，但是不管怎么说，我们见识到了将子查询转换为连接的强大作用，但是能不能不进行物化操作直接把子查询转换为连接呢？让我们重新审视一下上面的查询语句：</p>
<p>我们可以把这个查询理解成：对于s1表中的某条记录，如果我们能在s2表（准确的说是执行完WHERE s2.key3 = 'a'之后的结果集）中找到一条或多条记录，这些记录的common_field的值等于s1表记录的key1列的值，那么该条s1表的记录就会被加入到最终的结果集。这个过程其实和把s1和s2两个表连接起来的效果很像：</p>
<pre><code class="language-mysql">SELECT s1.* FROM s1 INNER JOIN s2 
    ON s1.key1 = s2.common_field 
    WHERE s2.key3 = 'a';
</code></pre>
<p>只不过我们不能保证对于s1表的某条记录来说，在s2表（准确的说是执行完WHERE s2.key3 = 'a'之后的结果集）中有多少条记录满足s1.key1 = s2.common_field这个条件，不过我们可以分三种情况讨论：</p>
<ul>
<li>情况一：对于s1表的某条记录来说，s2表中没有任何记录满足s1.key1 = s2.common_field这个条件，那么该记录自然也不会加入到最后的结果集。</li>
<li>情况二：对于s1表的某条记录来说，s2表中有且只有记录满足s1.key1 = s2.common_field这个条件，那么该记录会被加入最终的结果集。</li>
<li>情况三：对于s1表的某条记录来说，s2表中至少有2条记录满足s1.key1 = s2.common_field这个条件，那么该记录会被多次加入最终的结果集。</li>
</ul>
<p>对于s1表的某条记录来说，由于我们只关心s2表中是否存在记录满足s1.key1 = s2.common_field这个条件，而不关心具体有多少条记录与之匹配，又因为有情况三的存在，我们上面所说的IN子查询和两表连接之间并不完全等价。但是将子查询转换为连接又真的可以充分发挥优化器的作用，MySQL在这里提出了一个新概念 --- <code>半连接（英文名：semi-join）</code>。将s1表和s2表进行半连接的意思就是：<code>对于s1表的某条记录来说，我们只关心在s2表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留s1表的记录</code>。为了让大家有更直观的感受，我们假设MySQL内部是这么改写上面的子查询的：</p>
<pre><code class="language-mysql">SELECT s1.* FROM s1 SEMI JOIN s2
    ON s1.key1 = s2.common_field
    WHERE key3 = 'a';
</code></pre>
<p>概念是有了，怎么实现这种所谓的半连接呢？</p>
<ul>
<li><code>Table pullout （子查询中的表上拉）</code><br>
当子查询的查询列表处<code>只有主键或者唯一索引列</code>时，可以直接把子查询中的表上拉到外层查询的FROM子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中，比如这个<br>
假设key2列是s2表的唯一二级索引列，所以我们可以直接把s2表上拉到外层查询的FROM子句中，并且把子查询中的搜索条件合并到外层查询的搜索条件中，上拉之后的查询就是这样的：</li>
</ul>
<pre><code class="language-mysql">SELECT s1.* FROM s1 INNER JOIN s2 
    ON s1.key2 = s2.key2 
    WHERE s2.key3 = 'a';
</code></pre>
<ul>
<li>
<p><code>DuplicateWeedout execution strategy （重复值消除）</code><br>
在执行连接查询的过程中，每当某条s1表中的记录要加入结果集时，就首先把这条记录的id值加入到这个临时表里，如果添加成功，说明之前这条s1表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，说明这条之前这条s1表中的记录已经加入过最终的结果集，这里直接把它丢弃就好了，这种使用临时表消除semi-join结果集中的重复值的方式称之为DuplicateWeedout。</p>
</li>
<li>
<p><code>LooseScan execution strategy （松散索引扫描）</code><br>
假设有如下查询</p>
</li>
</ul>
<pre><code class="language-mysql">  SELECT * FROM s1 
    WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 &gt; 'a' AND key1 &lt; 'b');
</code></pre>
<p>在子查询中，对于s2表的访问可以使用到key1列的索引，而恰好子查询的查询列表处就是key1列，这样在将该查询转换为半连接查询后，如果将s2作为驱动表执行查询的话，那么执行过程就是这样：<br>
<img src="https://q456qq520.github.io/post-images/1676886879861.png" alt="" loading="lazy"><br>
在s2表的idx_key1索引中，值为'aa'的二级索引记录一共有3条，那么只需要取第一条的值到s1表中查找s1.key3 = 'aa'的记录，如果能在s1表中找到对应的记录，那么就把对应的记录加入到结果集。依此类推，其他值相同的二级索引记录，也只需要取第一条记录的值到s1表中找匹配的记录，这种虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为松散索引扫描。</p>
<ul>
<li>
<p><code>Semi-join Materialization execution strategy</code><br>
先把外层查询的IN子句中的不相关子查询进行物化，然后再进行外层查询的表和物化表的连接本质上也算是一种semi-join，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。</p>
</li>
<li>
<p><code>FirstMatch execution strategy （首次匹配）</code><br>
FirstMatch是一种最原始的半连接执行方式，就是说先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上面这个过程。</p>
</li>
</ul>
<p>如果子查询的查询列表处只有主键或者唯一二级索引列，还可以直接使用table pullout的策略来执行查询，但是需要大家注意的是，由于<code>相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询</code>。</p>
<p><strong>semi-join的适用条件</strong><br>
并不是所有包含IN子查询的查询语句都可以转换为semi-join，只有形如这样的查询才可以被转换为semi-join：</p>
<pre><code class="language-mysql">SELECT ... FROM outer_tables 
    WHERE expr IN (SELECT ... FROM inner_tables ...) AND ...

SELECT ... FROM outer_tables 
    WHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...
</code></pre>
<p>1、 该子查询必须是和IN语句组成的布尔表达式，并且在外层查询的WHERE或者ON子句中出现。<br>
2、外层查询也可以有其他的搜索条件，只不过和IN子查询的搜索条件必须使用AND连接起来。<br>
3、该子查询必须是一个单一的查询，不能是由若干查询由UNION连接起来的形式。<br>
4、该子查询不能包含GROUP BY或者HAVING语句或者聚集函数。</p>
<p><strong>不适用于semi-join的情况</strong><br>
1、外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用OR连接起来<br>
2、使用NOT IN而不是IN的情况<br>
3、在SELECT子句中的IN子查询的情况（SELECT key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a') FROM s1 ;）<br>
4、子查询中包含GROUP BY、HAVING或者聚集函数的情况<br>
5、子查询中包含UNION的情况</p>
<p>MySQL仍然留了两手绝活来优化不能转为semi-join查询的子查询，那就是：<br>
1、对于不相关子查询来说，可以尝试把它们物化之后再参与查询</p>
<pre><code class="language-mysql">SELECT * FROM s1 
    WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = 'a')
</code></pre>
<p>先将子查询物化，然后再判断key1是否在物化表的结果集中可以加快查询执行的速度。这里将子查询物化之后不能转为和外层查询的表的连接，只能是先扫描s1表，然后对s1表的某条记录来说，判断该记录的key1值在不在物化表中。<br>
2、不管子查询是相关的还是不相关的，都可以把IN子查询尝试专为EXISTS子查询<br>
链接:<a href="/post/lesslesscong-gen-er-shang-li-jie-mysqlgreatergreater-du-shu-bi-ji-si">《从根儿上理解MySQL》读书笔记(四)</a></p>

							</div>
	<div class="wow bounceInDown vt-post-tags">
 
				<a href="https://q456qq520.github.io/tag/d7gCKq8FS/" rel="tag">mysql</a>	
				 
					</div>						
<nav class="navigation3 post-navigation3" role="navigation">
		
		<div class="nav-links3">
      
		<div class="wow bounceInLeft nav-previous3"><a href="https://q456qq520.github.io/post/mian-shi-ti-yi/" rel="prev"> 面试题（一）</a></div>
		 
		 
		<div class="wow bounceInRight nav-next3"><a href="https://q456qq520.github.io/post/dong-tai-xian-cheng-chi/" rel="next"> 动态线程池</a></div>
		
		</div>
	</nav>
	<div class="wow rollIn author-info" style="visibility: visible; animation-name: rollIn;">
	<div class="author-avatar pull-left"><img src="https://q456qq520.github.io/images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">LIKECAT</div></div>


	<p class="author-bio">一条小咸鱼</p></div></div>
	
		</div>
		
 
		
</article>

<div id="marlin_lite_about_widget-2" class="wow bounceInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">
		
        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1e61bc4630cf7e3c0b8e',
    clientSecret: 'd1728142222f511a472443c6e499356387ab3b96',
    repo: 'q456qq520.github.io',
    owner: 'q456qq520',
    admin: ['q456qq520'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          
          
        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://q456qq520.github.io/media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            // AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)
            av: AV, 
            el: '.comment',
            lang: 'zh-cn',
            
            
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     	
      	
          
        });
    </script> 


   
  
 

		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">
	
        <div class="toc-widget">
			
            <div class="toc-title"></div>
			
            <div id="toc-content">
			
			
			</div>
        </div>
    </div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.5.0/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>										 

 
       


			</div>
		</div>

		
		 	<footer id="colophon" class="site-footer">

			<div class="container">
	
				<div class="copyright">Powered by <a href="https://blog.csdn.net/weixin_42652031" target="_blank">一条小咸鱼</a><br>Theme:   <a href="https://github.com/alterfang/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>. Powered by <a href="https://gridea.dev/" target="_blank" title="Gridea"><span>Gridea</span></a></div>		
			</div>
		
		</footer>

</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://q456qq520.github.io/media/scripts/marlin-scripts.js'></script>
 <script src="//tokinx.github.io/lately/lately.min.js"></script>
  <script>jQuery(document).ready(function(){$.lately({'target':'.lately-a,.lately-b,.lately-c'})});</script>
  <style type="text/css">a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
}

a.back_to_top span {
    color: #888;
}

a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
}

a.back_to_top:hover span {
    color: #555;
}

@media print, screen and (max-width: 580px) {
    .back_to_top {
        display: none !important;
    }
}



</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>


<script>$(document).ready((function(_this) {
  return function() {
    var bt;
    bt = $('#back_to_top');
    if ($(document).width() > 480) {
      $(window).scroll(function() {
        var st;
        st = $(window).scrollTop();
        if (st > 30) {
          return bt.css('display', 'block');
        } else {
          return bt.css('display', 'none');
        }
      });
      return bt.click(function() {
        $('body,html').animate({
          scrollTop: 0
        }, 800);
        return false;
      });
    }
  };
})(this));
</script>

		<script data-no-instant>
    (function ($) {
        $.extend({
            adamsOverload: function () {
                $('.navigation:eq(0)').remove();
                $("").attr("rel" , "external");
                $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
                $("a.vi").attr("rel" , "");
                $.viewImage({
                    'target'  : 'img',
                    'exclude' : '.vsmile-icons img,.gallery img',
                    'delay'   : 300
                });
                $.lately({
                    'target' : '.commentmetadata a,.infos time,.post-list time'
                });
                prettyPrint();
                
                $('ul.links li a').each(function(){
                    if($(this).parent().find('.bg').length==0){
                        $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
                    }
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
