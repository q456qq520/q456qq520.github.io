
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> 
<meta HTTP-EQUIV="expires" CONTENT="0"> 
<title>RocketMq技术内幕笔记（一） | LIKECAT</title>	

<link rel="stylesheet" href="https://q456qq520.github.io/styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

        if (thehour<07)

            display = "https://q456qq520.github.io/media/css/night.css";

       else if (thehour>18)

            display = "https://q456qq520.github.io/media/css/night.css";   

        else if (thehour>07)
           
            display = "https://q456qq520.github.io/media/css/day.css";

        else if (thehour<18)

            display = "https://q456qq520.github.io/media/css/day.css";
      

var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://fonts.googleapis.com/css?family=Dancing+Script|Noto+Sans+SC:300|Montserrat&display=swap" rel="stylesheet">
<link href="https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<script type='text/javascript' src='https://q456qq520.github.io/media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>


 	
</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">
        
			
		<header id="header" class="site-header" 
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://q456qq520.github.io" rel="home">LIKECAT</a></h1>
										
					<h2 class="site-description">一条小咸鱼</h2>
										
							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 
     			
<li>
	 
	<a  href="/"> 首页</a></li>
	
    
     			
<li>
	 
	<a  href="/archives"> 归档</a></li>
	
    
     			
<li>
	 
	<a  href="/tags"> 标签</a></li>
	
    
     			
<li>
	 
	<a  href="/post/about"> 关于</a></li>
	
    
     			
<li>
	 
	<a  href="https://q456qq520.github.io/tag/CH4G4OVER/"> 设计模式</a></li>
	
    
     			
<li>
	 
	<a  href="https://q456qq520.github.io/tag/fenbushi/"> 分布式</a></li>
	
    

</ul>
</li>		
		
</ul>				</div>
			</nav>
						<div class="jingge">


    

    

    

    

    

    

    

    

    

    

    

    
        </header>

		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">
				
<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">

	
	                      
		<div class="entry-content">
			<h1 class="wow swing entry-title">RocketMq技术内幕笔记（一）</h1>
<div class="entry-meta">
<div class="wow bounce">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2022-09-07 17:47:04" itemprop="datePublished" pubdate="">2022-09-07</time></i>
	          </div>
			
</span>
													 
		</div>
                  
			<div class="wow slideInLeft entry-summary song">
				<h1 id="1-大纲">1 大纲</h1>
<h2 id="11-rocketmq-原代码的目录结构">1.1 RocketMQ 原代码的目录结构</h2>
<p>RocketMQ 核心目 录说明如下 。</p>
<ol>
<li>broker: broker模块(broker启动进程) 。</li>
</ol>
<!-- more --> 
<ol start="3">
<li>client:消息客户端，包含消息生产者、消息消费者相关类。</li>
<li>common:公共包。</li>
<li>dev:开发者信息(非源代码)。</li>
<li>distribution:部署实例文件夹(非源代码)。</li>
<li>example: RocketMQ 示例代码 。</li>
<li>filter:消息过滤相关基础类。</li>
<li>filtersrv: 消息过滤服务器实现相关类(Filter启动进程)。</li>
<li>logappender:日志实现相关类。</li>
<li>namesrv : NameServer 实现相关类(Names巳rver启动进程) 。</li>
<li>openmessaging: 消息开放标准，正在制定中 。</li>
<li>remoting: 远程通信模块，基于 Netty。</li>
<li>srvutil:服务器工具类。</li>
<li>store:消息存储实现相关类 。</li>
<li>style: checkstyle相关实现。</li>
<li>test: 测试相关类。</li>
<li>tools: 工具类，监控命令相关实现类。</li>
</ol>
<h2 id="12-rocketmq-的设计理念和目标">1.2 RocketMQ 的设计理念和目标</h2>
<h3 id="121-设计理念">1.2.1 设计理念</h3>
<p>RocketMQ 设计基于主题的发布与 订阅 模式 ， (Broker)、消息消费。</p>
<p>NameServer：实现元数据的管理(Topic路由信息等)，因为 Topic 路由信息无须在集群之 间保持强一致，追求最终一致性，并且能容 忍分钟级的 不一致 。</p>
<p>高效的IO存储机制：RocketMQ追求消息发送的高吞吐量， RocketMQ 的消息存储文件设计成文件组的概念，组内单个文件大小固定，方便引人内存 l映射机制，所 有主 题的消息存储基于顺序写，极大地提高了消息写性能， 同时为了兼顾消息消费与消息查找，引入了消息消费队列文件与索引文件。</p>
<h3 id="122-设计能力">1.2.2 设计能力</h3>
<ol>
<li>
<p>架构模式<br>
RocketMQ 与大部分消息中间件一样，采用发布订阅模式，基本的参与组件主要包括 :<br>
消息发送者、消息服务器(消息存储)、消息消费、路由发现 。</p>
</li>
<li>
<p>顺序消息<br>
所谓顺序消息，就是消息消费者按照消息达到消息存储服务器的顺序消费 。 RocketMQ 可以严格保证消息有序 。</p>
</li>
<li>
<p>消息过滤<br>
RocketMQ 消息过滤支持在服务端与消费端的消息过滤机制 。<br>
1 )消息在 Broker 端过滤。Broker只将消息消费者感兴趣的消息发送给消息消费者 。<br>
2 )消息在消息消费端过滤，消息过滤方式完全由消息消费者自定义，但缺点是有很多无用的消息会从 Broker传输到消费端。</p>
</li>
<li>
<p>消息存储<br>
RocketMQ 追求消息存储的高性能，引人内存映射机制，所有主题的消息顺序存储在同一个文件中 。 同时为了避免消息无限在消息存储服务器中累积，引入了消息文件过期机制与文件存储空间报警机制。</p>
</li>
<li>
<p>消息高可用性<br>
通常影响消息可靠性的有以下几种情况 。</p>
</li>
</ol>
<ol>
<li>Broker正常关机。</li>
<li>Broker异常 Crash。</li>
<li>OS Crash。</li>
<li>机器断电，但 是 能立即恢复供电情况 。</li>
<li>机器无法开机(可能是 CPU、主板、 内存等关键设备损 坏)。</li>
<li>磁盘设备损坏。<br>
情况 1~4 的 RocketMQ 在同步刷盘机制下可以确保不丢失消息，在异步刷盘模式下，会丢失少量消息 。 情况 5-6 属于单点故障，一旦发生，该节点上的消息全 部丢失，如果开启了异步复制机制， RoketMQ 能保证只丢失少量消息。</li>
</ol>
<ol start="6">
<li>
<p>消息到达 (消费)低延迟<br>
RocketMQ在消息不发生消息堆积时，以长轮询模式实现准实时的消息推送模式。</p>
</li>
<li>
<p>确保消息必须被消费一次<br>
RocketMQ 通过消息消费确认机制(ACK)来确保消息至少被消费一次，但由于ACK消息有可能丢失等其他原因，RocketMQ无法做到消息只被消费一次，有重复消费的可能。</p>
</li>
<li>
<p>回溯消息<br>
回溯消息是指消息消费端已经消费成功的消息，由于业务要求需要重新消费消息。 RocketMQ 支持按时间回溯消息，时间维度可精确到毫秒，可以向前或向后回溯。</p>
</li>
<li>
<p>消息堆积<br>
RocketMQ 消息存储使用磁盘文件 (内存映射机制)，并且在物理布局上为多个大小相等的文件组成逻辑文件组，可以无限循环使用。 RocketMQ消息存储文件并不是永久存储在消息服务器端，而是提供了过期机制，默认保留3天。</p>
</li>
<li>
<p>定时消息<br>
定 时消息 是指消息发送到 Broker 后， 不能被消息消费端立即消费，要到特定的时间点或者等待特定的时间后才能被消费。 如果要支持任意精度的定时消息消费，必须在消息服务端对消息进行排序，势必带来很大的性能损耗，故RocketMQ不支持任意精度的定时消息，而只支持特定延迟级别。</p>
</li>
<li>
<p>消息重试机制<br>
消息重试是指消息在消费时，如果发送异常，消息中间件需要支持消息重新投递，RocketMQ支持消息重试机制。</p>
</li>
</ol>
<h1 id="2-rocketmq路由中心nameserver">2 RocketMQ路由中心NameServer</h1>
<h2 id="21-nameserver-架构设计">2.1 NameServer 架构设计</h2>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1663034308783.png" alt="RocketMQ 物理部署图" loading="lazy"></figure>
<p>Broker消息服务器在启动时向所有 NameServer注册，消息生产者(Producer)在发送消 息之前先从 NameServer获取Broker 服务器地址列表，然后根据负载算法从列表中选择一 台消息服务器进行消息发送。NameServer与每台 Broker 服务器保持长连接，并间隔30s检测Broker是否存活，如果检测到 Broker右机，则从路由注册表中将其移除。但是路由变化不会马上通知消息生产者。</p>
<p>NameServer本身的高可用可通过部 署多台 NameServer服务器来实现，但彼此之间互不通信，也就是 NameServer服务器之间在某一时刻的数据并不会完全相同，但这对消 息发送不会造成任何影响。</p>
<h2 id="22-nameserver-启动流程">2.2 NameServer 启动流程</h2>
<p>NameServer启动类 : org.apache.rocketmq.namesrv.NamesrvStartup。</p>
<ol>
<li>Step 1: 首先来解析配置文件，需要填充 NameServerConfig、NettyServerConfig属性值。</li>
</ol>
<pre><code class="language-java">  public static void parseCommandlineAndConfigFile(String[] args) throws Exception {
        System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));
        //PackageConflictDetect.detectFastjson();

        Options options = ServerUtil.buildCommandlineOptions(new Options());
        CommandLine commandLine = ServerUtil.parseCmdLine(&quot;mqnamesrv&quot;, args, buildCommandlineOptions(options), new PosixParser());
        if (null == commandLine) {
            System.exit(-1);
            return;
        }

        namesrvConfig = new NamesrvConfig();
        nettyServerConfig = new NettyServerConfig();
        nettyClientConfig = new NettyClientConfig();
        nettyServerConfig.setListenPort(9876);
        controllerConfig = new ControllerConfig();
        if (commandLine.hasOption('c')) {
            String file = commandLine.getOptionValue('c');
            if (file != null) {
                InputStream in = new BufferedInputStream(Files.newInputStream(Paths.get(file)));
                properties = new Properties();
                properties.load(in);
                MixAll.properties2Object(properties, namesrvConfig);
                MixAll.properties2Object(properties, nettyServerConfig);
                MixAll.properties2Object(properties, nettyClientConfig);
                MixAll.properties2Object(properties, controllerConfig);

                namesrvConfig.setConfigStorePath(file);

                System.out.printf(&quot;load config properties file OK, %s%n&quot;, file);
                in.close();
            }
        }

        if (commandLine.hasOption('p')) {
            MixAll.printObjectProperties(null, namesrvConfig);
            MixAll.printObjectProperties(null, nettyServerConfig);
            MixAll.printObjectProperties(null, nettyClientConfig);
            MixAll.printObjectProperties(null, controllerConfig);
            System.exit(0);
        }

        MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);

        if (null == namesrvConfig.getRocketmqHome()) {
            System.out.printf(&quot;Please set the %s variable in your environment to match the location of the RocketMQ installation%n&quot;, MixAll.ROCKETMQ_HOME_ENV);
            System.exit(-2);
        }

        LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
        JoranConfigurator configurator = new JoranConfigurator();
        configurator.setContext(lc);
        lc.reset();
        configurator.doConfigure(namesrvConfig.getRocketmqHome() + &quot;/conf/logback_namesrv.xml&quot;);

        log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);

        MixAll.printObjectProperties(log, namesrvConfig);
        MixAll.printObjectProperties(log, nettyServerConfig);
    }
</code></pre>
<p>创建 NameServerConfig ( NameServer业务参数)、NettyServer-Config ( NameServer网络参数)，然后在解析启动时把指定的配置文件或启动命令中的选项 值，填充到 nameServerConfig,nettyServerConfig对象。</p>
<pre><code class="language-java">public class NamesrvConfig {
    //rocketmq 主目录，可以通过 -Drocketmq.home.dir=path或通过设置环境变量 ROCKETMQ_HOME 来配置 RocketMQ 的主目录 。
    private String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));

    //NameServer存储 KV 配置属性 的持久化路径 
    private String kvConfigPath = System.getProperty(&quot;user.home&quot;) + File.separator + &quot;namesrv&quot; + File.separator + &quot;kvConfig.json&quot;;

    //NameServer 默认配置文件路径
    private String configStorePath = System.getProperty(&quot;user.home&quot;) + File.separator + &quot;namesrv&quot; + File.separator + &quot;namesrv.properties&quot;;
    private String productEnvName = &quot;center&quot;;
    private boolean clusterTest = false;

    //是否支持顺序消息，默认是不支持
    private boolean orderMessageEnable = false;
    private boolean returnOrderTopicConfigToBroker = true;
}
</code></pre>
<pre><code class="language-java">public class NettyServerConfig implements Cloneable {

    //NameServer监昕端口，该值默认会被初始化为 9876
    private int listenPort = 0;

    //Netty业务线程池线程个数。
    private int serverWorkerThreads = 8;

    //Netty public任务线程池线程个数，Netty网络设计，
    //根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等 。
    //如果该业务类型(RequestCode)未注册线程池， 则由 public线程池执行。
    private int serverCallbackExecutorThreads = 0;

    //IO线程池线程个数，主要是 NameServer、Broker端解析请求、返回相应的线程个数，这类线程主要是处理网络请求的解析请求包，然后转发到
    //各个业务线程池完成具体的业务操作，然后将结果再返回调用方 。
    private int serverSelectorThreads = 3;

    //send oneway 消息请求井发度
    private int serverOnewaySemaphoreValue = 256;

    //异步消息发送最大并发度
    private int serverAsyncSemaphoreValue = 64;

    //网络连接最大空闲时间，默认120s。 如果连接空闲时间超过该参数设置的值，连接将被关闭。
    private int serverChannelMaxIdleTimeSeconds = 120;

    //网络 socket发送缓存区大小， 默认 64k
    private int serverSocketSndBufSize = NettySystemConfig.socketSndbufSize;
    //网络 socket接收缓存区大小 ，默认 64k
    private int serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize;
    private int writeBufferHighWaterMark = NettySystemConfig.writeBufferHighWaterMark;
    private int writeBufferLowWaterMark = NettySystemConfig.writeBufferLowWaterMark;
    private int serverSocketBacklog = NettySystemConfig.socketBacklog;
    //ByteBuffer是否开启缓存 ， 建议开启
    private boolean serverPooledByteBufAllocatorEnable = true;

    /**
     * make install
     * ../glibc-2.10.1/configure \ --prefix=/usr \ --with-headers=/usr/include \
     * --host=x86_64-linux-gnu \ --build=x86_64-pc-linux-gnu \ --without-gd
     */
    //是否启用EpollIO模型， Linux环境建议开启。
    private boolean useEpollNativeSelector = false;
}
</code></pre>
<blockquote>
<p>️启动 NameServer时，可以先使用/mqnameserver-c configFile -p 打印当前加载的配置属性</p>
</blockquote>
<ol start="2">
<li>Step2:根据启动属性创建 NamesrvController实例，并初始化该实例，实例为NameServer核心控制器。</li>
</ol>
<pre><code class="language-java">  public boolean initialize() {
        //加载kvConfigPath下kvConfig.json配置文件里的KV配置，然后将这些配置放到KVConfigManager#configTable属性中
        loadConfig();
        //根据nettyServerConfig初始化一个netty服务器。
        initiateNetworkComponents();
        //初始化负责处理Netty网络交互数据的线程池，默认线程数是16个
        initiateThreadExecutors();
        ////注册Netty服务端业务处理逻辑，如果开启了clusterTest，那么注册的请求处理类是ClusterTestRequestProcessor，否则请求处理类是DefaultRequestProcessor
        registerProcessor();
        //注册心跳机制线程池，延迟5毫秒启动，每隔5秒遍历RouteInfoManager#brokerLiveTable这个属性，用来扫描不存活的broker
        //注册打印KV配置线程池，延迟1分钟启动、每10分钟打印出kvConfig配置
        startScheduleService();
        initiateSslContext();
        initiateRpcHooks();
        return true;
    }
</code></pre>
<ol start="3">
<li>Step3 :注册JVM钩子函数并启动服务器，以便监昕 Broker、消息生产者的网络请求 。</li>
</ol>
<pre><code class="language-java">//在 JVM 进程关闭之前，先将线程池关闭，及时释放资源 。
        Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, (Callable&lt;Void&gt;) () -&gt; {
            controller.shutdown();
            return null;
        }));

        controller.start();
</code></pre>
<h2 id="23-nameserver-路由注册-故障剔除">2.3 NameServer 路由注册、故障剔除</h2>
<p>NameServer主要作用是为消息生产者和消息消费者提供关于主题Topic的路由信息，那么NameServer需要存储路由的基础信息，还要能够管理Broker节点，包括路由注册、 路由删除等功能。</p>
<h3 id="231-路由元信息">2.3.1 路由元信息</h3>
<p>NameServer路由实现类: org.apache.rocketmq.namesrv.routeinfo.RoutelnfoManager</p>
<blockquote>
<p>RoutelnfoManage 路由元数据</p>
</blockquote>
<pre><code class="language-java">public class RouteInfoManager {
    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);
    private final static long DEFAULT_BROKER_CHANNEL_EXPIRED_TIME = 1000 * 60 * 2;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    //Topic 消息队列路由信息，消息发送时根据路由表进行负 载均衡 。
    private final Map&lt;String/* topic */, Map&lt;String, QueueData&gt;&gt; topicQueueTable;

    //Broker 基础信息， 包含 brokerName、 所属集群名称 、 主备 Broker地址。
    private final Map&lt;String/* brokerName */, BrokerData&gt; brokerAddrTable;

    //Broker 集群信息，存储集群中所有 Broker 名称 。
    private final Map&lt;String/* clusterName */, Set&lt;String/* brokerName */&gt;&gt; clusterAddrTable;
    //Broker 状态信息 。 NameServer 每次 收到心跳包时会 替换该信 息
    private final Map&lt;BrokerAddrInfo/* brokerAddr */, BrokerLiveInfo&gt; brokerLiveTable;
    // Broker上的 FilterServer列表，用于类模式消息过滤
    private final Map&lt;BrokerAddrInfo/* brokerAddr */, List&lt;String&gt;/* Filter Server */&gt; filterServerTable;
    private final Map&lt;String/* topic */, Map&lt;String/*brokerName*/, TopicQueueMappingInfo&gt;&gt; topicQueueMappingInfoTable;

    private final BatchUnregistrationService unRegisterService;

    private final NamesrvController namesrvController;
    private final NamesrvConfig namesrvConfig;
}
</code></pre>
<p>RocketMQ基于订阅发布机制，一个Topic拥有多个消息队列 ，一个Broker为每一主题默认创建4个读队列4个写队列。多个Broker组成一个集群，BrokerName由相同的多台Broker组成Master-Slave架构 ， brokerId为0代表 Master，大于0表示Slave。 BrokerLivelnfo中的lastUpdateTimestamp 存储上次收到Broker心跳包的时间。</p>
<h3 id="232-路由注册">2.3.2 路由注册</h3>
<p>RocketMQ路由注册是通过 Broker与NameServer的心跳功能实现的。Broker启动时 向 集群中 所有的 NameServer发送心跳语句，每隔30s向 集群 中所 有 NameServer发送心跳包，NameServer收到Broker心跳包时会更新brokerLiveTable缓存中BrokerLivelnfo的lastUpdateTimestamp，然后NameServer每隔10s扫描 brokerLiveTable，如果连续120s没有收到心跳包， NameServer将移除该 Broker的路由信息同时关闭Socket连接。</p>
<ol>
<li>Broker发送心跳包</li>
</ol>
<blockquote>
<p>Broker端心跳包发送</p>
</blockquote>
<pre><code class="language-java">  scheduledFutures.add(this.scheduledExecutorService.scheduleAtFixedRate(new AbstractBrokerRunnable(this.getBrokerIdentity()) {
            @Override
            public void run2() {
                try {
                    if (System.currentTimeMillis() &lt; shouldStartTime) {
                        BrokerController.LOG.info(&quot;Register to namesrv after {}&quot;, shouldStartTime);
                        return;
                    }
                    if (isIsolated) {
                        BrokerController.LOG.info(&quot;Skip register for broker is isolated&quot;);
                        return;
                    }
                    BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister());
                } catch (Throwable e) {
                    BrokerController.LOG.error(&quot;registerBrokerAll Exception&quot;, e);
                }
            }
        }, 1000 * 10, Math.max(10000, Math.min(brokerConfig.getRegisterNameServerPeriod(), 60000)), TimeUnit.MILLISECONDS));
</code></pre>
<blockquote>
<p>registerBrokerAll</p>
</blockquote>
<pre><code class="language-java">   final List&lt;RegisterBrokerResult&gt; registerBrokerResultList = new CopyOnWriteArrayList&lt;&gt;();

final CountDownLatch countDownLatch = new CountDownLatch(nameServerAddressList.size());
    for (final String namesrvAddr : nameServerAddressList) {
        brokerOuterExecutor.execute(new AbstractBrokerRunnable(brokerIdentity) {
            @Override
            public void run2() {
                try {
                    RegisterBrokerResult result = registerBroker(namesrvAddr, oneway, timeoutMills, requestHeader, body);
                    if (result != null) {
                        registerBrokerResultList.add(result);
                    }

                    LOGGER.info(&quot;Registering current broker to name server completed. TargetHost={}&quot;, namesrvAddr);
                } catch (Exception e) {
                    LOGGER.error(&quot;Failed to register current broker to name server. TargetHost={}&quot;, namesrvAddr, e);
                } finally {
                    countDownLatch.countDown();
                }
            }
        });
    }

        try {
        if (!countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS)) {
            LOGGER.warn(&quot;Registration to one or more name servers does NOT complete within deadline. Timeout threshold: {}ms&quot;, timeoutMills);
        }
    } catch (InterruptedException ignore) {
    }
</code></pre>
<p>该方法主要是遍历 NameServer列表，Broker消息服务器依次向 NameServer发送心跳包。</p>
<pre><code class="language-java">  private RegisterBrokerResult registerBroker(
            final String namesrvAddr,
            final boolean oneway,
            final int timeoutMills,
            final RegisterBrokerRequestHeader requestHeader,
            final byte[] body
    ) throws RemotingCommandException, MQBrokerException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException,
            InterruptedException {
        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.REGISTER_BROKER, requestHeader);
        request.setBody(body);

        if (oneway) {
            try {
                this.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);
            } catch (RemotingTooMuchRequestException e) {
                // Ignore
            }
            return null;
        }
        //....
    }
</code></pre>
<p>发送心跳包具体逻辑，首先封装请求包头( Header)。</p>
<p>brokerAddr: broker 地址 。<br>
brokerId: brokerld,0:Master;大 0: Slave。<br>
brokerName:broker名称。<br>
clusterName: 集群名称。<br>
haServerAddr: master 地址，初次请求时该值为空，slave 向Nameserver注册后返回。<br>
requestBody:<br>
filterServerList：消息过滤服务器列表。<br>
topicConfigWrapper：主题配置。</p>
<pre><code class="language-java">    final RegisterBrokerRequestHeader requestHeader = new RegisterBrokerRequestHeader();
    requestHeader.setBrokerAddr(brokerAddr);
    requestHeader.setBrokerId(brokerId);
    requestHeader.setBrokerName(brokerName);
    requestHeader.setClusterName(clusterName);
    requestHeader.setHaServerAddr(haServerAddr);
    requestHeader.setEnableActingMaster(enableActingMaster);
    requestHeader.setCompressed(false);

    RegisterBrokerBody requestBody = new RegisterBrokerBody();
    requestBody.setTopicConfigSerializeWrapper(TopicConfigAndMappingSerializeWrapper.from(topicConfigWrapper));
    requestBody.setFilterServerList(filterServerList);
</code></pre>
<blockquote>
<p>RocketMQ网络传输基于 Netty,每一个请求，RocketMQ都会定义一个RequestCode，然后在服务端会对应相应的网络处理器 (processor包中)。</p>
</blockquote>
<ol start="2">
<li>NameServer处理心跳包</li>
</ol>
<p>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor 网络处理器解析请求类型， 如果请求类型为RequestCode.REGISTER_BROKER，则请求最终转发到RoutelnfoMan ager#registerBroker。</p>
<pre><code class="language-java">this.lock.writeLock().lockInterruptibly();

//init or update the cluster info
Set&lt;String&gt; brokerNames = this.clusterAddrTable.computeIfAbsent(clusterName, k -&gt; new HashSet&lt;&gt;());
brokerNames.add(brokerName);
</code></pre>
<ul>
<li>Step1:路由注册需要加写锁，防止并发修改RoutelnfoManager中的路由表。</li>
</ul>
<pre><code class="language-java">// 是否第一个注册
boolean registerFirst = false; 
BrokerData brokerData = this.brokerAddrTable.get(brokerName);
if (null == brokerData) {
    registerFirst = true;
    brokerData = new BrokerData(clusterName, brokerName, new HashMap&lt;&gt;());
    this.brokerAddrTable.put(brokerName, brokerData);
}

boolean isOldVersionBroker = enableActingMaster == null;
brokerData.setEnableActingMaster(!isOldVersionBroker &amp;&amp; enableActingMaster);
brokerData.setZoneName(zoneName);

//省略

String oldAddr = brokerAddrsMap.put(brokerId, brokerAddr);
registerFirst = registerFirst || (StringUtils.isEmpty(oldAddr));
</code></pre>
<p>Step2 :维护BrokerData信息，首先从brokerAddrTable根据 BrokerName尝试获取 Broker信息，如果不存在，则新建BrokerData并放入到brokerAddrTable, registerFirst设置为 true;如果存在，直接替换原先的，registerFirst设置为false，表示非第一次注册。</p>
<pre><code class="language-java">boolean isMaster = MixAll.MASTER_ID == brokerId;
boolean isPrimeSlave = !isOldVersionBroker &amp;&amp; !isMaster
        &amp;&amp; brokerId == Collections.min(brokerAddrsMap.keySet());
if (null != topicConfigWrapper &amp;&amp; (isMaster || isPrimeSlave)) {

        ConcurrentMap&lt;String, TopicConfig&gt; tcTable =
                topicConfigWrapper.getTopicConfigTable();
        if (tcTable != null) {
            for (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) {
                if (registerFirst || this.isTopicConfigChanged(clusterName, brokerAddr,
                        topicConfigWrapper.getDataVersion(), brokerName,
                        entry.getValue().getTopicName())) {
                    final TopicConfig topicConfig = entry.getValue();
                    if (isPrimeSlave) {
                        // Wipe write perm for prime slave
                        topicConfig.setPerm(topicConfig.getPerm() &amp; (~PermName.PERM_WRITE));
                    }
                    this.createAndUpdateQueueData(brokerName, topicConfig);
                }
            }
        }
}
</code></pre>
<ul>
<li>Step3 :如果Broker为Master，并且BrokerTopic配置信息发生变化或者是初次注册，则需要创建或更新 Topic路由元数据，填充topicQueueTable，其实就是为默认主题自动注 册路由信息其中包含 MixAII.DEFAULT_TOPIC的路由信息。当消息生产者发送主题时，如果该主题未创建并且BrokerConfig的autoCreateTopicEnable为true时，将返回MixAII. DEFAULT_TOPIC的路由信息。</li>
</ul>
<pre><code class="language-java">private void createAndUpdateQueueData(final String brokerName, final TopicConfig topicConfig) {
    QueueData queueData = new QueueData();
    queueData.setBrokerName(brokerName);
    queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());
    queueData.setReadQueueNums(topicConfig.getReadQueueNums());
    queueData.setPerm(topicConfig.getPerm());
    queueData.setTopicSysFlag(topicConfig.getTopicSysFlag());

    Map&lt;String, QueueData&gt; queueDataMap = this.topicQueueTable.get(topicConfig.getTopicName());
    if (null == queueDataMap) {
        queueDataMap = new HashMap&lt;&gt;();
        queueDataMap.put(brokerName, queueData);
        this.topicQueueTable.put(topicConfig.getTopicName(), queueDataMap);
        log.info(&quot;new topic registered, {} {}&quot;, topicConfig.getTopicName(), queueData);
    } else {
        final QueueData existedQD = queueDataMap.get(brokerName);
        if (existedQD == null) {
            queueDataMap.put(brokerName, queueData);
        } else if (!existedQD.equals(queueData)) {
            log.info(&quot;topic changed, {} OLD: {} NEW: {}&quot;, topicConfig.getTopicName(), existedQD,
                queueData);
            queueDataMap.put(brokerName, queueData);
        }
    }
}
</code></pre>
<p>根据 TopicConfig创建 QueueData数据结构 ，然后更新 topicQueueTable。</p>
<pre><code class="language-java">BrokerAddrInfo brokerAddrInfo = new BrokerAddrInfo(clusterName, brokerAddr);
BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddrInfo,
        new BrokerLiveInfo(
                System.currentTimeMillis(),
                timeoutMillis == null ? DEFAULT_BROKER_CHANNEL_EXPIRED_TIME : timeoutMillis,
                topicConfigWrapper == null ? new DataVersion() : topicConfigWrapper.getDataVersion(),
                channel,
                haServerAddr));
if (null == prevBrokerLiveInfo) {
    log.info(&quot;new broker registered, {} HAService: {}&quot;, brokerAddrInfo, haServerAddr);
}
</code></pre>
<ul>
<li>Step4: 更新BrokerLivelnfo，存活Broker信息表， BrokeLivelnfo是执行路由删除的重要依据。</li>
</ul>
<pre><code class="language-java">if (filterServerList != null) {
    if (filterServerList.isEmpty()) {
        this.filterServerTable.remove(brokerAddrInfo);
    } else {
        this.filterServerTable.put(brokerAddrInfo, filterServerList);
    }
}

if (MixAll.MASTER_ID != brokerId) {
    String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);
    if (masterAddr != null) {
        BrokerAddrInfo masterAddrInfo = new BrokerAddrInfo(clusterName, masterAddr);
        BrokerLiveInfo masterLiveInfo = this.brokerLiveTable.get(masterAddrInfo);
        if (masterLiveInfo != null) {
            result.setHaServerAddr(masterLiveInfo.getHaServerAddr());
            result.setMasterAddr(masterAddr);
        }
    }
}
</code></pre>
<ul>
<li>Step5 : 注册Broker的过滤器Server地址列表，一个Broker上会关联多个FilterServer消息过滤服务器;如果此Broker为从节点，则需要查找该Broker的Master 的节点信息，并更新对应的masterAddr属性 。</li>
</ul>
<blockquote>
<p>NameServe与Broker保持长连接， Broker状态存储在 brokerLiveTable中，NameServer每收到一个心跳包，将更新 brokerLiveTable中关于Broker的状态信息以及路 由表( topicQueueTable、 brokerAddrTable、brokerLiveTable、filterServerTable)。 更新上述 路由表( HashTable)使用了锁粒度较少的<strong>读写锁</strong>，允许多个消息发送者( Producer)并发读，保证消息发送时的高并发。但同一时刻NameServer只处理一个Broker心跳包，多个心跳包请求串行执行。</p>
</blockquote>
<h3 id="233-路由删除">2.3.3 路由删除</h3>
<p>NameServer会每隔10s扫描brokerLiveTable状态表，如果BrokerLive的lastUpdateTimestamp的时间戳距当前时间超过 120s，则认为Broker失效，移除该 Broker, 关闭与Broker连接，并同时更新topicQueueTable、brokerAddrTable、brokerLiveTable、filterServerTable。</p>
<p>RocktMQ有两个触发点来触发路由删除。</p>
<ol>
<li>NameServer定时扫描 brokerLiveTable检测上次心跳包与当前系统时间的时间差，如果时间戳大于 120s则需要移除该 Broker信息 。<br>
2 ) Broker在正常被关闭的情况下会执行unregisterBroker指令。</li>
</ol>
<pre><code class="language-java">public void scanNotActiveBroker() {
    try {
        log.info(&quot;start scanNotActiveBroker&quot;);
        for (Entry&lt;BrokerAddrInfo, BrokerLiveInfo&gt; next : this.brokerLiveTable.entrySet()) {
            long last = next.getValue().getLastUpdateTimestamp();
            long timeoutMillis = next.getValue().getHeartbeatTimeoutMillis();
            if ((last + timeoutMillis) &lt; System.currentTimeMillis()) {
                RemotingUtil.closeChannel(next.getValue().getChannel());
                log.warn(&quot;The broker channel expired, {} {}ms&quot;, next.getKey(), timeoutMillis);
                this.onChannelDestroy(next.getKey());
            }
        }
    } catch (Exception e) {
        log.error(&quot;scanNotActiveBroker exception&quot;, e);
    }
}
</code></pre>
<pre><code class="language-java">public void onChannelDestroy(BrokerAddrInfo brokerAddrInfo) {
    UnRegisterBrokerRequestHeader unRegisterRequest = new UnRegisterBrokerRequestHeader();
    boolean needUnRegister = false;
    if (brokerAddrInfo != null) {
        try {
            try {
                this.lock.readLock().lockInterruptibly();
                needUnRegister = setupUnRegisterRequest(unRegisterRequest, brokerAddrInfo);
            } finally {
                this.lock.readLock().unlock();
            }
        } catch (Exception e) {
            log.error(&quot;onChannelDestroy Exception&quot;, e);
        }
    }

    if (needUnRegister) {
        boolean result = this.submitUnRegisterBrokerRequest(unRegisterRequest);
        log.info(&quot;the broker's channel destroyed, submit the unregister request at once, &quot; +
            &quot;broker info: {}, submit result: {}&quot;, unRegisterRequest, result);
    }
}
</code></pre>
<p>Step1 :申请写锁，把需要移除的broker添加到阻塞队列。</p>
<pre><code class="language-java">public void unRegisterBroker(Set&lt;UnRegisterBrokerRequestHeader&gt; unRegisterRequests) {
        try {
            try {
                Set&lt;String&gt; removedBroker = new HashSet&lt;&gt;();
                Set&lt;String&gt; reducedBroker = new HashSet&lt;&gt;();
                Map&lt;String, BrokerStatusChangeInfo&gt; needNotifyBrokerMap = new HashMap&lt;&gt;();

                this.lock.writeLock().lockInterruptibly();
                for (final UnRegisterBrokerRequestHeader unRegisterRequest : unRegisterRequests) {
                    final String brokerName = unRegisterRequest.getBrokerName();
                    final String clusterName = unRegisterRequest.getClusterName();

                    BrokerAddrInfo brokerAddrInfo = new BrokerAddrInfo(clusterName, unRegisterRequest.getBrokerAddr());

                    BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.remove(brokerAddrInfo);
                    log.info(&quot;unregisterBroker, remove from brokerLiveTable {}, {}&quot;,
                        brokerLiveInfo != null ? &quot;OK&quot; : &quot;Failed&quot;,
                        brokerAddrInfo
                    );

                    this.filterServerTable.remove(brokerAddrInfo);

                    boolean removeBrokerName = false;
                    boolean isMinBrokerIdChanged = false;
                    BrokerData brokerData = this.brokerAddrTable.get(brokerName);
                    if (null != brokerData) {
                        if (!brokerData.getBrokerAddrs().isEmpty() &amp;&amp;
                            unRegisterRequest.getBrokerId().equals(Collections.min(brokerData.getBrokerAddrs().keySet()))) {
                            isMinBrokerIdChanged = true;
                        }
                        String addr = brokerData.getBrokerAddrs().remove(unRegisterRequest.getBrokerId());
                        log.info(&quot;unregisterBroker, remove addr from brokerAddrTable {}, {}&quot;,
                            addr != null ? &quot;OK&quot; : &quot;Failed&quot;,
                            brokerAddrInfo
                        );
                        if (brokerData.getBrokerAddrs().isEmpty()) {
                            this.brokerAddrTable.remove(brokerName);
                            log.info(&quot;unregisterBroker, remove name from brokerAddrTable OK, {}&quot;,
                                brokerName
                            );

                            removeBrokerName = true;
                        } else if (isMinBrokerIdChanged) {
                            needNotifyBrokerMap.put(brokerName, new BrokerStatusChangeInfo(
                                brokerData.getBrokerAddrs(), addr, null));
                        }
                    }

                    if (removeBrokerName) {
                        Set&lt;String&gt; nameSet = this.clusterAddrTable.get(clusterName);
                        if (nameSet != null) {
                            boolean removed = nameSet.remove(brokerName);
                            log.info(&quot;unregisterBroker, remove name from clusterAddrTable {}, {}&quot;,
                                removed ? &quot;OK&quot; : &quot;Failed&quot;,
                                brokerName);

                            if (nameSet.isEmpty()) {
                                this.clusterAddrTable.remove(clusterName);
                                log.info(&quot;unregisterBroker, remove cluster from clusterAddrTable {}&quot;,
                                    clusterName
                                );
                            }
                        }
                        removedBroker.add(brokerName);
                    } else {
                        reducedBroker.add(brokerName);
                    }
                }

                cleanTopicByUnRegisterRequests(removedBroker, reducedBroker);

                if (!needNotifyBrokerMap.isEmpty() &amp;&amp; namesrvConfig.isNotifyMinBrokerIdChanged()) {
                    notifyMinBrokerIdChanged(needNotifyBrokerMap);
                }
            } finally {
                this.lock.writeLock().unlock();
            }
        } catch (Exception e) {
            log.error(&quot;unregisterBroker Exception&quot;, e);
        }
    }
</code></pre>
<p>Step2 :统一删除每个map中元数据。</p>
<pre><code class="language-java">private void cleanTopicByUnRegisterRequests(Set&lt;String&gt; removedBroker, Set&lt;String&gt; reducedBroker) {
    Iterator&lt;Entry&lt;String, Map&lt;String, QueueData&gt;&gt;&gt; itMap = this.topicQueueTable.entrySet().iterator();
    while (itMap.hasNext()) {
        Entry&lt;String, Map&lt;String, QueueData&gt;&gt; entry = itMap.next();

        String topic = entry.getKey();
        Map&lt;String, QueueData&gt; queueDataMap = entry.getValue();

        for (final String brokerName : removedBroker) {
            final QueueData removedQD = queueDataMap.remove(brokerName);
            if (removedQD != null) {
                log.debug(&quot;removeTopicByBrokerName, remove one broker's topic {} {}&quot;, topic, removedQD);
            }
        }

        if (queueDataMap.isEmpty()) {
            log.debug(&quot;removeTopicByBrokerName, remove the topic all queue {}&quot;, topic);
            itMap.remove();
        }

        for (final String brokerName : reducedBroker) {
            final QueueData queueData = queueDataMap.get(brokerName);

            if (queueData != null) {
                if (this.brokerAddrTable.get(brokerName).isEnableActingMaster()) {
                    // Master has been unregistered, wipe the write perm
                    if (isNoMasterExists(brokerName)) {
                        queueData.setPerm(queueData.getPerm() &amp; (~PermName.PERM_WRITE));
                    }
                }
            }
        }
    }
}
</code></pre>
<p>Step3 :删除Topic队列中元数据。</p>
<h3 id="234-路由发现">2.3.4 路由发现</h3>
<p>RocketMQ路由发现是非实时的，当Topic路由出现变化后，NameServer不主动推送给客户端，而是由客户端定时拉取主题最新的路由。根据主题名称拉取路由信息的命令编码为: GET_ROUTEINTO_BY_TOPIC。</p>
<pre><code class="language-java">public class TopicRouteData extends RemotingSerializable {

    //顺序消息配置内容，来自于 kvConfig。
    private String orderTopicConf;
    //topic 队列元数据 
    private List&lt;QueueData&gt; queueDatas;
    //topic分布的 broker元数据
    private List&lt;BrokerData&gt; brokerDatas;
    //broker上过滤服务器地址列表。
    private HashMap&lt;String/* brokerAddr */, List&lt;String&gt;/* Filter Server */&gt; filterServerTable;
    //It could be null or empty
    private Map&lt;String/*brokerName*/, TopicQueueMappingInfo&gt; topicQueueMappingByBroker;
}
</code></pre>
<pre><code class="language-java">public RemotingCommand getRouteInfoByTopic(ChannelHandlerContext ctx,
        RemotingCommand request) throws RemotingCommandException {
        final RemotingCommand response = RemotingCommand.createResponseCommand(null);
        final GetRouteInfoRequestHeader requestHeader =
            (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);

        TopicRouteData topicRouteData = this.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());

        if (topicRouteData != null) {
            if (this.namesrvController.getNamesrvConfig().isOrderMessageEnable()) {
                String orderTopicConf =
                    this.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,
                        requestHeader.getTopic());
                topicRouteData.setOrderTopicConf(orderTopicConf);
            }

            byte[] content;
            Boolean standardJsonOnly = requestHeader.getAcceptStandardJsonOnly();
            if (request.getVersion() &gt;= MQVersion.Version.V4_9_4.ordinal() || (null != standardJsonOnly &amp;&amp; standardJsonOnly)) {
                content = topicRouteData.encode(SerializerFeature.BrowserCompatible,
                    SerializerFeature.QuoteFieldNames, SerializerFeature.SkipTransientField,
                    SerializerFeature.MapSortField);
            } else {
                content = topicRouteData.encode();
            }

            response.setBody(content);
            response.setCode(ResponseCode.SUCCESS);
            response.setRemark(null);
            return response;
        }

        response.setCode(ResponseCode.TOPIC_NOT_EXIST);
        response.setRemark(&quot;No topic route info in name server for the topic: &quot; + requestHeader.getTopic()
            + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));
        return response;
    }
</code></pre>
<p>Step1:调用 RouterlnfoManager 的方法，从路由 表 topicQueueTable、 brokerAddrTable、 filterServerTable中分别填充TopicRouteData中的List<QueueData>、List<BrokerData>和 filterServer 地址表 。<br>
Step2 : 如果找到主题对应的路由信息并且该主题为顺序消息，则从 NameServer KVconfig 中获取关于顺序消息相关 的配置填充路由信息 。</p>
<p>如果找不到路由信息CODE则使用 TOPIC_NOT_EXISTS ，表示没有找到对应的路由 。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1663067880142.png" alt="NameServer 路由 注册、删除机制" loading="lazy"></figure>

							</div>
	<div class="wow bounceInDown vt-post-tags">
 
				<a href="https://q456qq520.github.io/tag/TtqxBbsHq/" rel="tag">rocketMq</a>	
				 
				<a href="https://q456qq520.github.io/tag/nsbXrS9tg/" rel="tag">mq</a>	
				 
					</div>						
<nav class="navigation3 post-navigation3" role="navigation">
		
		<div class="nav-links3">
      
		<div class="wow bounceInLeft nav-previous3"><a href="https://q456qq520.github.io/post/rocketmq-ji-zhu-nei-mu-bi-ji-er/" rel="prev"> RocketMq技术内幕笔记（二）</a></div>
		 
		 
		<div class="wow bounceInRight nav-next3"><a href="https://q456qq520.github.io/post/redis60-de-xin-te-xing/" rel="next"> Redis6.0的新特性</a></div>
		
		</div>
	</nav>
	<div class="wow rollIn author-info" style="visibility: visible; animation-name: rollIn;">
	<div class="author-avatar pull-left"><img src="https://q456qq520.github.io/images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">LIKECAT</div></div>


	<p class="author-bio">一条小咸鱼</p></div></div>
	
		</div>
		
 
		
</article>

<div id="marlin_lite_about_widget-2" class="wow bounceInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">
		
        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1e61bc4630cf7e3c0b8e',
    clientSecret: 'd1728142222f511a472443c6e499356387ab3b96',
    repo: 'q456qq520.github.io',
    owner: 'q456qq520',
    admin: ['q456qq520'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          
          
        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://q456qq520.github.io/media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            // AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)
            av: AV, 
            el: '.comment',
            lang: 'zh-cn',
            
            
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     	
      	
          
        });
    </script> 


   
  
 

		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">
	
        <div class="toc-widget">
			
            <div class="toc-title"></div>
			
            <div id="toc-content">
			
			
			</div>
        </div>
    </div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.5.0/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>										 

 
       


			</div>
		</div>

		
		 	<footer id="colophon" class="site-footer">

			<div class="container">
	
				<div class="copyright">Powered by <a href="https://blog.csdn.net/weixin_42652031" target="_blank">一条小咸鱼</a><br>Theme:   <a href="https://github.com/alterfang/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>. Powered by <a href="https://gridea.dev/" target="_blank" title="Gridea"><span>Gridea</span></a></div>		
			</div>
		
		</footer>

</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://q456qq520.github.io/media/scripts/marlin-scripts.js'></script>
 <script src="//tokinx.github.io/lately/lately.min.js"></script>
  <script>jQuery(document).ready(function(){$.lately({'target':'.lately-a,.lately-b,.lately-c'})});</script>
  <style type="text/css">a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
}

a.back_to_top span {
    color: #888;
}

a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
}

a.back_to_top:hover span {
    color: #555;
}

@media print, screen and (max-width: 580px) {
    .back_to_top {
        display: none !important;
    }
}



</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>


<script>$(document).ready((function(_this) {
  return function() {
    var bt;
    bt = $('#back_to_top');
    if ($(document).width() > 480) {
      $(window).scroll(function() {
        var st;
        st = $(window).scrollTop();
        if (st > 30) {
          return bt.css('display', 'block');
        } else {
          return bt.css('display', 'none');
        }
      });
      return bt.click(function() {
        $('body,html').animate({
          scrollTop: 0
        }, 800);
        return false;
      });
    }
  };
})(this));
</script>

		<script data-no-instant>
    (function ($) {
        $.extend({
            adamsOverload: function () {
                $('.navigation:eq(0)').remove();
                $("").attr("rel" , "external");
                $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
                $("a.vi").attr("rel" , "");
                $.viewImage({
                    'target'  : 'img',
                    'exclude' : '.vsmile-icons img,.gallery img',
                    'delay'   : 300
                });
                $.lately({
                    'target' : '.commentmetadata a,.infos time,.post-list time'
                });
                prettyPrint();
                
                $('ul.links li a').each(function(){
                    if($(this).parent().find('.bg').length==0){
                        $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
                    }
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
